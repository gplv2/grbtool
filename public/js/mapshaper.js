( function( f ) {
    if ( typeof exports === "object" && typeof module !== "undefined" ) {
        module.exports = f()
    } else if ( typeof define === "function" && define.amd ) {
        define( [], f )
    } else {
        var g;
        if ( typeof window !== "undefined" ) {
            g = window
        } else if ( typeof global !== "undefined" ) {
            g = global
        } else if ( typeof self !== "undefined" ) {
            g = self
        } else {
            g = this
        }
        g.mapshaper = f()
    }
} )( function() {
    var define, module, exports;
    return function() {
        function e( t, n, r ) {
            function s( o, u ) {
                if ( !n[ o ] ) {
                    if ( !t[ o ] ) {
                        var a = typeof require == "function" && require;
                        if ( !u && a ) return a( o, !0 );
                        if ( i ) return i( o, !0 );
                        var f = new Error( "Cannot find module '" + o + "'" );
                        throw f.code = "MODULE_NOT_FOUND", f
                    }
                    var l = n[ o ] = {
                        exports: {}
                    };
                    t[ o ][ 0 ].call( l.exports, function( e ) {
                        var n = t[ o ][ 1 ][ e ];
                        return s( n ? n : e )
                    }, l, l.exports, e, t, n, r )
                }
                return n[ o ].exports
            }
            var i = typeof require == "function" && require;
            for ( var o = 0; o < r.length; o++ ) s( r[ o ] );
            return s
        }
        return e
    }()( {
        1: [ function( require, module, exports ) {
            "use strict";
            exports.byteLength = byteLength;
            exports.toByteArray = toByteArray;
            exports.fromByteArray = fromByteArray;
            var lookup = [];
            var revLookup = [];
            var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for ( var i = 0, len = code.length; i < len; ++i ) {
                lookup[ i ] = code[ i ];
                revLookup[ code.charCodeAt( i ) ] = i
            }
            revLookup[ "-".charCodeAt( 0 ) ] = 62;
            revLookup[ "_".charCodeAt( 0 ) ] = 63;

            function placeHoldersCount( b64 ) {
                var len = b64.length;
                if ( len % 4 > 0 ) {
                    throw new Error( "Invalid string. Length must be a multiple of 4" )
                }
                return b64[ len - 2 ] === "=" ? 2 : b64[ len - 1 ] === "=" ? 1 : 0
            }

            function byteLength( b64 ) {
                return b64.length * 3 / 4 - placeHoldersCount( b64 )
            }

            function toByteArray( b64 ) {
                var i, l, tmp, placeHolders, arr;
                var len = b64.length;
                placeHolders = placeHoldersCount( b64 );
                arr = new Arr( len * 3 / 4 - placeHolders );
                l = placeHolders > 0 ? len - 4 : len;
                var L = 0;
                for ( i = 0; i < l; i += 4 ) {
                    tmp = revLookup[ b64.charCodeAt( i ) ] << 18 | revLookup[ b64.charCodeAt( i + 1 ) ] << 12 | revLookup[ b64.charCodeAt( i + 2 ) ] << 6 | revLookup[ b64.charCodeAt( i + 3 ) ];
                    arr[ L++ ] = tmp >> 16 & 255;
                    arr[ L++ ] = tmp >> 8 & 255;
                    arr[ L++ ] = tmp & 255
                }
                if ( placeHolders === 2 ) {
                    tmp = revLookup[ b64.charCodeAt( i ) ] << 2 | revLookup[ b64.charCodeAt( i + 1 ) ] >> 4;
                    arr[ L++ ] = tmp & 255
                } else if ( placeHolders === 1 ) {
                    tmp = revLookup[ b64.charCodeAt( i ) ] << 10 | revLookup[ b64.charCodeAt( i + 1 ) ] << 4 | revLookup[ b64.charCodeAt( i + 2 ) ] >> 2;
                    arr[ L++ ] = tmp >> 8 & 255;
                    arr[ L++ ] = tmp & 255
                }
                return arr
            }

            function tripletToBase64( num ) {
                return lookup[ num >> 18 & 63 ] + lookup[ num >> 12 & 63 ] + lookup[ num >> 6 & 63 ] + lookup[ num & 63 ]
            }

            function encodeChunk( uint8, start, end ) {
                var tmp;
                var output = [];
                for ( var i = start; i < end; i += 3 ) {
                    tmp = ( uint8[ i ] << 16 & 16711680 ) + ( uint8[ i + 1 ] << 8 & 65280 ) + ( uint8[ i + 2 ] & 255 );
                    output.push( tripletToBase64( tmp ) )
                }
                return output.join( "" )
            }

            function fromByteArray( uint8 ) {
                var tmp;
                var len = uint8.length;
                var extraBytes = len % 3;
                var output = "";
                var parts = [];
                var maxChunkLength = 16383;
                for ( var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength ) {
                    parts.push( encodeChunk( uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength ) )
                }
                if ( extraBytes === 1 ) {
                    tmp = uint8[ len - 1 ];
                    output += lookup[ tmp >> 2 ];
                    output += lookup[ tmp << 4 & 63 ];
                    output += "=="
                } else if ( extraBytes === 2 ) {
                    tmp = ( uint8[ len - 2 ] << 8 ) + uint8[ len - 1 ];
                    output += lookup[ tmp >> 10 ];
                    output += lookup[ tmp >> 4 & 63 ];
                    output += lookup[ tmp << 2 & 63 ];
                    output += "="
                }
                parts.push( output );
                return parts.join( "" )
            }
        }, {} ],
        2: [ function( require, module, exports ) {}, {} ],
        3: [ function( require, module, exports ) {
            arguments[ 4 ][ 2 ][ 0 ].apply( exports, arguments )
        }, {
            dup: 2
        } ],
        4: [ function( require, module, exports ) {
            "use strict";
            var base64 = require( "base64-js" );
            var ieee754 = require( "ieee754" );
            exports.Buffer = Buffer;
            exports.SlowBuffer = SlowBuffer;
            exports.INSPECT_MAX_BYTES = 50;
            var K_MAX_LENGTH = 2147483647;
            exports.kMaxLength = K_MAX_LENGTH;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if ( !Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function" ) {
                console.error( "This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support." )
            }

            function typedArraySupport() {
                try {
                    var arr = new Uint8Array( 1 );
                    arr.__proto__ = {
                        __proto__: Uint8Array.prototype,
                        foo: function() {
                            return 42
                        }
                    };
                    return arr.foo() === 42
                } catch ( e ) {
                    return false
                }
            }
            Object.defineProperty( Buffer.prototype, "parent", {
                get: function() {
                    if ( !( this instanceof Buffer ) ) {
                        return undefined
                    }
                    return this.buffer
                }
            } );
            Object.defineProperty( Buffer.prototype, "offset", {
                get: function() {
                    if ( !( this instanceof Buffer ) ) {
                        return undefined
                    }
                    return this.byteOffset
                }
            } );

            function createBuffer( length ) {
                if ( length > K_MAX_LENGTH ) {
                    throw new RangeError( "Invalid typed array length" )
                }
                var buf = new Uint8Array( length );
                buf.__proto__ = Buffer.prototype;
                return buf
            }

            function Buffer( arg, encodingOrOffset, length ) {
                if ( typeof arg === "number" ) {
                    if ( typeof encodingOrOffset === "string" ) {
                        throw new Error( "If encoding is specified then the first argument must be a string" )
                    }
                    return allocUnsafe( arg )
                }
                return from( arg, encodingOrOffset, length )
            }
            if ( typeof Symbol !== "undefined" && Symbol.species && Buffer[ Symbol.species ] === Buffer ) {
                Object.defineProperty( Buffer, Symbol.species, {
                    value: null,
                    configurable: true,
                    enumerable: false,
                    writable: false
                } )
            }
            Buffer.poolSize = 8192;

            function from( value, encodingOrOffset, length ) {
                if ( typeof value === "number" ) {
                    throw new TypeError( '"value" argument must not be a number' )
                }
                if ( isArrayBuffer( value ) || value && isArrayBuffer( value.buffer ) ) {
                    return fromArrayBuffer( value, encodingOrOffset, length )
                }
                if ( typeof value === "string" ) {
                    return fromString( value, encodingOrOffset )
                }
                return fromObject( value )
            }
            Buffer.from = function( value, encodingOrOffset, length ) {
                return from( value, encodingOrOffset, length )
            };
            Buffer.prototype.__proto__ = Uint8Array.prototype;
            Buffer.__proto__ = Uint8Array;

            function assertSize( size ) {
                if ( typeof size !== "number" ) {
                    throw new TypeError( '"size" argument must be of type number' )
                } else if ( size < 0 ) {
                    throw new RangeError( '"size" argument must not be negative' )
                }
            }

            function alloc( size, fill, encoding ) {
                assertSize( size );
                if ( size <= 0 ) {
                    return createBuffer( size )
                }
                if ( fill !== undefined ) {
                    return typeof encoding === "string" ? createBuffer( size ).fill( fill, encoding ) : createBuffer( size ).fill( fill )
                }
                return createBuffer( size )
            }
            Buffer.alloc = function( size, fill, encoding ) {
                return alloc( size, fill, encoding )
            };

            function allocUnsafe( size ) {
                assertSize( size );
                return createBuffer( size < 0 ? 0 : checked( size ) | 0 )
            }
            Buffer.allocUnsafe = function( size ) {
                return allocUnsafe( size )
            };
            Buffer.allocUnsafeSlow = function( size ) {
                return allocUnsafe( size )
            };

            function fromString( string, encoding ) {
                if ( typeof encoding !== "string" || encoding === "" ) {
                    encoding = "utf8"
                }
                if ( !Buffer.isEncoding( encoding ) ) {
                    throw new TypeError( "Unknown encoding: " + encoding )
                }
                var length = byteLength( string, encoding ) | 0;
                var buf = createBuffer( length );
                var actual = buf.write( string, encoding );
                if ( actual !== length ) {
                    buf = buf.slice( 0, actual )
                }
                return buf
            }

            function fromArrayLike( array ) {
                var length = array.length < 0 ? 0 : checked( array.length ) | 0;
                var buf = createBuffer( length );
                for ( var i = 0; i < length; i += 1 ) {
                    buf[ i ] = array[ i ] & 255
                }
                return buf
            }

            function fromArrayBuffer( array, byteOffset, length ) {
                if ( byteOffset < 0 || array.byteLength < byteOffset ) {
                    throw new RangeError( '"offset" is outside of buffer bounds' )
                }
                if ( array.byteLength < byteOffset + ( length || 0 ) ) {
                    throw new RangeError( '"length" is outside of buffer bounds' )
                }
                var buf;
                if ( byteOffset === undefined && length === undefined ) {
                    buf = new Uint8Array( array )
                } else if ( length === undefined ) {
                    buf = new Uint8Array( array, byteOffset )
                } else {
                    buf = new Uint8Array( array, byteOffset, length )
                }
                buf.__proto__ = Buffer.prototype;
                return buf
            }

            function fromObject( obj ) {
                if ( Buffer.isBuffer( obj ) ) {
                    var len = checked( obj.length ) | 0;
                    var buf = createBuffer( len );
                    if ( buf.length === 0 ) {
                        return buf
                    }
                    obj.copy( buf, 0, 0, len );
                    return buf
                }
                if ( obj ) {
                    if ( ArrayBuffer.isView( obj ) || "length" in obj ) {
                        if ( typeof obj.length !== "number" || numberIsNaN( obj.length ) ) {
                            return createBuffer( 0 )
                        }
                        return fromArrayLike( obj )
                    }
                    if ( obj.type === "Buffer" && Array.isArray( obj.data ) ) {
                        return fromArrayLike( obj.data )
                    }
                }
                throw new TypeError( "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object." )
            }

            function checked( length ) {
                if ( length >= K_MAX_LENGTH ) {
                    throw new RangeError( "Attempt to allocate Buffer larger than maximum " + "size: 0x" + K_MAX_LENGTH.toString( 16 ) + " bytes" )
                }
                return length | 0
            }

            function SlowBuffer( length ) {
                if ( +length != length ) {
                    length = 0
                }
                return Buffer.alloc( +length )
            }
            Buffer.isBuffer = function isBuffer( b ) {
                return b != null && b._isBuffer === true
            };
            Buffer.compare = function compare( a, b ) {
                if ( !Buffer.isBuffer( a ) || !Buffer.isBuffer( b ) ) {
                    throw new TypeError( "Arguments must be Buffers" )
                }
                if ( a === b ) return 0;
                var x = a.length;
                var y = b.length;
                for ( var i = 0, len = Math.min( x, y ); i < len; ++i ) {
                    if ( a[ i ] !== b[ i ] ) {
                        x = a[ i ];
                        y = b[ i ];
                        break
                    }
                }
                if ( x < y ) return -1;
                if ( y < x ) return 1;
                return 0
            };
            Buffer.isEncoding = function isEncoding( encoding ) {
                switch ( String( encoding ).toLowerCase() ) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false
                }
            };
            Buffer.concat = function concat( list, length ) {
                if ( !Array.isArray( list ) ) {
                    throw new TypeError( '"list" argument must be an Array of Buffers' )
                }
                if ( list.length === 0 ) {
                    return Buffer.alloc( 0 )
                }
                var i;
                if ( length === undefined ) {
                    length = 0;
                    for ( i = 0; i < list.length; ++i ) {
                        length += list[ i ].length
                    }
                }
                var buffer = Buffer.allocUnsafe( length );
                var pos = 0;
                for ( i = 0; i < list.length; ++i ) {
                    var buf = list[ i ];
                    if ( ArrayBuffer.isView( buf ) ) {
                        buf = Buffer.from( buf )
                    }
                    if ( !Buffer.isBuffer( buf ) ) {
                        throw new TypeError( '"list" argument must be an Array of Buffers' )
                    }
                    buf.copy( buffer, pos );
                    pos += buf.length
                }
                return buffer
            };

            function byteLength( string, encoding ) {
                if ( Buffer.isBuffer( string ) ) {
                    return string.length
                }
                if ( ArrayBuffer.isView( string ) || isArrayBuffer( string ) ) {
                    return string.byteLength
                }
                if ( typeof string !== "string" ) {
                    string = "" + string
                }
                var len = string.length;
                if ( len === 0 ) return 0;
                var loweredCase = false;
                for ( ;; ) {
                    switch ( encoding ) {
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return len;
                        case "utf8":
                        case "utf-8":
                        case undefined:
                            return utf8ToBytes( string ).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return len * 2;
                        case "hex":
                            return len >>> 1;
                        case "base64":
                            return base64ToBytes( string ).length;
                        default:
                            if ( loweredCase ) return utf8ToBytes( string ).length;
                            encoding = ( "" + encoding ).toLowerCase();
                            loweredCase = true
                    }
                }
            }
            Buffer.byteLength = byteLength;

            function slowToString( encoding, start, end ) {
                var loweredCase = false;
                if ( start === undefined || start < 0 ) {
                    start = 0
                }
                if ( start > this.length ) {
                    return ""
                }
                if ( end === undefined || end > this.length ) {
                    end = this.length
                }
                if ( end <= 0 ) {
                    return ""
                }
                end >>>= 0;
                start >>>= 0;
                if ( end <= start ) {
                    return ""
                }
                if ( !encoding ) encoding = "utf8";
                while ( true ) {
                    switch ( encoding ) {
                        case "hex":
                            return hexSlice( this, start, end );
                        case "utf8":
                        case "utf-8":
                            return utf8Slice( this, start, end );
                        case "ascii":
                            return asciiSlice( this, start, end );
                        case "latin1":
                        case "binary":
                            return latin1Slice( this, start, end );
                        case "base64":
                            return base64Slice( this, start, end );
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return utf16leSlice( this, start, end );
                        default:
                            if ( loweredCase ) throw new TypeError( "Unknown encoding: " + encoding );
                            encoding = ( encoding + "" ).toLowerCase();
                            loweredCase = true
                    }
                }
            }
            Buffer.prototype._isBuffer = true;

            function swap( b, n, m ) {
                var i = b[ n ];
                b[ n ] = b[ m ];
                b[ m ] = i
            }
            Buffer.prototype.swap16 = function swap16() {
                var len = this.length;
                if ( len % 2 !== 0 ) {
                    throw new RangeError( "Buffer size must be a multiple of 16-bits" )
                }
                for ( var i = 0; i < len; i += 2 ) {
                    swap( this, i, i + 1 )
                }
                return this
            };
            Buffer.prototype.swap32 = function swap32() {
                var len = this.length;
                if ( len % 4 !== 0 ) {
                    throw new RangeError( "Buffer size must be a multiple of 32-bits" )
                }
                for ( var i = 0; i < len; i += 4 ) {
                    swap( this, i, i + 3 );
                    swap( this, i + 1, i + 2 )
                }
                return this
            };
            Buffer.prototype.swap64 = function swap64() {
                var len = this.length;
                if ( len % 8 !== 0 ) {
                    throw new RangeError( "Buffer size must be a multiple of 64-bits" )
                }
                for ( var i = 0; i < len; i += 8 ) {
                    swap( this, i, i + 7 );
                    swap( this, i + 1, i + 6 );
                    swap( this, i + 2, i + 5 );
                    swap( this, i + 3, i + 4 )
                }
                return this
            };
            Buffer.prototype.toString = function toString() {
                var length = this.length;
                if ( length === 0 ) return "";
                if ( arguments.length === 0 ) return utf8Slice( this, 0, length );
                return slowToString.apply( this, arguments )
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals( b ) {
                if ( !Buffer.isBuffer( b ) ) throw new TypeError( "Argument must be a Buffer" );
                if ( this === b ) return true;
                return Buffer.compare( this, b ) === 0
            };
            Buffer.prototype.inspect = function inspect() {
                var str = "";
                var max = exports.INSPECT_MAX_BYTES;
                if ( this.length > 0 ) {
                    str = this.toString( "hex", 0, max ).match( /.{2}/g ).join( " " );
                    if ( this.length > max ) str += " ... "
                }
                return "<Buffer " + str + ">"
            };
            Buffer.prototype.compare = function compare( target, start, end, thisStart, thisEnd ) {
                if ( !Buffer.isBuffer( target ) ) {
                    throw new TypeError( "Argument must be a Buffer" )
                }
                if ( start === undefined ) {
                    start = 0
                }
                if ( end === undefined ) {
                    end = target ? target.length : 0
                }
                if ( thisStart === undefined ) {
                    thisStart = 0
                }
                if ( thisEnd === undefined ) {
                    thisEnd = this.length
                }
                if ( start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length ) {
                    throw new RangeError( "out of range index" )
                }
                if ( thisStart >= thisEnd && start >= end ) {
                    return 0
                }
                if ( thisStart >= thisEnd ) {
                    return -1
                }
                if ( start >= end ) {
                    return 1
                }
                start >>>= 0;
                end >>>= 0;
                thisStart >>>= 0;
                thisEnd >>>= 0;
                if ( this === target ) return 0;
                var x = thisEnd - thisStart;
                var y = end - start;
                var len = Math.min( x, y );
                var thisCopy = this.slice( thisStart, thisEnd );
                var targetCopy = target.slice( start, end );
                for ( var i = 0; i < len; ++i ) {
                    if ( thisCopy[ i ] !== targetCopy[ i ] ) {
                        x = thisCopy[ i ];
                        y = targetCopy[ i ];
                        break
                    }
                }
                if ( x < y ) return -1;
                if ( y < x ) return 1;
                return 0
            };

            function bidirectionalIndexOf( buffer, val, byteOffset, encoding, dir ) {
                if ( buffer.length === 0 ) return -1;
                if ( typeof byteOffset === "string" ) {
                    encoding = byteOffset;
                    byteOffset = 0
                } else if ( byteOffset > 2147483647 ) {
                    byteOffset = 2147483647
                } else if ( byteOffset < -2147483648 ) {
                    byteOffset = -2147483648
                }
                byteOffset = +byteOffset;
                if ( numberIsNaN( byteOffset ) ) {
                    byteOffset = dir ? 0 : buffer.length - 1
                }
                if ( byteOffset < 0 ) byteOffset = buffer.length + byteOffset;
                if ( byteOffset >= buffer.length ) {
                    if ( dir ) return -1;
                    else byteOffset = buffer.length - 1
                } else if ( byteOffset < 0 ) {
                    if ( dir ) byteOffset = 0;
                    else return -1
                }
                if ( typeof val === "string" ) {
                    val = Buffer.from( val, encoding )
                }
                if ( Buffer.isBuffer( val ) ) {
                    if ( val.length === 0 ) {
                        return -1
                    }
                    return arrayIndexOf( buffer, val, byteOffset, encoding, dir )
                } else if ( typeof val === "number" ) {
                    val = val & 255;
                    if ( typeof Uint8Array.prototype.indexOf === "function" ) {
                        if ( dir ) {
                            return Uint8Array.prototype.indexOf.call( buffer, val, byteOffset )
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call( buffer, val, byteOffset )
                        }
                    }
                    return arrayIndexOf( buffer, [ val ], byteOffset, encoding, dir )
                }
                throw new TypeError( "val must be string, number or Buffer" )
            }

            function arrayIndexOf( arr, val, byteOffset, encoding, dir ) {
                var indexSize = 1;
                var arrLength = arr.length;
                var valLength = val.length;
                if ( encoding !== undefined ) {
                    encoding = String( encoding ).toLowerCase();
                    if ( encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le" ) {
                        if ( arr.length < 2 || val.length < 2 ) {
                            return -1
                        }
                        indexSize = 2;
                        arrLength /= 2;
                        valLength /= 2;
                        byteOffset /= 2
                    }
                }

                function read( buf, i ) {
                    if ( indexSize === 1 ) {
                        return buf[ i ]
                    } else {
                        return buf.readUInt16BE( i * indexSize )
                    }
                }
                var i;
                if ( dir ) {
                    var foundIndex = -1;
                    for ( i = byteOffset; i < arrLength; i++ ) {
                        if ( read( arr, i ) === read( val, foundIndex === -1 ? 0 : i - foundIndex ) ) {
                            if ( foundIndex === -1 ) foundIndex = i;
                            if ( i - foundIndex + 1 === valLength ) return foundIndex * indexSize
                        } else {
                            if ( foundIndex !== -1 ) i -= i - foundIndex;
                            foundIndex = -1
                        }
                    }
                } else {
                    if ( byteOffset + valLength > arrLength ) byteOffset = arrLength - valLength;
                    for ( i = byteOffset; i >= 0; i-- ) {
                        var found = true;
                        for ( var j = 0; j < valLength; j++ ) {
                            if ( read( arr, i + j ) !== read( val, j ) ) {
                                found = false;
                                break
                            }
                        }
                        if ( found ) return i
                    }
                }
                return -1
            }
            Buffer.prototype.includes = function includes( val, byteOffset, encoding ) {
                return this.indexOf( val, byteOffset, encoding ) !== -1
            };
            Buffer.prototype.indexOf = function indexOf( val, byteOffset, encoding ) {
                return bidirectionalIndexOf( this, val, byteOffset, encoding, true )
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf( val, byteOffset, encoding ) {
                return bidirectionalIndexOf( this, val, byteOffset, encoding, false )
            };

            function hexWrite( buf, string, offset, length ) {
                offset = Number( offset ) || 0;
                var remaining = buf.length - offset;
                if ( !length ) {
                    length = remaining
                } else {
                    length = Number( length );
                    if ( length > remaining ) {
                        length = remaining
                    }
                }
                var strLen = string.length;
                if ( length > strLen / 2 ) {
                    length = strLen / 2
                }
                for ( var i = 0; i < length; ++i ) {
                    var parsed = parseInt( string.substr( i * 2, 2 ), 16 );
                    if ( numberIsNaN( parsed ) ) return i;
                    buf[ offset + i ] = parsed
                }
                return i
            }

            function utf8Write( buf, string, offset, length ) {
                return blitBuffer( utf8ToBytes( string, buf.length - offset ), buf, offset, length )
            }

            function asciiWrite( buf, string, offset, length ) {
                return blitBuffer( asciiToBytes( string ), buf, offset, length )
            }

            function latin1Write( buf, string, offset, length ) {
                return asciiWrite( buf, string, offset, length )
            }

            function base64Write( buf, string, offset, length ) {
                return blitBuffer( base64ToBytes( string ), buf, offset, length )
            }

            function ucs2Write( buf, string, offset, length ) {
                return blitBuffer( utf16leToBytes( string, buf.length - offset ), buf, offset, length )
            }
            Buffer.prototype.write = function write( string, offset, length, encoding ) {
                if ( offset === undefined ) {
                    encoding = "utf8";
                    length = this.length;
                    offset = 0
                } else if ( length === undefined && typeof offset === "string" ) {
                    encoding = offset;
                    length = this.length;
                    offset = 0
                } else if ( isFinite( offset ) ) {
                    offset = offset >>> 0;
                    if ( isFinite( length ) ) {
                        length = length >>> 0;
                        if ( encoding === undefined ) encoding = "utf8"
                    } else {
                        encoding = length;
                        length = undefined
                    }
                } else {
                    throw new Error( "Buffer.write(string, encoding, offset[, length]) is no longer supported" )
                }
                var remaining = this.length - offset;
                if ( length === undefined || length > remaining ) length = remaining;
                if ( string.length > 0 && ( length < 0 || offset < 0 ) || offset > this.length ) {
                    throw new RangeError( "Attempt to write outside buffer bounds" )
                }
                if ( !encoding ) encoding = "utf8";
                var loweredCase = false;
                for ( ;; ) {
                    switch ( encoding ) {
                        case "hex":
                            return hexWrite( this, string, offset, length );
                        case "utf8":
                        case "utf-8":
                            return utf8Write( this, string, offset, length );
                        case "ascii":
                            return asciiWrite( this, string, offset, length );
                        case "latin1":
                        case "binary":
                            return latin1Write( this, string, offset, length );
                        case "base64":
                            return base64Write( this, string, offset, length );
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return ucs2Write( this, string, offset, length );
                        default:
                            if ( loweredCase ) throw new TypeError( "Unknown encoding: " + encoding );
                            encoding = ( "" + encoding ).toLowerCase();
                            loweredCase = true
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call( this._arr || this, 0 )
                }
            };

            function base64Slice( buf, start, end ) {
                if ( start === 0 && end === buf.length ) {
                    return base64.fromByteArray( buf )
                } else {
                    return base64.fromByteArray( buf.slice( start, end ) )
                }
            }

            function utf8Slice( buf, start, end ) {
                end = Math.min( buf.length, end );
                var res = [];
                var i = start;
                while ( i < end ) {
                    var firstByte = buf[ i ];
                    var codePoint = null;
                    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                    if ( i + bytesPerSequence <= end ) {
                        var secondByte, thirdByte, fourthByte, tempCodePoint;
                        switch ( bytesPerSequence ) {
                            case 1:
                                if ( firstByte < 128 ) {
                                    codePoint = firstByte
                                }
                                break;
                            case 2:
                                secondByte = buf[ i + 1 ];
                                if ( ( secondByte & 192 ) === 128 ) {
                                    tempCodePoint = ( firstByte & 31 ) << 6 | secondByte & 63;
                                    if ( tempCodePoint > 127 ) {
                                        codePoint = tempCodePoint
                                    }
                                }
                                break;
                            case 3:
                                secondByte = buf[ i + 1 ];
                                thirdByte = buf[ i + 2 ];
                                if ( ( secondByte & 192 ) === 128 && ( thirdByte & 192 ) === 128 ) {
                                    tempCodePoint = ( firstByte & 15 ) << 12 | ( secondByte & 63 ) << 6 | thirdByte & 63;
                                    if ( tempCodePoint > 2047 && ( tempCodePoint < 55296 || tempCodePoint > 57343 ) ) {
                                        codePoint = tempCodePoint
                                    }
                                }
                                break;
                            case 4:
                                secondByte = buf[ i + 1 ];
                                thirdByte = buf[ i + 2 ];
                                fourthByte = buf[ i + 3 ];
                                if ( ( secondByte & 192 ) === 128 && ( thirdByte & 192 ) === 128 && ( fourthByte & 192 ) === 128 ) {
                                    tempCodePoint = ( firstByte & 15 ) << 18 | ( secondByte & 63 ) << 12 | ( thirdByte & 63 ) << 6 | fourthByte & 63;
                                    if ( tempCodePoint > 65535 && tempCodePoint < 1114112 ) {
                                        codePoint = tempCodePoint
                                    }
                                }
                        }
                    }
                    if ( codePoint === null ) {
                        codePoint = 65533;
                        bytesPerSequence = 1
                    } else if ( codePoint > 65535 ) {
                        codePoint -= 65536;
                        res.push( codePoint >>> 10 & 1023 | 55296 );
                        codePoint = 56320 | codePoint & 1023
                    }
                    res.push( codePoint );
                    i += bytesPerSequence
                }
                return decodeCodePointsArray( res )
            }
            var MAX_ARGUMENTS_LENGTH = 4096;

            function decodeCodePointsArray( codePoints ) {
                var len = codePoints.length;
                if ( len <= MAX_ARGUMENTS_LENGTH ) {
                    return String.fromCharCode.apply( String, codePoints )
                }
                var res = "";
                var i = 0;
                while ( i < len ) {
                    res += String.fromCharCode.apply( String, codePoints.slice( i, i += MAX_ARGUMENTS_LENGTH ) )
                }
                return res
            }

            function asciiSlice( buf, start, end ) {
                var ret = "";
                end = Math.min( buf.length, end );
                for ( var i = start; i < end; ++i ) {
                    ret += String.fromCharCode( buf[ i ] & 127 )
                }
                return ret
            }

            function latin1Slice( buf, start, end ) {
                var ret = "";
                end = Math.min( buf.length, end );
                for ( var i = start; i < end; ++i ) {
                    ret += String.fromCharCode( buf[ i ] )
                }
                return ret
            }

            function hexSlice( buf, start, end ) {
                var len = buf.length;
                if ( !start || start < 0 ) start = 0;
                if ( !end || end < 0 || end > len ) end = len;
                var out = "";
                for ( var i = start; i < end; ++i ) {
                    out += toHex( buf[ i ] )
                }
                return out
            }

            function utf16leSlice( buf, start, end ) {
                var bytes = buf.slice( start, end );
                var res = "";
                for ( var i = 0; i < bytes.length; i += 2 ) {
                    res += String.fromCharCode( bytes[ i ] + bytes[ i + 1 ] * 256 )
                }
                return res
            }
            Buffer.prototype.slice = function slice( start, end ) {
                var len = this.length;
                start = ~~start;
                end = end === undefined ? len : ~~end;
                if ( start < 0 ) {
                    start += len;
                    if ( start < 0 ) start = 0
                } else if ( start > len ) {
                    start = len
                }
                if ( end < 0 ) {
                    end += len;
                    if ( end < 0 ) end = 0
                } else if ( end > len ) {
                    end = len
                }
                if ( end < start ) end = start;
                var newBuf = this.subarray( start, end );
                newBuf.__proto__ = Buffer.prototype;
                return newBuf
            };

            function checkOffset( offset, ext, length ) {
                if ( offset % 1 !== 0 || offset < 0 ) throw new RangeError( "offset is not uint" );
                if ( offset + ext > length ) throw new RangeError( "Trying to access beyond buffer length" )
            }
            Buffer.prototype.readUIntLE = function readUIntLE( offset, byteLength, noAssert ) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if ( !noAssert ) checkOffset( offset, byteLength, this.length );
                var val = this[ offset ];
                var mul = 1;
                var i = 0;
                while ( ++i < byteLength && ( mul *= 256 ) ) {
                    val += this[ offset + i ] * mul
                }
                return val
            };
            Buffer.prototype.readUIntBE = function readUIntBE( offset, byteLength, noAssert ) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if ( !noAssert ) {
                    checkOffset( offset, byteLength, this.length )
                }
                var val = this[ offset + --byteLength ];
                var mul = 1;
                while ( byteLength > 0 && ( mul *= 256 ) ) {
                    val += this[ offset + --byteLength ] * mul
                }
                return val
            };
            Buffer.prototype.readUInt8 = function readUInt8( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 1, this.length );
                return this[ offset ]
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 2, this.length );
                return this[ offset ] | this[ offset + 1 ] << 8
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 2, this.length );
                return this[ offset ] << 8 | this[ offset + 1 ]
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 4, this.length );
                return ( this[ offset ] | this[ offset + 1 ] << 8 | this[ offset + 2 ] << 16 ) + this[ offset + 3 ] * 16777216
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 4, this.length );
                return this[ offset ] * 16777216 + ( this[ offset + 1 ] << 16 | this[ offset + 2 ] << 8 | this[ offset + 3 ] )
            };
            Buffer.prototype.readIntLE = function readIntLE( offset, byteLength, noAssert ) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if ( !noAssert ) checkOffset( offset, byteLength, this.length );
                var val = this[ offset ];
                var mul = 1;
                var i = 0;
                while ( ++i < byteLength && ( mul *= 256 ) ) {
                    val += this[ offset + i ] * mul
                }
                mul *= 128;
                if ( val >= mul ) val -= Math.pow( 2, 8 * byteLength );
                return val
            };
            Buffer.prototype.readIntBE = function readIntBE( offset, byteLength, noAssert ) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if ( !noAssert ) checkOffset( offset, byteLength, this.length );
                var i = byteLength;
                var mul = 1;
                var val = this[ offset + --i ];
                while ( i > 0 && ( mul *= 256 ) ) {
                    val += this[ offset + --i ] * mul
                }
                mul *= 128;
                if ( val >= mul ) val -= Math.pow( 2, 8 * byteLength );
                return val
            };
            Buffer.prototype.readInt8 = function readInt8( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 1, this.length );
                if ( !( this[ offset ] & 128 ) ) return this[ offset ];
                return ( 255 - this[ offset ] + 1 ) * -1
            };
            Buffer.prototype.readInt16LE = function readInt16LE( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 2, this.length );
                var val = this[ offset ] | this[ offset + 1 ] << 8;
                return val & 32768 ? val | 4294901760 : val
            };
            Buffer.prototype.readInt16BE = function readInt16BE( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 2, this.length );
                var val = this[ offset + 1 ] | this[ offset ] << 8;
                return val & 32768 ? val | 4294901760 : val
            };
            Buffer.prototype.readInt32LE = function readInt32LE( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 4, this.length );
                return this[ offset ] | this[ offset + 1 ] << 8 | this[ offset + 2 ] << 16 | this[ offset + 3 ] << 24
            };
            Buffer.prototype.readInt32BE = function readInt32BE( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 4, this.length );
                return this[ offset ] << 24 | this[ offset + 1 ] << 16 | this[ offset + 2 ] << 8 | this[ offset + 3 ]
            };
            Buffer.prototype.readFloatLE = function readFloatLE( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 4, this.length );
                return ieee754.read( this, offset, true, 23, 4 )
            };
            Buffer.prototype.readFloatBE = function readFloatBE( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 4, this.length );
                return ieee754.read( this, offset, false, 23, 4 )
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 8, this.length );
                return ieee754.read( this, offset, true, 52, 8 )
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE( offset, noAssert ) {
                offset = offset >>> 0;
                if ( !noAssert ) checkOffset( offset, 8, this.length );
                return ieee754.read( this, offset, false, 52, 8 )
            };

            function checkInt( buf, value, offset, ext, max, min ) {
                if ( !Buffer.isBuffer( buf ) ) throw new TypeError( '"buffer" argument must be a Buffer instance' );
                if ( value > max || value < min ) throw new RangeError( '"value" argument is out of bounds' );
                if ( offset + ext > buf.length ) throw new RangeError( "Index out of range" )
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE( value, offset, byteLength, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if ( !noAssert ) {
                    var maxBytes = Math.pow( 2, 8 * byteLength ) - 1;
                    checkInt( this, value, offset, byteLength, maxBytes, 0 )
                }
                var mul = 1;
                var i = 0;
                this[ offset ] = value & 255;
                while ( ++i < byteLength && ( mul *= 256 ) ) {
                    this[ offset + i ] = value / mul & 255
                }
                return offset + byteLength
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE( value, offset, byteLength, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if ( !noAssert ) {
                    var maxBytes = Math.pow( 2, 8 * byteLength ) - 1;
                    checkInt( this, value, offset, byteLength, maxBytes, 0 )
                }
                var i = byteLength - 1;
                var mul = 1;
                this[ offset + i ] = value & 255;
                while ( --i >= 0 && ( mul *= 256 ) ) {
                    this[ offset + i ] = value / mul & 255
                }
                return offset + byteLength
            };
            Buffer.prototype.writeUInt8 = function writeUInt8( value, offset, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) checkInt( this, value, offset, 1, 255, 0 );
                this[ offset ] = value & 255;
                return offset + 1
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE( value, offset, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) checkInt( this, value, offset, 2, 65535, 0 );
                this[ offset ] = value & 255;
                this[ offset + 1 ] = value >>> 8;
                return offset + 2
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE( value, offset, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) checkInt( this, value, offset, 2, 65535, 0 );
                this[ offset ] = value >>> 8;
                this[ offset + 1 ] = value & 255;
                return offset + 2
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE( value, offset, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) checkInt( this, value, offset, 4, 4294967295, 0 );
                this[ offset + 3 ] = value >>> 24;
                this[ offset + 2 ] = value >>> 16;
                this[ offset + 1 ] = value >>> 8;
                this[ offset ] = value & 255;
                return offset + 4
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE( value, offset, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) checkInt( this, value, offset, 4, 4294967295, 0 );
                this[ offset ] = value >>> 24;
                this[ offset + 1 ] = value >>> 16;
                this[ offset + 2 ] = value >>> 8;
                this[ offset + 3 ] = value & 255;
                return offset + 4
            };
            Buffer.prototype.writeIntLE = function writeIntLE( value, offset, byteLength, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) {
                    var limit = Math.pow( 2, 8 * byteLength - 1 );
                    checkInt( this, value, offset, byteLength, limit - 1, -limit )
                }
                var i = 0;
                var mul = 1;
                var sub = 0;
                this[ offset ] = value & 255;
                while ( ++i < byteLength && ( mul *= 256 ) ) {
                    if ( value < 0 && sub === 0 && this[ offset + i - 1 ] !== 0 ) {
                        sub = 1
                    }
                    this[ offset + i ] = ( value / mul >> 0 ) - sub & 255
                }
                return offset + byteLength
            };
            Buffer.prototype.writeIntBE = function writeIntBE( value, offset, byteLength, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) {
                    var limit = Math.pow( 2, 8 * byteLength - 1 );
                    checkInt( this, value, offset, byteLength, limit - 1, -limit )
                }
                var i = byteLength - 1;
                var mul = 1;
                var sub = 0;
                this[ offset + i ] = value & 255;
                while ( --i >= 0 && ( mul *= 256 ) ) {
                    if ( value < 0 && sub === 0 && this[ offset + i + 1 ] !== 0 ) {
                        sub = 1
                    }
                    this[ offset + i ] = ( value / mul >> 0 ) - sub & 255
                }
                return offset + byteLength
            };
            Buffer.prototype.writeInt8 = function writeInt8( value, offset, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) checkInt( this, value, offset, 1, 127, -128 );
                if ( value < 0 ) value = 255 + value + 1;
                this[ offset ] = value & 255;
                return offset + 1
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE( value, offset, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) checkInt( this, value, offset, 2, 32767, -32768 );
                this[ offset ] = value & 255;
                this[ offset + 1 ] = value >>> 8;
                return offset + 2
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE( value, offset, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) checkInt( this, value, offset, 2, 32767, -32768 );
                this[ offset ] = value >>> 8;
                this[ offset + 1 ] = value & 255;
                return offset + 2
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE( value, offset, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) checkInt( this, value, offset, 4, 2147483647, -2147483648 );
                this[ offset ] = value & 255;
                this[ offset + 1 ] = value >>> 8;
                this[ offset + 2 ] = value >>> 16;
                this[ offset + 3 ] = value >>> 24;
                return offset + 4
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE( value, offset, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) checkInt( this, value, offset, 4, 2147483647, -2147483648 );
                if ( value < 0 ) value = 4294967295 + value + 1;
                this[ offset ] = value >>> 24;
                this[ offset + 1 ] = value >>> 16;
                this[ offset + 2 ] = value >>> 8;
                this[ offset + 3 ] = value & 255;
                return offset + 4
            };

            function checkIEEE754( buf, value, offset, ext, max, min ) {
                if ( offset + ext > buf.length ) throw new RangeError( "Index out of range" );
                if ( offset < 0 ) throw new RangeError( "Index out of range" )
            }

            function writeFloat( buf, value, offset, littleEndian, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) {
                    checkIEEE754( buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38 )
                }
                ieee754.write( buf, value, offset, littleEndian, 23, 4 );
                return offset + 4
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE( value, offset, noAssert ) {
                return writeFloat( this, value, offset, true, noAssert )
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE( value, offset, noAssert ) {
                return writeFloat( this, value, offset, false, noAssert )
            };

            function writeDouble( buf, value, offset, littleEndian, noAssert ) {
                value = +value;
                offset = offset >>> 0;
                if ( !noAssert ) {
                    checkIEEE754( buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308 )
                }
                ieee754.write( buf, value, offset, littleEndian, 52, 8 );
                return offset + 8
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE( value, offset, noAssert ) {
                return writeDouble( this, value, offset, true, noAssert )
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE( value, offset, noAssert ) {
                return writeDouble( this, value, offset, false, noAssert )
            };
            Buffer.prototype.copy = function copy( target, targetStart, start, end ) {
                if ( !Buffer.isBuffer( target ) ) throw new TypeError( "argument should be a Buffer" );
                if ( !start ) start = 0;
                if ( !end && end !== 0 ) end = this.length;
                if ( targetStart >= target.length ) targetStart = target.length;
                if ( !targetStart ) targetStart = 0;
                if ( end > 0 && end < start ) end = start;
                if ( end === start ) return 0;
                if ( target.length === 0 || this.length === 0 ) return 0;
                if ( targetStart < 0 ) {
                    throw new RangeError( "targetStart out of bounds" )
                }
                if ( start < 0 || start >= this.length ) throw new RangeError( "Index out of range" );
                if ( end < 0 ) throw new RangeError( "sourceEnd out of bounds" );
                if ( end > this.length ) end = this.length;
                if ( target.length - targetStart < end - start ) {
                    end = target.length - targetStart + start
                }
                var len = end - start;
                if ( this === target && typeof Uint8Array.prototype.copyWithin === "function" ) {
                    this.copyWithin( targetStart, start, end )
                } else if ( this === target && start < targetStart && targetStart < end ) {
                    for ( var i = len - 1; i >= 0; --i ) {
                        target[ i + targetStart ] = this[ i + start ]
                    }
                } else {
                    Uint8Array.prototype.set.call( target, this.subarray( start, end ), targetStart )
                }
                return len
            };
            Buffer.prototype.fill = function fill( val, start, end, encoding ) {
                if ( typeof val === "string" ) {
                    if ( typeof start === "string" ) {
                        encoding = start;
                        start = 0;
                        end = this.length
                    } else if ( typeof end === "string" ) {
                        encoding = end;
                        end = this.length
                    }
                    if ( encoding !== undefined && typeof encoding !== "string" ) {
                        throw new TypeError( "encoding must be a string" )
                    }
                    if ( typeof encoding === "string" && !Buffer.isEncoding( encoding ) ) {
                        throw new TypeError( "Unknown encoding: " + encoding )
                    }
                    if ( val.length === 1 ) {
                        var code = val.charCodeAt( 0 );
                        if ( encoding === "utf8" && code < 128 || encoding === "latin1" ) {
                            val = code
                        }
                    }
                } else if ( typeof val === "number" ) {
                    val = val & 255
                }
                if ( start < 0 || this.length < start || this.length < end ) {
                    throw new RangeError( "Out of range index" )
                }
                if ( end <= start ) {
                    return this
                }
                start = start >>> 0;
                end = end === undefined ? this.length : end >>> 0;
                if ( !val ) val = 0;
                var i;
                if ( typeof val === "number" ) {
                    for ( i = start; i < end; ++i ) {
                        this[ i ] = val
                    }
                } else {
                    var bytes = Buffer.isBuffer( val ) ? val : new Buffer( val, encoding );
                    var len = bytes.length;
                    if ( len === 0 ) {
                        throw new TypeError( 'The value "' + val + '" is invalid for argument "value"' )
                    }
                    for ( i = 0; i < end - start; ++i ) {
                        this[ i + start ] = bytes[ i % len ]
                    }
                }
                return this
            };
            var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

            function base64clean( str ) {
                str = str.split( "=" )[ 0 ];
                str = str.trim().replace( INVALID_BASE64_RE, "" );
                if ( str.length < 2 ) return "";
                while ( str.length % 4 !== 0 ) {
                    str = str + "="
                }
                return str
            }

            function toHex( n ) {
                if ( n < 16 ) return "0" + n.toString( 16 );
                return n.toString( 16 )
            }

            function utf8ToBytes( string, units ) {
                units = units || Infinity;
                var codePoint;
                var length = string.length;
                var leadSurrogate = null;
                var bytes = [];
                for ( var i = 0; i < length; ++i ) {
                    codePoint = string.charCodeAt( i );
                    if ( codePoint > 55295 && codePoint < 57344 ) {
                        if ( !leadSurrogate ) {
                            if ( codePoint > 56319 ) {
                                if ( ( units -= 3 ) > -1 ) bytes.push( 239, 191, 189 );
                                continue
                            } else if ( i + 1 === length ) {
                                if ( ( units -= 3 ) > -1 ) bytes.push( 239, 191, 189 );
                                continue
                            }
                            leadSurrogate = codePoint;
                            continue
                        }
                        if ( codePoint < 56320 ) {
                            if ( ( units -= 3 ) > -1 ) bytes.push( 239, 191, 189 );
                            leadSurrogate = codePoint;
                            continue
                        }
                        codePoint = ( leadSurrogate - 55296 << 10 | codePoint - 56320 ) + 65536
                    } else if ( leadSurrogate ) {
                        if ( ( units -= 3 ) > -1 ) bytes.push( 239, 191, 189 )
                    }
                    leadSurrogate = null;
                    if ( codePoint < 128 ) {
                        if ( ( units -= 1 ) < 0 ) break;
                        bytes.push( codePoint )
                    } else if ( codePoint < 2048 ) {
                        if ( ( units -= 2 ) < 0 ) break;
                        bytes.push( codePoint >> 6 | 192, codePoint & 63 | 128 )
                    } else if ( codePoint < 65536 ) {
                        if ( ( units -= 3 ) < 0 ) break;
                        bytes.push( codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128 )
                    } else if ( codePoint < 1114112 ) {
                        if ( ( units -= 4 ) < 0 ) break;
                        bytes.push( codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128 )
                    } else {
                        throw new Error( "Invalid code point" )
                    }
                }
                return bytes
            }

            function asciiToBytes( str ) {
                var byteArray = [];
                for ( var i = 0; i < str.length; ++i ) {
                    byteArray.push( str.charCodeAt( i ) & 255 )
                }
                return byteArray
            }

            function utf16leToBytes( str, units ) {
                var c, hi, lo;
                var byteArray = [];
                for ( var i = 0; i < str.length; ++i ) {
                    if ( ( units -= 2 ) < 0 ) break;
                    c = str.charCodeAt( i );
                    hi = c >> 8;
                    lo = c % 256;
                    byteArray.push( lo );
                    byteArray.push( hi )
                }
                return byteArray
            }

            function base64ToBytes( str ) {
                return base64.toByteArray( base64clean( str ) )
            }

            function blitBuffer( src, dst, offset, length ) {
                for ( var i = 0; i < length; ++i ) {
                    if ( i + offset >= dst.length || i >= src.length ) break;
                    dst[ i + offset ] = src[ i ]
                }
                return i
            }

            function isArrayBuffer( obj ) {
                return obj instanceof ArrayBuffer || obj != null && obj.constructor != null && obj.constructor.name === "ArrayBuffer" && typeof obj.byteLength === "number"
            }

            function numberIsNaN( obj ) {
                return obj !== obj
            }
        }, {
            "base64-js": 1,
            ieee754: 29
        } ],
        5: [ function( require, module, exports ) {
            ( function( Buffer ) {
                function isArray( arg ) {
                    if ( Array.isArray ) {
                        return Array.isArray( arg )
                    }
                    return objectToString( arg ) === "[object Array]"
                }
                exports.isArray = isArray;

                function isBoolean( arg ) {
                    return typeof arg === "boolean"
                }
                exports.isBoolean = isBoolean;

                function isNull( arg ) {
                    return arg === null
                }
                exports.isNull = isNull;

                function isNullOrUndefined( arg ) {
                    return arg == null
                }
                exports.isNullOrUndefined = isNullOrUndefined;

                function isNumber( arg ) {
                    return typeof arg === "number"
                }
                exports.isNumber = isNumber;

                function isString( arg ) {
                    return typeof arg === "string"
                }
                exports.isString = isString;

                function isSymbol( arg ) {
                    return typeof arg === "symbol"
                }
                exports.isSymbol = isSymbol;

                function isUndefined( arg ) {
                    return arg === void 0
                }
                exports.isUndefined = isUndefined;

                function isRegExp( re ) {
                    return objectToString( re ) === "[object RegExp]"
                }
                exports.isRegExp = isRegExp;

                function isObject( arg ) {
                    return typeof arg === "object" && arg !== null
                }
                exports.isObject = isObject;

                function isDate( d ) {
                    return objectToString( d ) === "[object Date]"
                }
                exports.isDate = isDate;

                function isError( e ) {
                    return objectToString( e ) === "[object Error]" || e instanceof Error
                }
                exports.isError = isError;

                function isFunction( arg ) {
                    return typeof arg === "function"
                }
                exports.isFunction = isFunction;

                function isPrimitive( arg ) {
                    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined"
                }
                exports.isPrimitive = isPrimitive;
                exports.isBuffer = Buffer.isBuffer;

                function objectToString( o ) {
                    return Object.prototype.toString.call( o )
                }
            } ).call( this, {
                isBuffer: require( "../../is-buffer/index.js" )
            } )
        }, {
            "../../is-buffer/index.js": 31
        } ],
        6: [ function( require, module, exports ) {
            ( function( global, factory ) {
                typeof exports === "object" && typeof module !== "undefined" ? factory( exports ) : typeof define === "function" && define.amd ? define( [ "exports" ], factory ) : factory( global.d3 = global.d3 || {} )
            } )( this, function( exports ) {
                "use strict";
                var EOL = {};
                var EOF = {};
                var QUOTE = 34;
                var NEWLINE = 10;
                var RETURN = 13;

                function objectConverter( columns ) {
                    return new Function( "d", "return {" + columns.map( function( name, i ) {
                        return JSON.stringify( name ) + ": d[" + i + "]"
                    } ).join( "," ) + "}" )
                }

                function customConverter( columns, f ) {
                    var object = objectConverter( columns );
                    return function( row, i ) {
                        return f( object( row ), i, columns )
                    }
                }

                function inferColumns( rows ) {
                    var columnSet = Object.create( null ),
                        columns = [];
                    rows.forEach( function( row ) {
                        for ( var column in row ) {
                            if ( !( column in columnSet ) ) {
                                columns.push( columnSet[ column ] = column )
                            }
                        }
                    } );
                    return columns
                }
                var dsv = function( delimiter ) {
                    var reFormat = new RegExp( '["' + delimiter + "\n\r]" ),
                        DELIMITER = delimiter.charCodeAt( 0 );

                    function parse( text, f ) {
                        var convert, columns, rows = parseRows( text, function( row, i ) {
                            if ( convert ) return convert( row, i - 1 );
                            columns = row, convert = f ? customConverter( row, f ) : objectConverter( row )
                        } );
                        rows.columns = columns || [];
                        return rows
                    }

                    function parseRows( text, f ) {
                        var rows = [],
                            N = text.length,
                            I = 0,
                            n = 0,
                            t, eof = N <= 0,
                            eol = false;
                        if ( text.charCodeAt( N - 1 ) === NEWLINE ) --N;
                        if ( text.charCodeAt( N - 1 ) === RETURN ) --N;

                        function token() {
                            if ( eof ) return EOF;
                            if ( eol ) return eol = false, EOL;
                            var i, j = I,
                                c;
                            if ( text.charCodeAt( j ) === QUOTE ) {
                                while ( I++ < N && text.charCodeAt( I ) !== QUOTE || text.charCodeAt( ++I ) === QUOTE );
                                if ( ( i = I ) >= N ) eof = true;
                                else if ( ( c = text.charCodeAt( I++ ) ) === NEWLINE ) eol = true;
                                else if ( c === RETURN ) {
                                    eol = true;
                                    if ( text.charCodeAt( I ) === NEWLINE ) ++I
                                }
                                return text.slice( j + 1, i - 1 ).replace( /""/g, '"' )
                            }
                            while ( I < N ) {
                                if ( ( c = text.charCodeAt( i = I++ ) ) === NEWLINE ) eol = true;
                                else if ( c === RETURN ) {
                                    eol = true;
                                    if ( text.charCodeAt( I ) === NEWLINE ) ++I
                                } else if ( c !== DELIMITER ) continue;
                                return text.slice( j, i )
                            }
                            return eof = true, text.slice( j, N )
                        }
                        while ( ( t = token() ) !== EOF ) {
                            var row = [];
                            while ( t !== EOL && t !== EOF ) row.push( t ), t = token();
                            if ( f && ( row = f( row, n++ ) ) == null ) continue;
                            rows.push( row )
                        }
                        return rows
                    }

                    function format( rows, columns ) {
                        if ( columns == null ) columns = inferColumns( rows );
                        return [ columns.map( formatValue ).join( delimiter ) ].concat( rows.map( function( row ) {
                            return columns.map( function( column ) {
                                return formatValue( row[ column ] )
                            } ).join( delimiter )
                        } ) ).join( "\n" )
                    }

                    function formatRows( rows ) {
                        return rows.map( formatRow ).join( "\n" )
                    }

                    function formatRow( row ) {
                        return row.map( formatValue ).join( delimiter )
                    }

                    function formatValue( text ) {
                        return text == null ? "" : reFormat.test( text += "" ) ? '"' + text.replace( /"/g, '""' ) + '"' : text
                    }
                    return {
                        parse: parse,
                        parseRows: parseRows,
                        format: format,
                        formatRows: formatRows
                    }
                };
                var csv = dsv( "," );
                var csvParse = csv.parse;
                var csvParseRows = csv.parseRows;
                var csvFormat = csv.format;
                var csvFormatRows = csv.formatRows;
                var tsv = dsv( "\t" );
                var tsvParse = tsv.parse;
                var tsvParseRows = tsv.parseRows;
                var tsvFormat = tsv.format;
                var tsvFormatRows = tsv.formatRows;
                exports.dsvFormat = dsv;
                exports.csvParse = csvParse;
                exports.csvParseRows = csvParseRows;
                exports.csvFormat = csvFormat;
                exports.csvFormatRows = csvFormatRows;
                exports.tsvParse = tsvParse;
                exports.tsvParseRows = tsvParseRows;
                exports.tsvFormat = tsvFormat;
                exports.tsvFormatRows = tsvFormatRows;
                Object.defineProperty( exports, "__esModule", {
                    value: true
                } )
            } )
        }, {} ],
        7: [ function( require, module, exports ) {
            var objectCreate = Object.create || objectCreatePolyfill;
            var objectKeys = Object.keys || objectKeysPolyfill;
            var bind = Function.prototype.bind || functionBindPolyfill;

            function EventEmitter() {
                if ( !this._events || !Object.prototype.hasOwnProperty.call( this, "_events" ) ) {
                    this._events = objectCreate( null );
                    this._eventsCount = 0
                }
                this._maxListeners = this._maxListeners || undefined
            }
            module.exports = EventEmitter;
            EventEmitter.EventEmitter = EventEmitter;
            EventEmitter.prototype._events = undefined;
            EventEmitter.prototype._maxListeners = undefined;
            var defaultMaxListeners = 10;
            var hasDefineProperty;
            try {
                var o = {};
                if ( Object.defineProperty ) Object.defineProperty( o, "x", {
                    value: 0
                } );
                hasDefineProperty = o.x === 0
            } catch ( err ) {
                hasDefineProperty = false
            }
            if ( hasDefineProperty ) {
                Object.defineProperty( EventEmitter, "defaultMaxListeners", {
                    enumerable: true,
                    get: function() {
                        return defaultMaxListeners
                    },
                    set: function( arg ) {
                        if ( typeof arg !== "number" || arg < 0 || arg !== arg ) throw new TypeError( '"defaultMaxListeners" must be a positive number' );
                        defaultMaxListeners = arg
                    }
                } )
            } else {
                EventEmitter.defaultMaxListeners = defaultMaxListeners
            }
            EventEmitter.prototype.setMaxListeners = function setMaxListeners( n ) {
                if ( typeof n !== "number" || n < 0 || isNaN( n ) ) throw new TypeError( '"n" argument must be a positive number' );
                this._maxListeners = n;
                return this
            };

            function $getMaxListeners( that ) {
                if ( that._maxListeners === undefined ) return EventEmitter.defaultMaxListeners;
                return that._maxListeners
            }
            EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
                return $getMaxListeners( this )
            };

            function emitNone( handler, isFn, self ) {
                if ( isFn ) handler.call( self );
                else {
                    var len = handler.length;
                    var listeners = arrayClone( handler, len );
                    for ( var i = 0; i < len; ++i ) listeners[ i ].call( self )
                }
            }

            function emitOne( handler, isFn, self, arg1 ) {
                if ( isFn ) handler.call( self, arg1 );
                else {
                    var len = handler.length;
                    var listeners = arrayClone( handler, len );
                    for ( var i = 0; i < len; ++i ) listeners[ i ].call( self, arg1 )
                }
            }

            function emitTwo( handler, isFn, self, arg1, arg2 ) {
                if ( isFn ) handler.call( self, arg1, arg2 );
                else {
                    var len = handler.length;
                    var listeners = arrayClone( handler, len );
                    for ( var i = 0; i < len; ++i ) listeners[ i ].call( self, arg1, arg2 )
                }
            }

            function emitThree( handler, isFn, self, arg1, arg2, arg3 ) {
                if ( isFn ) handler.call( self, arg1, arg2, arg3 );
                else {
                    var len = handler.length;
                    var listeners = arrayClone( handler, len );
                    for ( var i = 0; i < len; ++i ) listeners[ i ].call( self, arg1, arg2, arg3 )
                }
            }

            function emitMany( handler, isFn, self, args ) {
                if ( isFn ) handler.apply( self, args );
                else {
                    var len = handler.length;
                    var listeners = arrayClone( handler, len );
                    for ( var i = 0; i < len; ++i ) listeners[ i ].apply( self, args )
                }
            }
            EventEmitter.prototype.emit = function emit( type ) {
                var er, handler, len, args, i, events;
                var doError = type === "error";
                events = this._events;
                if ( events ) doError = doError && events.error == null;
                else if ( !doError ) return false;
                if ( doError ) {
                    if ( arguments.length > 1 ) er = arguments[ 1 ];
                    if ( er instanceof Error ) {
                        throw er
                    } else {
                        var err = new Error( 'Unhandled "error" event. (' + er + ")" );
                        err.context = er;
                        throw err
                    }
                    return false
                }
                handler = events[ type ];
                if ( !handler ) return false;
                var isFn = typeof handler === "function";
                len = arguments.length;
                switch ( len ) {
                    case 1:
                        emitNone( handler, isFn, this );
                        break;
                    case 2:
                        emitOne( handler, isFn, this, arguments[ 1 ] );
                        break;
                    case 3:
                        emitTwo( handler, isFn, this, arguments[ 1 ], arguments[ 2 ] );
                        break;
                    case 4:
                        emitThree( handler, isFn, this, arguments[ 1 ], arguments[ 2 ], arguments[ 3 ] );
                        break;
                    default:
                        args = new Array( len - 1 );
                        for ( i = 1; i < len; i++ ) args[ i - 1 ] = arguments[ i ];
                        emitMany( handler, isFn, this, args )
                }
                return true
            };

            function _addListener( target, type, listener, prepend ) {
                var m;
                var events;
                var existing;
                if ( typeof listener !== "function" ) throw new TypeError( '"listener" argument must be a function' );
                events = target._events;
                if ( !events ) {
                    events = target._events = objectCreate( null );
                    target._eventsCount = 0
                } else {
                    if ( events.newListener ) {
                        target.emit( "newListener", type, listener.listener ? listener.listener : listener );
                        events = target._events
                    }
                    existing = events[ type ]
                }
                if ( !existing ) {
                    existing = events[ type ] = listener;
                    ++target._eventsCount
                } else {
                    if ( typeof existing === "function" ) {
                        existing = events[ type ] = prepend ? [ listener, existing ] : [ existing, listener ]
                    } else {
                        if ( prepend ) {
                            existing.unshift( listener )
                        } else {
                            existing.push( listener )
                        }
                    }
                    if ( !existing.warned ) {
                        m = $getMaxListeners( target );
                        if ( m && m > 0 && existing.length > m ) {
                            existing.warned = true;
                            var w = new Error( "Possible EventEmitter memory leak detected. " + existing.length + ' "' + String( type ) + '" listeners ' + "added. Use emitter.setMaxListeners() to " + "increase limit." );
                            w.name = "MaxListenersExceededWarning";
                            w.emitter = target;
                            w.type = type;
                            w.count = existing.length;
                            if ( typeof console === "object" && console.warn ) {
                                console.warn( "%s: %s", w.name, w.message )
                            }
                        }
                    }
                }
                return target
            }
            EventEmitter.prototype.addListener = function addListener( type, listener ) {
                return _addListener( this, type, listener, false )
            };
            EventEmitter.prototype.on = EventEmitter.prototype.addListener;
            EventEmitter.prototype.prependListener = function prependListener( type, listener ) {
                return _addListener( this, type, listener, true )
            };

            function onceWrapper() {
                if ( !this.fired ) {
                    this.target.removeListener( this.type, this.wrapFn );
                    this.fired = true;
                    switch ( arguments.length ) {
                        case 0:
                            return this.listener.call( this.target );
                        case 1:
                            return this.listener.call( this.target, arguments[ 0 ] );
                        case 2:
                            return this.listener.call( this.target, arguments[ 0 ], arguments[ 1 ] );
                        case 3:
                            return this.listener.call( this.target, arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );
                        default:
                            var args = new Array( arguments.length );
                            for ( var i = 0; i < args.length; ++i ) args[ i ] = arguments[ i ];
                            this.listener.apply( this.target, args )
                    }
                }
            }

            function _onceWrap( target, type, listener ) {
                var state = {
                    fired: false,
                    wrapFn: undefined,
                    target: target,
                    type: type,
                    listener: listener
                };
                var wrapped = bind.call( onceWrapper, state );
                wrapped.listener = listener;
                state.wrapFn = wrapped;
                return wrapped
            }
            EventEmitter.prototype.once = function once( type, listener ) {
                if ( typeof listener !== "function" ) throw new TypeError( '"listener" argument must be a function' );
                this.on( type, _onceWrap( this, type, listener ) );
                return this
            };
            EventEmitter.prototype.prependOnceListener = function prependOnceListener( type, listener ) {
                if ( typeof listener !== "function" ) throw new TypeError( '"listener" argument must be a function' );
                this.prependListener( type, _onceWrap( this, type, listener ) );
                return this
            };
            EventEmitter.prototype.removeListener = function removeListener( type, listener ) {
                var list, events, position, i, originalListener;
                if ( typeof listener !== "function" ) throw new TypeError( '"listener" argument must be a function' );
                events = this._events;
                if ( !events ) return this;
                list = events[ type ];
                if ( !list ) return this;
                if ( list === listener || list.listener === listener ) {
                    if ( --this._eventsCount === 0 ) this._events = objectCreate( null );
                    else {
                        delete events[ type ];
                        if ( events.removeListener ) this.emit( "removeListener", type, list.listener || listener )
                    }
                } else if ( typeof list !== "function" ) {
                    position = -1;
                    for ( i = list.length - 1; i >= 0; i-- ) {
                        if ( list[ i ] === listener || list[ i ].listener === listener ) {
                            originalListener = list[ i ].listener;
                            position = i;
                            break
                        }
                    }
                    if ( position < 0 ) return this;
                    if ( position === 0 ) list.shift();
                    else spliceOne( list, position );
                    if ( list.length === 1 ) events[ type ] = list[ 0 ];
                    if ( events.removeListener ) this.emit( "removeListener", type, originalListener || listener )
                }
                return this
            };
            EventEmitter.prototype.removeAllListeners = function removeAllListeners( type ) {
                var listeners, events, i;
                events = this._events;
                if ( !events ) return this;
                if ( !events.removeListener ) {
                    if ( arguments.length === 0 ) {
                        this._events = objectCreate( null );
                        this._eventsCount = 0
                    } else if ( events[ type ] ) {
                        if ( --this._eventsCount === 0 ) this._events = objectCreate( null );
                        else delete events[ type ]
                    }
                    return this
                }
                if ( arguments.length === 0 ) {
                    var keys = objectKeys( events );
                    var key;
                    for ( i = 0; i < keys.length; ++i ) {
                        key = keys[ i ];
                        if ( key === "removeListener" ) continue;
                        this.removeAllListeners( key )
                    }
                    this.removeAllListeners( "removeListener" );
                    this._events = objectCreate( null );
                    this._eventsCount = 0;
                    return this
                }
                listeners = events[ type ];
                if ( typeof listeners === "function" ) {
                    this.removeListener( type, listeners )
                } else if ( listeners ) {
                    for ( i = listeners.length - 1; i >= 0; i-- ) {
                        this.removeListener( type, listeners[ i ] )
                    }
                }
                return this
            };
            EventEmitter.prototype.listeners = function listeners( type ) {
                var evlistener;
                var ret;
                var events = this._events;
                if ( !events ) ret = [];
                else {
                    evlistener = events[ type ];
                    if ( !evlistener ) ret = [];
                    else if ( typeof evlistener === "function" ) ret = [ evlistener.listener || evlistener ];
                    else ret = unwrapListeners( evlistener )
                }
                return ret
            };
            EventEmitter.listenerCount = function( emitter, type ) {
                if ( typeof emitter.listenerCount === "function" ) {
                    return emitter.listenerCount( type )
                } else {
                    return listenerCount.call( emitter, type )
                }
            };
            EventEmitter.prototype.listenerCount = listenerCount;

            function listenerCount( type ) {
                var events = this._events;
                if ( events ) {
                    var evlistener = events[ type ];
                    if ( typeof evlistener === "function" ) {
                        return 1
                    } else if ( evlistener ) {
                        return evlistener.length
                    }
                }
                return 0
            }
            EventEmitter.prototype.eventNames = function eventNames() {
                return this._eventsCount > 0 ? Reflect.ownKeys( this._events ) : []
            };

            function spliceOne( list, index ) {
                for ( var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1 ) list[ i ] = list[ k ];
                list.pop()
            }

            function arrayClone( arr, n ) {
                var copy = new Array( n );
                for ( var i = 0; i < n; ++i ) copy[ i ] = arr[ i ];
                return copy
            }

            function unwrapListeners( arr ) {
                var ret = new Array( arr.length );
                for ( var i = 0; i < ret.length; ++i ) {
                    ret[ i ] = arr[ i ].listener || arr[ i ]
                }
                return ret
            }

            function objectCreatePolyfill( proto ) {
                var F = function() {};
                F.prototype = proto;
                return new F
            }

            function objectKeysPolyfill( obj ) {
                var keys = [];
                for ( var k in obj )
                    if ( Object.prototype.hasOwnProperty.call( obj, k ) ) {
                        keys.push( k )
                    }
                return k
            }

            function functionBindPolyfill( context ) {
                var fn = this;
                return function() {
                    return fn.apply( context, arguments )
                }
            }
        }, {} ],
        8: [ function( require, module, exports ) {
            "use strict";
            var Buffer = require( "buffer" ).Buffer;
            exports._dbcs = DBCSCodec;
            var UNASSIGNED = -1,
                GB18030_CODE = -2,
                SEQ_START = -10,
                NODE_START = -1e3,
                UNASSIGNED_NODE = new Array( 256 ),
                DEF_CHAR = -1;
            for ( var i = 0; i < 256; i++ ) UNASSIGNED_NODE[ i ] = UNASSIGNED;

            function DBCSCodec( codecOptions, iconv ) {
                this.encodingName = codecOptions.encodingName;
                if ( !codecOptions ) throw new Error( "DBCS codec is called without the data." );
                if ( !codecOptions.table ) throw new Error( "Encoding '" + this.encodingName + "' has no data." );
                var mappingTable = codecOptions.table();
                this.decodeTables = [];
                this.decodeTables[ 0 ] = UNASSIGNED_NODE.slice( 0 );
                this.decodeTableSeq = [];
                for ( var i = 0; i < mappingTable.length; i++ ) this._addDecodeChunk( mappingTable[ i ] );
                this.defaultCharUnicode = iconv.defaultCharUnicode;
                this.encodeTable = [];
                this.encodeTableSeq = [];
                var skipEncodeChars = {};
                if ( codecOptions.encodeSkipVals )
                    for ( var i = 0; i < codecOptions.encodeSkipVals.length; i++ ) {
                        var val = codecOptions.encodeSkipVals[ i ];
                        if ( typeof val === "number" ) skipEncodeChars[ val ] = true;
                        else
                            for ( var j = val.from; j <= val.to; j++ ) skipEncodeChars[ j ] = true
                    }
                this._fillEncodeTable( 0, 0, skipEncodeChars );
                if ( codecOptions.encodeAdd ) {
                    for ( var uChar in codecOptions.encodeAdd )
                        if ( Object.prototype.hasOwnProperty.call( codecOptions.encodeAdd, uChar ) ) this._setEncodeChar( uChar.charCodeAt( 0 ), codecOptions.encodeAdd[ uChar ] )
                }
                this.defCharSB = this.encodeTable[ 0 ][ iconv.defaultCharSingleByte.charCodeAt( 0 ) ];
                if ( this.defCharSB === UNASSIGNED ) this.defCharSB = this.encodeTable[ 0 ][ "?" ];
                if ( this.defCharSB === UNASSIGNED ) this.defCharSB = "?".charCodeAt( 0 );
                if ( typeof codecOptions.gb18030 === "function" ) {
                    this.gb18030 = codecOptions.gb18030();
                    var thirdByteNodeIdx = this.decodeTables.length;
                    var thirdByteNode = this.decodeTables[ thirdByteNodeIdx ] = UNASSIGNED_NODE.slice( 0 );
                    var fourthByteNodeIdx = this.decodeTables.length;
                    var fourthByteNode = this.decodeTables[ fourthByteNodeIdx ] = UNASSIGNED_NODE.slice( 0 );
                    for ( var i = 129; i <= 254; i++ ) {
                        var secondByteNodeIdx = NODE_START - this.decodeTables[ 0 ][ i ];
                        var secondByteNode = this.decodeTables[ secondByteNodeIdx ];
                        for ( var j = 48; j <= 57; j++ ) secondByteNode[ j ] = NODE_START - thirdByteNodeIdx
                    }
                    for ( var i = 129; i <= 254; i++ ) thirdByteNode[ i ] = NODE_START - fourthByteNodeIdx;
                    for ( var i = 48; i <= 57; i++ ) fourthByteNode[ i ] = GB18030_CODE
                }
            }
            DBCSCodec.prototype.encoder = DBCSEncoder;
            DBCSCodec.prototype.decoder = DBCSDecoder;
            DBCSCodec.prototype._getDecodeTrieNode = function( addr ) {
                var bytes = [];
                for ( ; addr > 0; addr >>= 8 ) bytes.push( addr & 255 );
                if ( bytes.length == 0 ) bytes.push( 0 );
                var node = this.decodeTables[ 0 ];
                for ( var i = bytes.length - 1; i > 0; i-- ) {
                    var val = node[ bytes[ i ] ];
                    if ( val == UNASSIGNED ) {
                        node[ bytes[ i ] ] = NODE_START - this.decodeTables.length;
                        this.decodeTables.push( node = UNASSIGNED_NODE.slice( 0 ) )
                    } else if ( val <= NODE_START ) {
                        node = this.decodeTables[ NODE_START - val ]
                    } else throw new Error( "Overwrite byte in " + this.encodingName + ", addr: " + addr.toString( 16 ) )
                }
                return node
            };
            DBCSCodec.prototype._addDecodeChunk = function( chunk ) {
                var curAddr = parseInt( chunk[ 0 ], 16 );
                var writeTable = this._getDecodeTrieNode( curAddr );
                curAddr = curAddr & 255;
                for ( var k = 1; k < chunk.length; k++ ) {
                    var part = chunk[ k ];
                    if ( typeof part === "string" ) {
                        for ( var l = 0; l < part.length; ) {
                            var code = part.charCodeAt( l++ );
                            if ( 55296 <= code && code < 56320 ) {
                                var codeTrail = part.charCodeAt( l++ );
                                if ( 56320 <= codeTrail && codeTrail < 57344 ) writeTable[ curAddr++ ] = 65536 + ( code - 55296 ) * 1024 + ( codeTrail - 56320 );
                                else throw new Error( "Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[ 0 ] )
                            } else if ( 4080 < code && code <= 4095 ) {
                                var len = 4095 - code + 2;
                                var seq = [];
                                for ( var m = 0; m < len; m++ ) seq.push( part.charCodeAt( l++ ) );
                                writeTable[ curAddr++ ] = SEQ_START - this.decodeTableSeq.length;
                                this.decodeTableSeq.push( seq )
                            } else writeTable[ curAddr++ ] = code
                        }
                    } else if ( typeof part === "number" ) {
                        var charCode = writeTable[ curAddr - 1 ] + 1;
                        for ( var l = 0; l < part; l++ ) writeTable[ curAddr++ ] = charCode++
                    } else throw new Error( "Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[ 0 ] )
                }
                if ( curAddr > 255 ) throw new Error( "Incorrect chunk in " + this.encodingName + " at addr " + chunk[ 0 ] + ": too long" + curAddr )
            };
            DBCSCodec.prototype._getEncodeBucket = function( uCode ) {
                var high = uCode >> 8;
                if ( this.encodeTable[ high ] === undefined ) this.encodeTable[ high ] = UNASSIGNED_NODE.slice( 0 );
                return this.encodeTable[ high ]
            };
            DBCSCodec.prototype._setEncodeChar = function( uCode, dbcsCode ) {
                var bucket = this._getEncodeBucket( uCode );
                var low = uCode & 255;
                if ( bucket[ low ] <= SEQ_START ) this.encodeTableSeq[ SEQ_START - bucket[ low ] ][ DEF_CHAR ] = dbcsCode;
                else if ( bucket[ low ] == UNASSIGNED ) bucket[ low ] = dbcsCode
            };
            DBCSCodec.prototype._setEncodeSequence = function( seq, dbcsCode ) {
                var uCode = seq[ 0 ];
                var bucket = this._getEncodeBucket( uCode );
                var low = uCode & 255;
                var node;
                if ( bucket[ low ] <= SEQ_START ) {
                    node = this.encodeTableSeq[ SEQ_START - bucket[ low ] ]
                } else {
                    node = {};
                    if ( bucket[ low ] !== UNASSIGNED ) node[ DEF_CHAR ] = bucket[ low ];
                    bucket[ low ] = SEQ_START - this.encodeTableSeq.length;
                    this.encodeTableSeq.push( node )
                }
                for ( var j = 1; j < seq.length - 1; j++ ) {
                    var oldVal = node[ uCode ];
                    if ( typeof oldVal === "object" ) node = oldVal;
                    else {
                        node = node[ uCode ] = {};
                        if ( oldVal !== undefined ) node[ DEF_CHAR ] = oldVal
                    }
                }
                uCode = seq[ seq.length - 1 ];
                node[ uCode ] = dbcsCode
            };
            DBCSCodec.prototype._fillEncodeTable = function( nodeIdx, prefix, skipEncodeChars ) {
                var node = this.decodeTables[ nodeIdx ];
                for ( var i = 0; i < 256; i++ ) {
                    var uCode = node[ i ];
                    var mbCode = prefix + i;
                    if ( skipEncodeChars[ mbCode ] ) continue;
                    if ( uCode >= 0 ) this._setEncodeChar( uCode, mbCode );
                    else if ( uCode <= NODE_START ) this._fillEncodeTable( NODE_START - uCode, mbCode << 8, skipEncodeChars );
                    else if ( uCode <= SEQ_START ) this._setEncodeSequence( this.decodeTableSeq[ SEQ_START - uCode ], mbCode )
                }
            };

            function DBCSEncoder( options, codec ) {
                this.leadSurrogate = -1;
                this.seqObj = undefined;
                this.encodeTable = codec.encodeTable;
                this.encodeTableSeq = codec.encodeTableSeq;
                this.defaultCharSingleByte = codec.defCharSB;
                this.gb18030 = codec.gb18030
            }
            DBCSEncoder.prototype.write = function( str ) {
                var newBuf = new Buffer( str.length * ( this.gb18030 ? 4 : 3 ) ),
                    leadSurrogate = this.leadSurrogate,
                    seqObj = this.seqObj,
                    nextChar = -1,
                    i = 0,
                    j = 0;
                while ( true ) {
                    if ( nextChar === -1 ) {
                        if ( i == str.length ) break;
                        var uCode = str.charCodeAt( i++ )
                    } else {
                        var uCode = nextChar;
                        nextChar = -1
                    }
                    if ( 55296 <= uCode && uCode < 57344 ) {
                        if ( uCode < 56320 ) {
                            if ( leadSurrogate === -1 ) {
                                leadSurrogate = uCode;
                                continue
                            } else {
                                leadSurrogate = uCode;
                                uCode = UNASSIGNED
                            }
                        } else {
                            if ( leadSurrogate !== -1 ) {
                                uCode = 65536 + ( leadSurrogate - 55296 ) * 1024 + ( uCode - 56320 );
                                leadSurrogate = -1
                            } else {
                                uCode = UNASSIGNED
                            }
                        }
                    } else if ( leadSurrogate !== -1 ) {
                        nextChar = uCode;
                        uCode = UNASSIGNED;
                        leadSurrogate = -1
                    }
                    var dbcsCode = UNASSIGNED;
                    if ( seqObj !== undefined && uCode != UNASSIGNED ) {
                        var resCode = seqObj[ uCode ];
                        if ( typeof resCode === "object" ) {
                            seqObj = resCode;
                            continue
                        } else if ( typeof resCode == "number" ) {
                            dbcsCode = resCode
                        } else if ( resCode == undefined ) {
                            resCode = seqObj[ DEF_CHAR ];
                            if ( resCode !== undefined ) {
                                dbcsCode = resCode;
                                nextChar = uCode
                            } else {}
                        }
                        seqObj = undefined
                    } else if ( uCode >= 0 ) {
                        var subtable = this.encodeTable[ uCode >> 8 ];
                        if ( subtable !== undefined ) dbcsCode = subtable[ uCode & 255 ];
                        if ( dbcsCode <= SEQ_START ) {
                            seqObj = this.encodeTableSeq[ SEQ_START - dbcsCode ];
                            continue
                        }
                        if ( dbcsCode == UNASSIGNED && this.gb18030 ) {
                            var idx = findIdx( this.gb18030.uChars, uCode );
                            if ( idx != -1 ) {
                                var dbcsCode = this.gb18030.gbChars[ idx ] + ( uCode - this.gb18030.uChars[ idx ] );
                                newBuf[ j++ ] = 129 + Math.floor( dbcsCode / 12600 );
                                dbcsCode = dbcsCode % 12600;
                                newBuf[ j++ ] = 48 + Math.floor( dbcsCode / 1260 );
                                dbcsCode = dbcsCode % 1260;
                                newBuf[ j++ ] = 129 + Math.floor( dbcsCode / 10 );
                                dbcsCode = dbcsCode % 10;
                                newBuf[ j++ ] = 48 + dbcsCode;
                                continue
                            }
                        }
                    }
                    if ( dbcsCode === UNASSIGNED ) dbcsCode = this.defaultCharSingleByte;
                    if ( dbcsCode < 256 ) {
                        newBuf[ j++ ] = dbcsCode
                    } else if ( dbcsCode < 65536 ) {
                        newBuf[ j++ ] = dbcsCode >> 8;
                        newBuf[ j++ ] = dbcsCode & 255
                    } else {
                        newBuf[ j++ ] = dbcsCode >> 16;
                        newBuf[ j++ ] = dbcsCode >> 8 & 255;
                        newBuf[ j++ ] = dbcsCode & 255
                    }
                }
                this.seqObj = seqObj;
                this.leadSurrogate = leadSurrogate;
                return newBuf.slice( 0, j )
            };
            DBCSEncoder.prototype.end = function() {
                if ( this.leadSurrogate === -1 && this.seqObj === undefined ) return;
                var newBuf = new Buffer( 10 ),
                    j = 0;
                if ( this.seqObj ) {
                    var dbcsCode = this.seqObj[ DEF_CHAR ];
                    if ( dbcsCode !== undefined ) {
                        if ( dbcsCode < 256 ) {
                            newBuf[ j++ ] = dbcsCode
                        } else {
                            newBuf[ j++ ] = dbcsCode >> 8;
                            newBuf[ j++ ] = dbcsCode & 255
                        }
                    } else {}
                    this.seqObj = undefined
                }
                if ( this.leadSurrogate !== -1 ) {
                    newBuf[ j++ ] = this.defaultCharSingleByte;
                    this.leadSurrogate = -1
                }
                return newBuf.slice( 0, j )
            };
            DBCSEncoder.prototype.findIdx = findIdx;

            function DBCSDecoder( options, codec ) {
                this.nodeIdx = 0;
                this.prevBuf = new Buffer( 0 );
                this.decodeTables = codec.decodeTables;
                this.decodeTableSeq = codec.decodeTableSeq;
                this.defaultCharUnicode = codec.defaultCharUnicode;
                this.gb18030 = codec.gb18030
            }
            DBCSDecoder.prototype.write = function( buf ) {
                var newBuf = new Buffer( buf.length * 2 ),
                    nodeIdx = this.nodeIdx,
                    prevBuf = this.prevBuf,
                    prevBufOffset = this.prevBuf.length,
                    seqStart = -this.prevBuf.length,
                    uCode;
                if ( prevBufOffset > 0 ) prevBuf = Buffer.concat( [ prevBuf, buf.slice( 0, 10 ) ] );
                for ( var i = 0, j = 0; i < buf.length; i++ ) {
                    var curByte = i >= 0 ? buf[ i ] : prevBuf[ i + prevBufOffset ];
                    var uCode = this.decodeTables[ nodeIdx ][ curByte ];
                    if ( uCode >= 0 ) {} else if ( uCode === UNASSIGNED ) {
                        i = seqStart;
                        uCode = this.defaultCharUnicode.charCodeAt( 0 )
                    } else if ( uCode === GB18030_CODE ) {
                        var curSeq = seqStart >= 0 ? buf.slice( seqStart, i + 1 ) : prevBuf.slice( seqStart + prevBufOffset, i + 1 + prevBufOffset );
                        var ptr = ( curSeq[ 0 ] - 129 ) * 12600 + ( curSeq[ 1 ] - 48 ) * 1260 + ( curSeq[ 2 ] - 129 ) * 10 + ( curSeq[ 3 ] - 48 );
                        var idx = findIdx( this.gb18030.gbChars, ptr );
                        uCode = this.gb18030.uChars[ idx ] + ptr - this.gb18030.gbChars[ idx ]
                    } else if ( uCode <= NODE_START ) {
                        nodeIdx = NODE_START - uCode;
                        continue
                    } else if ( uCode <= SEQ_START ) {
                        var seq = this.decodeTableSeq[ SEQ_START - uCode ];
                        for ( var k = 0; k < seq.length - 1; k++ ) {
                            uCode = seq[ k ];
                            newBuf[ j++ ] = uCode & 255;
                            newBuf[ j++ ] = uCode >> 8
                        }
                        uCode = seq[ seq.length - 1 ]
                    } else throw new Error( "iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte );
                    if ( uCode > 65535 ) {
                        uCode -= 65536;
                        var uCodeLead = 55296 + Math.floor( uCode / 1024 );
                        newBuf[ j++ ] = uCodeLead & 255;
                        newBuf[ j++ ] = uCodeLead >> 8;
                        uCode = 56320 + uCode % 1024
                    }
                    newBuf[ j++ ] = uCode & 255;
                    newBuf[ j++ ] = uCode >> 8;
                    nodeIdx = 0;
                    seqStart = i + 1
                }
                this.nodeIdx = nodeIdx;
                this.prevBuf = seqStart >= 0 ? buf.slice( seqStart ) : prevBuf.slice( seqStart + prevBufOffset );
                return newBuf.slice( 0, j ).toString( "ucs2" )
            };
            DBCSDecoder.prototype.end = function() {
                var ret = "";
                while ( this.prevBuf.length > 0 ) {
                    ret += this.defaultCharUnicode;
                    var buf = this.prevBuf.slice( 1 );
                    this.prevBuf = new Buffer( 0 );
                    this.nodeIdx = 0;
                    if ( buf.length > 0 ) ret += this.write( buf )
                }
                this.nodeIdx = 0;
                return ret
            };

            function findIdx( table, val ) {
                if ( table[ 0 ] > val ) return -1;
                var l = 0,
                    r = table.length;
                while ( l < r - 1 ) {
                    var mid = l + Math.floor( ( r - l + 1 ) / 2 );
                    if ( table[ mid ] <= val ) l = mid;
                    else r = mid
                }
                return l
            }
        }, {
            buffer: 4
        } ],
        9: [ function( require, module, exports ) {
            "use strict";
            module.exports = {
                shiftjis: {
                    type: "_dbcs",
                    table: function() {
                        return require( "./tables/shiftjis.json" )
                    },
                    encodeAdd: {
                        "": 92,
                        "": 126
                    },
                    encodeSkipVals: [ {
                        from: 60736,
                        to: 63808
                    } ]
                },
                csshiftjis: "shiftjis",
                mskanji: "shiftjis",
                sjis: "shiftjis",
                windows31j: "shiftjis",
                ms31j: "shiftjis",
                xsjis: "shiftjis",
                windows932: "shiftjis",
                ms932: "shiftjis",
                932: "shiftjis",
                cp932: "shiftjis",
                eucjp: {
                    type: "_dbcs",
                    table: function() {
                        return require( "./tables/eucjp.json" )
                    },
                    encodeAdd: {
                        "": 92,
                        "": 126
                    }
                },
                gb2312: "cp936",
                gb231280: "cp936",
                gb23121980: "cp936",
                csgb2312: "cp936",
                csiso58gb231280: "cp936",
                euccn: "cp936",
                windows936: "cp936",
                ms936: "cp936",
                936: "cp936",
                cp936: {
                    type: "_dbcs",
                    table: function() {
                        return require( "./tables/cp936.json" )
                    }
                },
                gbk: {
                    type: "_dbcs",
                    table: function() {
                        return require( "./tables/cp936.json" ).concat( require( "./tables/gbk-added.json" ) )
                    }
                },
                xgbk: "gbk",
                isoir58: "gbk",
                gb18030: {
                    type: "_dbcs",
                    table: function() {
                        return require( "./tables/cp936.json" ).concat( require( "./tables/gbk-added.json" ) )
                    },
                    gb18030: function() {
                        return require( "./tables/gb18030-ranges.json" )
                    },
                    encodeSkipVals: [ 128 ],
                    encodeAdd: {
                        "": 41699
                    }
                },
                chinese: "gb18030",
                windows949: "cp949",
                ms949: "cp949",
                949: "cp949",
                cp949: {
                    type: "_dbcs",
                    table: function() {
                        return require( "./tables/cp949.json" )
                    }
                },
                cseuckr: "cp949",
                csksc56011987: "cp949",
                euckr: "cp949",
                isoir149: "cp949",
                korean: "cp949",
                ksc56011987: "cp949",
                ksc56011989: "cp949",
                ksc5601: "cp949",
                windows950: "cp950",
                ms950: "cp950",
                950: "cp950",
                cp950: {
                    type: "_dbcs",
                    table: function() {
                        return require( "./tables/cp950.json" )
                    }
                },
                big5: "big5hkscs",
                big5hkscs: {
                    type: "_dbcs",
                    table: function() {
                        return require( "./tables/cp950.json" ).concat( require( "./tables/big5-added.json" ) )
                    },
                    encodeSkipVals: [ 41676 ]
                },
                cnbig5: "big5hkscs",
                csbig5: "big5hkscs",
                xxbig5: "big5hkscs"
            }
        }, {
            "./tables/big5-added.json": 15,
            "./tables/cp936.json": 16,
            "./tables/cp949.json": 17,
            "./tables/cp950.json": 18,
            "./tables/eucjp.json": 19,
            "./tables/gb18030-ranges.json": 20,
            "./tables/gbk-added.json": 21,
            "./tables/shiftjis.json": 22
        } ],
        10: [ function( require, module, exports ) {
            "use strict";
            var modules = [ require( "./internal" ), require( "./utf16" ), require( "./utf7" ), require( "./sbcs-codec" ), require( "./sbcs-data" ), require( "./sbcs-data-generated" ), require( "./dbcs-codec" ), require( "./dbcs-data" ) ];
            for ( var i = 0; i < modules.length; i++ ) {
                var module = modules[ i ];
                for ( var enc in module )
                    if ( Object.prototype.hasOwnProperty.call( module, enc ) ) exports[ enc ] = module[ enc ]
            }
        }, {
            "./dbcs-codec": 8,
            "./dbcs-data": 9,
            "./internal": 11,
            "./sbcs-codec": 12,
            "./sbcs-data": 14,
            "./sbcs-data-generated": 13,
            "./utf16": 23,
            "./utf7": 24
        } ],
        11: [ function( require, module, exports ) {
            "use strict";
            var Buffer = require( "buffer" ).Buffer;
            module.exports = {
                utf8: {
                    type: "_internal",
                    bomAware: true
                },
                cesu8: {
                    type: "_internal",
                    bomAware: true
                },
                unicode11utf8: "utf8",
                ucs2: {
                    type: "_internal",
                    bomAware: true
                },
                utf16le: "ucs2",
                binary: {
                    type: "_internal"
                },
                base64: {
                    type: "_internal"
                },
                hex: {
                    type: "_internal"
                },
                _internal: InternalCodec
            };

            function InternalCodec( codecOptions, iconv ) {
                this.enc = codecOptions.encodingName;
                this.bomAware = codecOptions.bomAware;
                if ( this.enc === "base64" ) this.encoder = InternalEncoderBase64;
                else if ( this.enc === "cesu8" ) {
                    this.enc = "utf8";
                    this.encoder = InternalEncoderCesu8;
                    if ( new Buffer( "eda0bdedb2a9", "hex" ).toString() !== "" ) {
                        this.decoder = InternalDecoderCesu8;
                        this.defaultCharUnicode = iconv.defaultCharUnicode
                    }
                }
            }
            InternalCodec.prototype.encoder = InternalEncoder;
            InternalCodec.prototype.decoder = InternalDecoder;
            var StringDecoder = require( "string_decoder" ).StringDecoder;
            if ( !StringDecoder.prototype.end ) StringDecoder.prototype.end = function() {};

            function InternalDecoder( options, codec ) {
                StringDecoder.call( this, codec.enc )
            }
            InternalDecoder.prototype = StringDecoder.prototype;

            function InternalEncoder( options, codec ) {
                this.enc = codec.enc
            }
            InternalEncoder.prototype.write = function( str ) {
                return new Buffer( str, this.enc )
            };
            InternalEncoder.prototype.end = function() {};

            function InternalEncoderBase64( options, codec ) {
                this.prevStr = ""
            }
            InternalEncoderBase64.prototype.write = function( str ) {
                str = this.prevStr + str;
                var completeQuads = str.length - str.length % 4;
                this.prevStr = str.slice( completeQuads );
                str = str.slice( 0, completeQuads );
                return new Buffer( str, "base64" )
            };
            InternalEncoderBase64.prototype.end = function() {
                return new Buffer( this.prevStr, "base64" )
            };

            function InternalEncoderCesu8( options, codec ) {}
            InternalEncoderCesu8.prototype.write = function( str ) {
                var buf = new Buffer( str.length * 3 ),
                    bufIdx = 0;
                for ( var i = 0; i < str.length; i++ ) {
                    var charCode = str.charCodeAt( i );
                    if ( charCode < 128 ) buf[ bufIdx++ ] = charCode;
                    else if ( charCode < 2048 ) {
                        buf[ bufIdx++ ] = 192 + ( charCode >>> 6 );
                        buf[ bufIdx++ ] = 128 + ( charCode & 63 )
                    } else {
                        buf[ bufIdx++ ] = 224 + ( charCode >>> 12 );
                        buf[ bufIdx++ ] = 128 + ( charCode >>> 6 & 63 );
                        buf[ bufIdx++ ] = 128 + ( charCode & 63 )
                    }
                }
                return buf.slice( 0, bufIdx )
            };
            InternalEncoderCesu8.prototype.end = function() {};

            function InternalDecoderCesu8( options, codec ) {
                this.acc = 0;
                this.contBytes = 0;
                this.accBytes = 0;
                this.defaultCharUnicode = codec.defaultCharUnicode
            }
            InternalDecoderCesu8.prototype.write = function( buf ) {
                var acc = this.acc,
                    contBytes = this.contBytes,
                    accBytes = this.accBytes,
                    res = "";
                for ( var i = 0; i < buf.length; i++ ) {
                    var curByte = buf[ i ];
                    if ( ( curByte & 192 ) !== 128 ) {
                        if ( contBytes > 0 ) {
                            res += this.defaultCharUnicode;
                            contBytes = 0
                        }
                        if ( curByte < 128 ) {
                            res += String.fromCharCode( curByte )
                        } else if ( curByte < 224 ) {
                            acc = curByte & 31;
                            contBytes = 1;
                            accBytes = 1
                        } else if ( curByte < 240 ) {
                            acc = curByte & 15;
                            contBytes = 2;
                            accBytes = 1
                        } else {
                            res += this.defaultCharUnicode
                        }
                    } else {
                        if ( contBytes > 0 ) {
                            acc = acc << 6 | curByte & 63;
                            contBytes--;
                            accBytes++;
                            if ( contBytes === 0 ) {
                                if ( accBytes === 2 && acc < 128 && acc > 0 ) res += this.defaultCharUnicode;
                                else if ( accBytes === 3 && acc < 2048 ) res += this.defaultCharUnicode;
                                else res += String.fromCharCode( acc )
                            }
                        } else {
                            res += this.defaultCharUnicode
                        }
                    }
                }
                this.acc = acc;
                this.contBytes = contBytes;
                this.accBytes = accBytes;
                return res
            };
            InternalDecoderCesu8.prototype.end = function() {
                var res = 0;
                if ( this.contBytes > 0 ) res += this.defaultCharUnicode;
                return res
            }
        }, {
            buffer: 4,
            string_decoder: 62
        } ],
        12: [ function( require, module, exports ) {
            "use strict";
            var Buffer = require( "buffer" ).Buffer;
            exports._sbcs = SBCSCodec;

            function SBCSCodec( codecOptions, iconv ) {
                if ( !codecOptions ) throw new Error( "SBCS codec is called without the data." );
                if ( !codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256 ) throw new Error( "Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)" );
                if ( codecOptions.chars.length === 128 ) {
                    var asciiString = "";
                    for ( var i = 0; i < 128; i++ ) asciiString += String.fromCharCode( i );
                    codecOptions.chars = asciiString + codecOptions.chars
                }
                this.decodeBuf = new Buffer( codecOptions.chars, "ucs2" );
                var encodeBuf = new Buffer( 65536 );
                encodeBuf.fill( iconv.defaultCharSingleByte.charCodeAt( 0 ) );
                for ( var i = 0; i < codecOptions.chars.length; i++ ) encodeBuf[ codecOptions.chars.charCodeAt( i ) ] = i;
                this.encodeBuf = encodeBuf
            }
            SBCSCodec.prototype.encoder = SBCSEncoder;
            SBCSCodec.prototype.decoder = SBCSDecoder;

            function SBCSEncoder( options, codec ) {
                this.encodeBuf = codec.encodeBuf
            }
            SBCSEncoder.prototype.write = function( str ) {
                var buf = new Buffer( str.length );
                for ( var i = 0; i < str.length; i++ ) buf[ i ] = this.encodeBuf[ str.charCodeAt( i ) ];
                return buf
            };
            SBCSEncoder.prototype.end = function() {};

            function SBCSDecoder( options, codec ) {
                this.decodeBuf = codec.decodeBuf
            }
            SBCSDecoder.prototype.write = function( buf ) {
                var decodeBuf = this.decodeBuf;
                var newBuf = new Buffer( buf.length * 2 );
                var idx1 = 0,
                    idx2 = 0;
                for ( var i = 0; i < buf.length; i++ ) {
                    idx1 = buf[ i ] * 2;
                    idx2 = i * 2;
                    newBuf[ idx2 ] = decodeBuf[ idx1 ];
                    newBuf[ idx2 + 1 ] = decodeBuf[ idx1 + 1 ]
                }
                return newBuf.toString( "ucs2" )
            };
            SBCSDecoder.prototype.end = function() {}
        }, {
            buffer: 4
        } ],
        13: [ function( require, module, exports ) {
            "use strict";
            module.exports = {
                437: "cp437",
                737: "cp737",
                775: "cp775",
                850: "cp850",
                852: "cp852",
                855: "cp855",
                856: "cp856",
                857: "cp857",
                858: "cp858",
                860: "cp860",
                861: "cp861",
                862: "cp862",
                863: "cp863",
                864: "cp864",
                865: "cp865",
                866: "cp866",
                869: "cp869",
                874: "windows874",
                922: "cp922",
                1046: "cp1046",
                1124: "cp1124",
                1125: "cp1125",
                1129: "cp1129",
                1133: "cp1133",
                1161: "cp1161",
                1162: "cp1162",
                1163: "cp1163",
                1250: "windows1250",
                1251: "windows1251",
                1252: "windows1252",
                1253: "windows1253",
                1254: "windows1254",
                1255: "windows1255",
                1256: "windows1256",
                1257: "windows1257",
                1258: "windows1258",
                28591: "iso88591",
                28592: "iso88592",
                28593: "iso88593",
                28594: "iso88594",
                28595: "iso88595",
                28596: "iso88596",
                28597: "iso88597",
                28598: "iso88598",
                28599: "iso88599",
                28600: "iso885910",
                28601: "iso885911",
                28603: "iso885913",
                28604: "iso885914",
                28605: "iso885915",
                28606: "iso885916",
                windows874: {
                    type: "_sbcs",
                    chars: ""
                },
                win874: "windows874",
                cp874: "windows874",
                windows1250: {
                    type: "_sbcs",
                    chars: ""
                },
                win1250: "windows1250",
                cp1250: "windows1250",
                windows1251: {
                    type: "_sbcs",
                    chars: ""
                },
                win1251: "windows1251",
                cp1251: "windows1251",
                windows1252: {
                    type: "_sbcs",
                    chars: ""
                },
                win1252: "windows1252",
                cp1252: "windows1252",
                windows1253: {
                    type: "_sbcs",
                    chars: ""
                },
                win1253: "windows1253",
                cp1253: "windows1253",
                windows1254: {
                    type: "_sbcs",
                    chars: ""
                },
                win1254: "windows1254",
                cp1254: "windows1254",
                windows1255: {
                    type: "_sbcs",
                    chars: ""
                },
                win1255: "windows1255",
                cp1255: "windows1255",
                windows1256: {
                    type: "_sbcs",
                    chars: ""
                },
                win1256: "windows1256",
                cp1256: "windows1256",
                windows1257: {
                    type: "_sbcs",
                    chars: ""
                },
                win1257: "windows1257",
                cp1257: "windows1257",
                windows1258: {
                    type: "_sbcs",
                    chars: ""
                },
                win1258: "windows1258",
                cp1258: "windows1258",
                iso88591: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28591: "iso88591",
                iso88592: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28592: "iso88592",
                iso88593: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28593: "iso88593",
                iso88594: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28594: "iso88594",
                iso88595: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28595: "iso88595",
                iso88596: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28596: "iso88596",
                iso88597: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28597: "iso88597",
                iso88598: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28598: "iso88598",
                iso88599: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28599: "iso88599",
                iso885910: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28600: "iso885910",
                iso885911: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28601: "iso885911",
                iso885913: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28603: "iso885913",
                iso885914: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28604: "iso885914",
                iso885915: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28605: "iso885915",
                iso885916: {
                    type: "_sbcs",
                    chars: ""
                },
                cp28606: "iso885916",
                cp437: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm437: "cp437",
                csibm437: "cp437",
                cp737: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm737: "cp737",
                csibm737: "cp737",
                cp775: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm775: "cp775",
                csibm775: "cp775",
                cp850: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm850: "cp850",
                csibm850: "cp850",
                cp852: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm852: "cp852",
                csibm852: "cp852",
                cp855: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm855: "cp855",
                csibm855: "cp855",
                cp856: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm856: "cp856",
                csibm856: "cp856",
                cp857: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm857: "cp857",
                csibm857: "cp857",
                cp858: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm858: "cp858",
                csibm858: "cp858",
                cp860: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm860: "cp860",
                csibm860: "cp860",
                cp861: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm861: "cp861",
                csibm861: "cp861",
                cp862: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm862: "cp862",
                csibm862: "cp862",
                cp863: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm863: "cp863",
                csibm863: "cp863",
                cp864: {
                    type: "_sbcs",
                    chars: "\0\b\t\n\v\f\r !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
                },
                ibm864: "cp864",
                csibm864: "cp864",
                cp865: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm865: "cp865",
                csibm865: "cp865",
                cp866: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm866: "cp866",
                csibm866: "cp866",
                cp869: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm869: "cp869",
                csibm869: "cp869",
                cp922: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm922: "cp922",
                csibm922: "cp922",
                cp1046: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm1046: "cp1046",
                csibm1046: "cp1046",
                cp1124: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm1124: "cp1124",
                csibm1124: "cp1124",
                cp1125: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm1125: "cp1125",
                csibm1125: "cp1125",
                cp1129: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm1129: "cp1129",
                csibm1129: "cp1129",
                cp1133: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm1133: "cp1133",
                csibm1133: "cp1133",
                cp1161: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm1161: "cp1161",
                csibm1161: "cp1161",
                cp1162: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm1162: "cp1162",
                csibm1162: "cp1162",
                cp1163: {
                    type: "_sbcs",
                    chars: ""
                },
                ibm1163: "cp1163",
                csibm1163: "cp1163",
                maccroatian: {
                    type: "_sbcs",
                    chars: ""
                },
                maccyrillic: {
                    type: "_sbcs",
                    chars: ""
                },
                macgreek: {
                    type: "_sbcs",
                    chars: ""
                },
                maciceland: {
                    type: "_sbcs",
                    chars: ""
                },
                macroman: {
                    type: "_sbcs",
                    chars: ""
                },
                macromania: {
                    type: "_sbcs",
                    chars: ""
                },
                macthai: {
                    type: "_sbcs",
                    chars: "\ufeff"
                },
                macturkish: {
                    type: "_sbcs",
                    chars: ""
                },
                macukraine: {
                    type: "_sbcs",
                    chars: ""
                },
                koi8r: {
                    type: "_sbcs",
                    chars: ""
                },
                koi8u: {
                    type: "_sbcs",
                    chars: ""
                },
                koi8ru: {
                    type: "_sbcs",
                    chars: ""
                },
                koi8t: {
                    type: "_sbcs",
                    chars: ""
                },
                armscii8: {
                    type: "_sbcs",
                    chars: ")(.,-"
                },
                rk1048: {
                    type: "_sbcs",
                    chars: ""
                },
                tcvn: {
                    type: "_sbcs",
                    chars: "\0\b\t\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
                },
                georgianacademy: {
                    type: "_sbcs",
                    chars: ""
                },
                georgianps: {
                    type: "_sbcs",
                    chars: ""
                },
                pt154: {
                    type: "_sbcs",
                    chars: ""
                },
                viscii: {
                    type: "_sbcs",
                    chars: "\0\b\t\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
                },
                iso646cn: {
                    type: "_sbcs",
                    chars: "\0\b\t\n\v\f\r !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
                },
                iso646jp: {
                    type: "_sbcs",
                    chars: "\0\b\t\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
                },
                hproman8: {
                    type: "_sbcs",
                    chars: ""
                },
                macintosh: {
                    type: "_sbcs",
                    chars: ""
                },
                ascii: {
                    type: "_sbcs",
                    chars: ""
                },
                tis620: {
                    type: "_sbcs",
                    chars: ""
                }
            }
        }, {} ],
        14: [ function( require, module, exports ) {
            "use strict";
            module.exports = {
                10029: "maccenteuro",
                maccenteuro: {
                    type: "_sbcs",
                    chars: ""
                },
                808: "cp808",
                ibm808: "cp808",
                cp808: {
                    type: "_sbcs",
                    chars: ""
                },
                ascii8bit: "ascii",
                usascii: "ascii",
                ansix34: "ascii",
                ansix341968: "ascii",
                ansix341986: "ascii",
                csascii: "ascii",
                cp367: "ascii",
                ibm367: "ascii",
                isoir6: "ascii",
                iso646us: "ascii",
                iso646irv: "ascii",
                us: "ascii",
                latin1: "iso88591",
                latin2: "iso88592",
                latin3: "iso88593",
                latin4: "iso88594",
                latin5: "iso88599",
                latin6: "iso885910",
                latin7: "iso885913",
                latin8: "iso885914",
                latin9: "iso885915",
                latin10: "iso885916",
                csisolatin1: "iso88591",
                csisolatin2: "iso88592",
                csisolatin3: "iso88593",
                csisolatin4: "iso88594",
                csisolatincyrillic: "iso88595",
                csisolatinarabic: "iso88596",
                csisolatingreek: "iso88597",
                csisolatinhebrew: "iso88598",
                csisolatin5: "iso88599",
                csisolatin6: "iso885910",
                l1: "iso88591",
                l2: "iso88592",
                l3: "iso88593",
                l4: "iso88594",
                l5: "iso88599",
                l6: "iso885910",
                l7: "iso885913",
                l8: "iso885914",
                l9: "iso885915",
                l10: "iso885916",
                isoir14: "iso646jp",
                isoir57: "iso646cn",
                isoir100: "iso88591",
                isoir101: "iso88592",
                isoir109: "iso88593",
                isoir110: "iso88594",
                isoir144: "iso88595",
                isoir127: "iso88596",
                isoir126: "iso88597",
                isoir138: "iso88598",
                isoir148: "iso88599",
                isoir157: "iso885910",
                isoir166: "tis620",
                isoir179: "iso885913",
                isoir199: "iso885914",
                isoir203: "iso885915",
                isoir226: "iso885916",
                cp819: "iso88591",
                ibm819: "iso88591",
                cyrillic: "iso88595",
                arabic: "iso88596",
                arabic8: "iso88596",
                ecma114: "iso88596",
                asmo708: "iso88596",
                greek: "iso88597",
                greek8: "iso88597",
                ecma118: "iso88597",
                elot928: "iso88597",
                hebrew: "iso88598",
                hebrew8: "iso88598",
                turkish: "iso88599",
                turkish8: "iso88599",
                thai: "iso885911",
                thai8: "iso885911",
                celtic: "iso885914",
                celtic8: "iso885914",
                isoceltic: "iso885914",
                tis6200: "tis620",
                tis62025291: "tis620",
                tis62025330: "tis620",
                10000: "macroman",
                10006: "macgreek",
                10007: "maccyrillic",
                10079: "maciceland",
                10081: "macturkish",
                cspc8codepage437: "cp437",
                cspc775baltic: "cp775",
                cspc850multilingual: "cp850",
                cspcp852: "cp852",
                cspc862latinhebrew: "cp862",
                cpgr: "cp869",
                msee: "cp1250",
                mscyrl: "cp1251",
                msansi: "cp1252",
                msgreek: "cp1253",
                msturk: "cp1254",
                mshebr: "cp1255",
                msarab: "cp1256",
                winbaltrim: "cp1257",
                cp20866: "koi8r",
                20866: "koi8r",
                ibm878: "koi8r",
                cskoi8r: "koi8r",
                cp21866: "koi8u",
                21866: "koi8u",
                ibm1168: "koi8u",
                strk10482002: "rk1048",
                tcvn5712: "tcvn",
                tcvn57121: "tcvn",
                gb198880: "iso646cn",
                cn: "iso646cn",
                csiso14jisc6220ro: "iso646jp",
                jisc62201969ro: "iso646jp",
                jp: "iso646jp",
                cshproman8: "hproman8",
                r8: "hproman8",
                roman8: "hproman8",
                xroman8: "hproman8",
                ibm1051: "hproman8",
                mac: "macintosh",
                csmacintosh: "macintosh"
            }
        }, {} ],
        15: [ function( require, module, exports ) {
            module.exports = [ [ "8740", "" ], [ "8767", "" ], [ "87a1", "" ], [ "8840", "", 4, "" ], [ "88a1", "" ], [ "8940", "" ], [ "8943", "" ], [ "8946", "" ], [ "894c", "" ], [ "89a1", "" ], [ "89ab", "" ], [ "89b0", "" ], [ "89b5", "" ], [ "89c1", "" ], [ "89c5", "" ], [ "8a40", "" ], [ "8a43", "" ], [ "8a64", "" ], [ "8a76", "" ], [ "8aa1", "" ], [ "8aac", "" ], [ "8ab2", "" ], [ "8abb", "" ], [ "8ac9", "" ], [ "8ace", "" ], [ "8adf", "" ], [ "8af6", "" ], [ "8b40", "" ], [ "8b55", "" ], [ "8ba1", "" ], [ "8bde", "" ], [ "8c40", "" ], [ "8ca1", "" ], [ "8ca7", "" ], [ "8cc9", "" ], [ "8cce", "" ], [ "8ce6", "" ], [ "8d40", "" ], [ "8d42", "" ], [ "8da1", "" ], [ "8e40", "" ], [ "8ea1", "" ], [ "8f40", "" ], [ "8fa1", "" ], [ "9040", "" ], [ "90a1", "" ], [ "9140", "" ], [ "91a1", "" ], [ "9240", "" ], [ "92a1", "" ], [ "9340", "" ], [ "93a1", "" ], [ "9440", "" ], [ "94a1", "" ], [ "9540", "" ], [ "95a1", "" ], [ "9640", "" ], [ "96a1", "" ], [ "9740", "" ], [ "97a1", "" ], [ "9840", "" ], [ "98a1", "" ], [ "9940", "" ], [ "99a1", "" ], [ "9a40", "" ], [ "9aa1", "" ], [ "9b40", "" ], [ "9b62", "" ], [ "9ba1", "" ], [ "9c40", "" ], [ "9ca1", "" ], [ "9d40", "" ], [ "9da1", "" ], [ "9e40", "" ], [ "9ea1", "" ], [ "9ead", "" ], [ "9ec5", "" ], [ "9ef5", "" ], [ "9f40", "" ], [ "9f4f", "" ], [ "9fa1", "" ], [ "9fae", "" ], [ "9fb2", "" ], [ "9fc1", "" ], [ "9fc9", "" ], [ "9fdb", "" ], [ "9fe7", "" ], [ "9feb", "" ], [ "9ff0", "" ], [ "a040", "" ], [ "a055", "" ], [ "a058", "" ], [ "a05b", "" ], [ "a063", "" ], [ "a073", "" ], [ "a0a1", "" ], [ "a0a6", "" ], [ "a0ae", "" ], [ "a0b0", "" ], [ "a0d4", "" ], [ "a0e2", "" ], [ "a3c0", "", 31, "" ], [ "c6a1", "", 9, "", 9, "", 9, "", 23 ], [ "c740", "", 58, "" ], [ "c7a1", "", 81, "", 5, "", 4 ], [ "c840", "", 26, "", 25, "" ], [ "c8a1", "" ], [ "c8cd", "" ], [ "c8f5", "" ], [ "f9fe", "" ], [ "fa40", "" ], [ "faa1", "" ], [ "fb40", "" ], [ "fba1", "" ], [ "fc40", "" ], [ "fca1", "" ], [ "fd40", "" ], [ "fda1", "" ], [ "fe40", "" ], [ "fea1", "" ] ]
        }, {} ],
        16: [ function( require, module, exports ) {
            module.exports = [ [ "0", "\0", 127, "" ], [ "8140", "", 5, "", 9, "", 6, "" ], [ "8180", "", 6, "", 4, "", 4, "", 5, "" ], [ "8240", "", 4, "", 8, "", 4, "", 11 ], [ "8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, "" ], [ "8340", "", 17, "", 5, "", 10, "", 4, "", 9, "" ], [ "8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5 ], [ "8440", "", 5, "", 5, "" ], [ "8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, "" ], [ "8540", "", 9, "" ], [ "8580", "", 4, "", 6, "", 4, "", 4, "", 7, "" ], [ "8640", "", 4, "", 5, "", 4, "", 5, "" ], [ "8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, "" ], [ "8740", "", 7, "", 11, "", 4, "", 4 ], [ "8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6 ], [ "8840", "", 9, "", 4, "", 4, "" ], [ "8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7 ], [ "8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, "" ], [ "8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, "" ], [ "8a40", "", 4, "", 12, "" ], [ "8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5 ], [ "8b40", "", 8, "", 17, "", 6, "", 13, "" ], [ "8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6 ], [ "8c40", "", 7, "" ], [ "8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4 ], [ "8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4 ], [ "8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, "" ], [ "8e40", "", 21, "", 12, "", 6, "", 12, "" ], [ "8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6 ], [ "8f40", "", 5, "", 11, "", 8, "" ], [ "8f80", "", 6, "", 14, "", 5, "", 5, "", 4, "" ], [ "9040", "", 4, "", 4, "", 6, "" ], [ "9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6 ], [ "9140", "", 6, "", 6, "", 18, "", 4, "" ], [ "9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, "" ], [ "9240", "", 6, "", 5, "" ], [ "9280", "", 5, "", 7, "", 6, "" ], [ "9340", "", 6, "", 4, "", 4, "", 5, "" ], [ "9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, "" ], [ "9440", "", 24, "", 7, "", 7, "", 4, "", 8 ], [ "9480", "", 4, "", 4, "", 14, "", 7, "", 7, "" ], [ "9540", "", 4, "", 4, "", 6, "" ], [ "9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, "" ], [ "9640", "", 5, "", 4, "" ], [ "9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5 ], [ "9740", "", 7, "", 8, "", 7, "", 9, "" ], [ "9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, "" ], [ "9840", "", 4, "", 5, "", 9, "" ], [ "9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, "" ], [ "9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5 ], [ "9980", "", 114, "", 6 ], [ "9a40", "", 11, "", 7, "", 13, "" ], [ "9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, "" ], [ "9b40", "", 4, "" ], [ "9b80", "", 5, "", 4, "", 4, "", 5, "" ], [ "9c40", "", 7, "" ], [ "9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5 ], [ "9d40", "", 7, "", 4, "", 9, "", 6, "" ], [ "9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, "" ], [ "9e40", "", 7, "", 32, "", 7, "", 6, "", 6 ], [ "9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, "" ], [ "9f40", "", 6, "", 10, "", 4, "", 10, "", 7, "" ], [ "9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4 ], [ "a040", "", 9, "", 5, "", 9, "", 11, "", 19 ], [ "a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, "" ], [ "a1a1", "", 7, "" ], [ "a2a1", "", 9 ], [ "a2b1", "", 19, "", 19, "", 9 ], [ "a2e5", "", 9 ], [ "a2f1", "", 11 ], [ "a3a1", "", 88, "" ], [ "a4a1", "", 82 ], [ "a5a1", "", 85 ], [ "a6a1", "", 16, "", 6 ], [ "a6c1", "", 16, "", 6 ], [ "a6e0", "" ], [ "a6ee", "" ], [ "a6f4", "" ], [ "a7a1", "", 5, "", 25 ], [ "a7d1", "", 5, "", 25 ], [ "a840", "", 35, "", 6 ], [ "a880", "", 7, "" ], [ "a8a1", "" ], [ "a8bd", "" ], [ "a8c0", "" ], [ "a8c5", "", 36 ], [ "a940", "", 8, "" ], [ "a959", "" ], [ "a95c", "" ], [ "a960", "", 9, "", 8 ], [ "a980", "", 4, "" ], [ "a996", "" ], [ "a9a4", "", 75 ], [ "aa40", "", 5, "", 5, "", 8 ], [ "aa80", "", 7, "", 10, "" ], [ "ab40", "", 11, "", 4, "", 5, "", 4 ], [ "ab80", "", 6, "", 4 ], [ "ac40", "", 10, "", 8, "", 5, "", 4, "", 11 ], [ "ac80", "", 6, "", 12, "", 4, "" ], [ "ad40", "", 10, "", 7, "", 15, "", 12 ], [ "ad80", "", 9, "", 8, "", 6, "" ], [ "ae40", "", 6, "", 7, "", 4, "" ], [ "ae80", "", 7, "", 6, "", 4, "" ], [ "af40", "", 4, "" ], [ "af80", "" ], [ "b040", "", 6, "", 5, "", 4, "", 6, "", 7, "" ], [ "b080", "", 7, "", 8, "", 9, "" ], [ "b140", "", 4, "", 7, "", 10, "" ], [ "b180", "", 4, "", 7, "", 7, "" ], [ "b240", "", 11, "", 5, "", 11, "", 4 ], [ "b280", "", 12, "", 8, "", 4, "" ], [ "b340", "", 5, "" ], [ "b380", "", 11, "", 7, "", 6, "" ], [ "b440", "", 7, "", 9 ], [ "b480", "", 4, "", 5, "", 6, "" ], [ "b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, "" ], [ "b580", "", 6, "", 4, "" ], [ "b640", "", 6, "", 11, "", 10, "", 4, "", 5, "" ], [ "b680", "", 6, "", 4, "" ], [ "b740", "", 14, "", 5, "", 9, "", 4, "", 16 ], [ "b780", "", 6, "" ], [ "b840", "", 4, "", 10, "", 10, "", 9, "", 5, "" ], [ "b880", "", 4, "" ], [ "b940", "", 5, "", 10, "", 6, "" ], [ "b980", "", 7, "" ], [ "ba40", "", 4, "", 4, "", 7, "", 5, "" ], [ "ba80", "", 4, "", 5, "", 12, "", 5, "" ], [ "bb40", "", 9, "", 36, "", 5, "", 9 ], [ "bb80", "", 6, "", 4, "" ], [ "bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5 ], [ "bc80", "", 14, "", 6, "" ], [ "bd40", "", 54, "", 7 ], [ "bd80", "", 32, "" ], [ "be40", "", 12, "", 6, "", 42 ], [ "be80", "", 32, "" ], [ "bf40", "", 62 ], [ "bf80", "", 4, "", 4, "", 21, "" ], [ "c040", "", 35, "", 23, "" ], [ "c080", "", 6, "", 9, "" ], [ "c140", "", 4, "", 7, "", 4, "", 4, "", 6, "" ], [ "c180", "", 4, "", 4, "", 5, "" ], [ "c240", "", 6, "", 5, "" ], [ "c280", "", 13, "", 5, "", 11, "" ], [ "c340", "", 5, "", 4, "", 6, "" ], [ "c380", "", 12, "", 4, "" ], [ "c440", "", 5, "", 4, "", 4, "", 5, "", 4, "" ], [ "c480", "", 7, "", 5, "", 6, "" ], [ "c540", "", 14, "", 4, "", 5, "", 4, "", 5, "" ], [ "c580", "", 7, "", 7, "" ], [ "c640", "" ], [ "c680", "", 4, "", 9, "" ], [ "c740", "", 4, "", 4, "", 6, "", 6, "", 6, "" ], [ "c780", "" ], [ "c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, "" ], [ "c880", "", 6, "", 4, "", 4, "" ], [ "c940", "", 4, "", 7, "", 12, "" ], [ "c980", "", 4, "", 4, "", 10, "" ], [ "ca40", "", 8, "", 8, "", 9, "", 4, "", 10 ], [ "ca80", "", 4, "", 8, "" ], [ "cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, "" ], [ "cb80", "", 5, "", 6, "", 14, "" ], [ "cc40", "", 4, "", 10, "", 15, "", 13, "" ], [ "cc80", "", 11, "", 4, "", 7, "" ], [ "cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, "" ], [ "cd80", "" ], [ "ce40", "", 6, "", 5, "", 7, "" ], [ "ce80", "", 4, "", 6, "", 4, "" ], [ "cf40", "", 4, "", 4, "", 6, "", 9 ], [ "cf80", "", 5, "", 7, "", 4, "" ], [ "d040", "", 13, "", 5, "", 5, "", 5, "", 6, "" ], [ "d080", "", 4, "", 4, "", 5, "" ], [ "d140", "", 4, "", 4, "", 6, "", 5 ], [ "d180", "", 4, "", 4, "", 4, "" ], [ "d240", "", 8, "", 24, "", 5, "", 19, "" ], [ "d280", "", 26, "" ], [ "d340", "", 30, "", 6 ], [ "d380", "", 4, "", 5, "", 21, "" ], [ "d440", "", 31, "", 8, "", 21 ], [ "d480", "", 25, "", 6, "" ], [ "d540", "", 7, "", 7, "", 46 ], [ "d580", "", 32, "" ], [ "d640", "", 34, "", 27 ], [ "d680", "", 30, "" ], [ "d740", "", 31, "", 4, "", 25 ], [ "d780", "", 24, "" ], [ "d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, "" ], [ "d880", "", 6, "", 20, "" ], [ "d940", "", 62 ], [ "d980", "", 32, "" ], [ "da40", "", 14, "", 8, "", 4, "", 9, "" ], [ "da80", "", 12, "" ], [ "db40", "", 6, "", 7, "", 4, "" ], [ "db80", "", 4, "", 5, "", 11, "" ], [ "dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7 ], [ "dc80", "", 10, "", 21, "" ], [ "dd40", "", 62 ], [ "dd80", "", 32, "" ], [ "de40", "", 32, "" ], [ "de80", "", 4, "" ], [ "df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, "" ], [ "df80", "", 4, "" ], [ "e040", "", 19, "" ], [ "e080", "", 10, "", 6, "", 8, "" ], [ "e140", "", 4, "", 6, "", 5, "", 5, "" ], [ "e180", "", 10, "", 9, "", 8, "" ], [ "e240", "", 62 ], [ "e280", "", 32, "", 5, "" ], [ "e340", "", 45, "", 16 ], [ "e380", "", 7, "", 24, "" ], [ "e440", "", 5, "", 24, "", 31 ], [ "e480", "", 32, "" ], [ "e540", "", 51, "", 10 ], [ "e580", "", 31, "" ], [ "e640", "", 34, "", 27 ], [ "e680", "", 29, "" ], [ "e740", "", 7, "", 54 ], [ "e780", "", 32, "", 6, "", 4, "" ], [ "e840", "", 14, "", 43, "" ], [ "e880", "", 20, "" ], [ "e940", "", 7, "", 42 ], [ "e980", "", 32, "" ], [ "ea40", "", 27, "", 6, "" ], [ "ea80", "", 4, "", 12, "" ], [ "eb40", "", 9, "", 7, "", 9, "", 6, "" ], [ "eb80", "", 4, "" ], [ "ec40", "", 8, "", 4, "", 18, "", 7 ], [ "ec80", "", 4, "", 7, "", 4, "", 4, "" ], [ "ed40", "", 6, "", 46 ], [ "ed80", "", 4, "", 23, "" ], [ "ee40", "", 62 ], [ "ee80", "", 32, "", 4, "", 6, "" ], [ "ef40", "", 5, "", 37, "", 4 ], [ "ef80", "", 30, "", 4, "", 8, "" ], [ "f040", "", 4, "", 28, "", 26 ], [ "f080", "", 9, "", 12, "", 4, "", 6, "" ], [ "f140", "", 10, "", 47 ], [ "f180", "", 32, "" ], [ "f240", "", 62 ], [ "f280", "", 32, "" ], [ "f340", "", 17, "", 6, "", 4, "" ], [ "f380", "", 8, "", 6, "" ], [ "f440", "", 5, "", 10, "", 10, "", 7, "", 5 ], [ "f480", "", 32, "" ], [ "f540", "", 62 ], [ "f580", "", 32, "" ], [ "f640", "", 62 ], [ "f680", "", 32, "", 5, "", 5, "", 4, "", 7, "" ], [ "f740", "", 62 ], [ "f780", "", 4, "", 4, "" ], [ "f840", "", 62 ], [ "f880", "", 32 ], [ "f940", "", 62 ], [ "f980", "", 32 ], [ "fa40", "", 62 ], [ "fa80", "", 32 ], [ "fb40", "", 27, "", 9, "" ], [ "fb80", "", 5, "", 8, "", 5, "" ], [ "fc40", "", 8, "", 4, "", 8, "", 6 ], [ "fc80", "", 4, "", 5, "", 8, "" ], [ "fd40", "", 4, "", 4, "", 10, "", 38 ], [ "fd80", "", 5, "", 11, "", 4, "" ], [ "fe40", "" ] ]
        }, {} ],
        17: [ function( require, module, exports ) {
            module.exports = [ [ "0", "\0", 127 ], [ "8141", "", 4, "", 6, "" ], [ "8161", "", 9, "", 5, "" ], [ "8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, "" ], [ "8241", "", 7, "", 5 ], [ "8261", "", 6, "", 5, "" ], [ "8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18 ], [ "8341", "", 5, "", 5, "", 7 ], [ "8361", "", 18, "" ], [ "8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8 ], [ "8441", "", 5, "", 8 ], [ "8461", "", 18 ], [ "8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, "" ], [ "8541", "", 5, "", 4, "", 6, "", 4 ], [ "8561", "", 5, "", 5, "", 6, "" ], [ "8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, "" ], [ "8641", "", 6, "", 5, "" ], [ "8661", "", 6, "", 10 ], [ "8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, "" ], [ "8741", "", 9, "", 15 ], [ "8761", "", 18, "" ], [ "8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4 ], [ "8841", "", 4, "", 5, "", 6, "", 4 ], [ "8861", "", 4, "" ], [ "8881", "", 15, "", 4, "", 6, "", 5, "", 54, "" ], [ "8941", "", 6, "", 5, "" ], [ "8961", "", 10, "", 5, "" ], [ "8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15 ], [ "8a41", "", 10, "", 6, "" ], [ "8a61", "", 4, "", 18, "" ], [ "8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, "" ], [ "8b41", "", 5, "", 4, "", 6, "" ], [ "8b61", "", 6, "", 8 ], [ "8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18 ], [ "8c41", "", 15, "", 4 ], [ "8c61", "", 6, "", 5, "", 6, "", 5 ], [ "8c81", "", 12, "", 26, "", 50, "", 5, "", 16 ], [ "8d41", "", 16, "", 8 ], [ "8d61", "", 17, "" ], [ "8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, "" ], [ "8e41", "", 6, "", 5, "", 8 ], [ "8e61", "", 4, "", 19 ], [ "8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7 ], [ "8f41", "", 7, "", 17 ], [ "8f61", "", 7, "", 6, "", 4 ], [ "8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5 ], [ "9041", "", 6, "", 5, "" ], [ "9061", "", 5, "", 15 ], [ "9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, "" ], [ "9141", "", 6, "", 5 ], [ "9161", "", 9, "", 5 ], [ "9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6 ], [ "9241", "", 7, "", 4, "" ], [ "9261", "", 7, "", 7, "", 4 ], [ "9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, "" ], [ "9341", "", 4, "" ], [ "9361", "", 6, "", 8 ], [ "9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, "" ], [ "9441", "", 5, "", 5, "", 8 ], [ "9461", "", 5, "", 6, "", 12 ], [ "9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24 ], [ "9541", "", 11, "", 5, "" ], [ "9561", "", 6, "", 5, "" ], [ "9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14 ], [ "9641", "", 23, "" ], [ "9661", "", 6, "", 5, "", 8 ], [ "9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44 ], [ "9741", "", 16, "", 8 ], [ "9761", "", 17, "", 7 ], [ "9781", "", 11, "", 5, "", 6, "", 89, "" ], [ "9841", "", 16, "", 5, "" ], [ "9861", "", 6, "", 15 ], [ "9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, "" ], [ "9941", "", 6, "", 5, "" ], [ "9961", "", 6, "", 5, "" ], [ "9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, "" ], [ "9a41", "", 16 ], [ "9a61", "", 6, "", 6, "" ], [ "9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, "" ], [ "9b41", "", 6, "", 8 ], [ "9b61", "", 17, "", 7 ], [ "9b81", "", 25, "", 4, "", 5, "", 50, "", 22, "" ], [ "9c41", "", 4, "", 5, "", 5 ], [ "9c61", "", 8, "", 6, "", 9 ], [ "9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12 ], [ "9d41", "", 13, "", 8 ], [ "9d61", "", 25 ], [ "9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, "" ], [ "9e41", "", 7, "", 9, "" ], [ "9e61", "", 4, "", 6, "" ], [ "9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, "" ], [ "9f41", "", 5, "", 4, "", 5, "" ], [ "9f61", "", 6, "", 5, "" ], [ "9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, "" ], [ "a041", "", 5, "", 6, "" ], [ "a061", "", 5, "", 13 ], [ "a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, "" ], [ "a141", "", 18, "" ], [ "a161", "", 6, "", 5, "" ], [ "a181", "", 14, "", 5, "", 4, "", 9, "" ], [ "a241", "", 5, "", 18 ], [ "a261", "", 6, "", 18 ], [ "a281", "", 7, "", 6, "", 7, "" ], [ "a341", "", 6, "", 10, "" ], [ "a361", "", 6, "", 16 ], [ "a381", "", 16, "", 4, "", 58, "", 32, "" ], [ "a441", "", 5, "" ], [ "a461", "", 5, "", 12 ], [ "a481", "", 28, "", 93 ], [ "a541", "", 4, "", 6, "", 5, "" ], [ "a561", "", 17, "", 5, "" ], [ "a581", "", 16, "", 14, "", 9 ], [ "a5b0", "", 9 ], [ "a5c1", "", 16, "", 6 ], [ "a5e1", "", 16, "", 6 ], [ "a641", "", 19, "" ], [ "a661", "", 5, "", 5, "", 6 ], [ "a681", "", 6, "", 18, "", 7 ], [ "a741", "", 4, "", 6, "", 7 ], [ "a761", "", 22, "" ], [ "a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, "" ], [ "a841", "", 10, "", 14 ], [ "a861", "", 18, "", 6 ], [ "a881", "", 19, "", 11, "" ], [ "a8a6", "" ], [ "a8a8", "" ], [ "a8b1", "", 27, "", 25, "", 14, "" ], [ "a941", "", 14, "", 10 ], [ "a961", "", 18 ], [ "a981", "", 14, "", 6, "", 27, "", 25, "", 14, "" ], [ "aa41", "", 6, "", 4, "" ], [ "aa61", "", 4, "", 5, "", 6, "" ], [ "aa81", "", 29, "", 82 ], [ "ab41", "", 6, "", 5, "" ], [ "ab61", "", 6, "", 5, "", 5 ], [ "ab81", "", 8, "", 6, "", 12, "", 85 ], [ "ac41", "", 5, "", 6, "" ], [ "ac61", "", 11, "", 4 ], [ "ac81", "", 28, "", 5, "", 25 ], [ "acd1", "", 5, "", 25 ], [ "ad41", "", 6, "", 5, "", 7 ], [ "ad61", "", 6, "", 10, "" ], [ "ad81", "", 5, "", 18, "" ], [ "ae41", "", 5, "", 16 ], [ "ae61", "", 5, "", 6, "", 4 ], [ "ae81", "", 6, "", 5, "" ], [ "af41", "", 19 ], [ "af61", "", 13, "", 5, "" ], [ "af81", "", 5, "", 6, "", 5, "" ], [ "b041", "", 5, "", 5, "", 12 ], [ "b061", "", 5, "", 19 ], [ "b081", "", 13, "", 6, "", 5, "", 7, "", 4, "" ], [ "b141", "", 6, "", 5, "" ], [ "b161", "", 6, "", 5, "", 11 ], [ "b181", "", 14, "", 6, "" ], [ "b241", "", 6, "", 5, "" ], [ "b261", "", 18, "", 5, "" ], [ "b281", "", 5, "", 18, "", 6, "" ], [ "b341", "", 19, "" ], [ "b361", "", 5, "", 5, "", 5 ], [ "b381", "", 5, "", 5, "", 19, "", 4, "" ], [ "b441", "", 5, "", 6, "", 5 ], [ "b461", "", 6, "", 10, "" ], [ "b481", "", 6, "", 18, "", 4, "", 4, "" ], [ "b541", "", 14, "", 5 ], [ "b561", "", 5, "", 5, "", 4 ], [ "b581", "", 6, "", 5, "", 11, "" ], [ "b641", "", 7, "", 17 ], [ "b661", "", 15, "" ], [ "b681", "", 5, "", 6, "", 5, "" ], [ "b741", "", 13, "", 6, "" ], [ "b761", "", 20, "" ], [ "b781", "", 6, "", 14, "" ], [ "b841", "", 7, "", 17 ], [ "b861", "", 8, "", 13 ], [ "b881", "", 5, "", 24, "", 4, "" ], [ "b941", "", 6, "", 5, "" ], [ "b961", "", 14, "", 6, "" ], [ "b981", "", 22, "", 4, "", 4, "" ], [ "ba41", "", 5, "", 6, "" ], [ "ba61", "", 5, "", 4, "", 5 ], [ "ba81", "", 6, "", 9, "" ], [ "bb41", "", 4, "", 5, "", 4, "" ], [ "bb61", "", 6, "", 5, "" ], [ "bb81", "", 31, "" ], [ "bc41", "", 17, "" ], [ "bc61", "", 5, "", 6, "" ], [ "bc81", "", 4, "", 6, "", 5, "", 5, "", 4, "" ], [ "bd41", "", 7, "", 7, "" ], [ "bd61", "", 5, "", 13 ], [ "bd81", "", 5, "", 25, "" ], [ "be41", "", 7, "", 14 ], [ "be61", "", 7, "", 7, "" ], [ "be81", "", 4, "", 4, "", 5, "", 8, "", 6, "" ], [ "bf41", "", 10, "", 14 ], [ "bf61", "", 18, "" ], [ "bf81", "", 5, "", 7, "", 6, "", 5, "" ], [ "c041", "", 5, "", 6, "", 5 ], [ "c061", "", 25 ], [ "c081", "", 6, "", 5, "", 7, "" ], [ "c141", "", 5, "", 6, "" ], [ "c161", "", 19, "" ], [ "c181", "", 31, "" ], [ "c241", "", 4, "", 5, "" ], [ "c261", "", 4, "", 5, "", 6, "" ], [ "c281", "", 5, "", 7, "", 9, "" ], [ "c341", "", 4 ], [ "c361", "", 4, "", 5, "", 11 ], [ "c381", "", 5, "", 7, "", 5, "" ], [ "c441", "", 7, "", 7, "" ], [ "c461", "", 5, "", 4 ], [ "c481", "", 5, "", 11, "" ], [ "c541", "", 6, "", 5, "" ], [ "c561", "", 6, "", 5, "", 4 ], [ "c581", "", 6, "", 5, "" ], [ "c641", "", 6, "", 5 ], [ "c6a1", "" ], [ "c7a1", "" ], [ "c8a1", "" ], [ "caa1", "" ], [ "cba1", "" ], [ "cca1", "" ], [ "cda1", "" ], [ "cea1", "" ], [ "cfa1", "" ], [ "d0a1", "" ], [ "d1a1", "", 5, "", 4, "" ], [ "d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, "" ], [ "d3a1", "" ], [ "d4a1", "" ], [ "d5a1", "" ], [ "d6a1", "" ], [ "d7a1", "" ], [ "d8a1", "" ], [ "d9a1", "" ], [ "daa1", "" ], [ "dba1", "" ], [ "dca1", "" ], [ "dda1", "" ], [ "dea1", "" ], [ "dfa1", "" ], [ "e0a1", "" ], [ "e1a1", "" ], [ "e2a1", "" ], [ "e3a1", "" ], [ "e4a1", "" ], [ "e5a1", "" ], [ "e6a1", "" ], [ "e7a1", "" ], [ "e8a1", "" ], [ "e9a1", "" ], [ "eaa1", "" ], [ "eba1", "" ], [ "eca1", "" ], [ "eda1", "" ], [ "eea1", "" ], [ "efa1", "" ], [ "f0a1", "" ], [ "f1a1", "" ], [ "f2a1", "" ], [ "f3a1", "" ], [ "f4a1", "" ], [ "f5a1", "" ], [ "f6a1", "" ], [ "f7a1", "" ], [ "f8a1", "" ], [ "f9a1", "" ], [ "faa1", "" ], [ "fba1", "" ], [ "fca1", "" ], [ "fda1", "" ] ]
        }, {} ],
        18: [ function( require, module, exports ) {
            module.exports = [ [ "0", "\0", 127 ], [ "a140", "" ], [ "a1a1", "", 4, "" ], [ "a240", "", 7, "" ], [ "a2a1", "", 9, "", 9, "", 8, "", 25, "", 21 ], [ "a340", "", 16, "", 6, "", 16, "", 6, "", 10 ], [ "a3a1", "", 25, "" ], [ "a3e1", "" ], [ "a440", "" ], [ "a4a1", "" ], [ "a540", "" ], [ "a5a1", "" ], [ "a640", "" ], [ "a6a1", "" ], [ "a740", "" ], [ "a7a1", "" ], [ "a840", "" ], [ "a8a1", "" ], [ "a940", "" ], [ "a9a1", "" ], [ "aa40", "" ], [ "aaa1", "" ], [ "ab40", "" ], [ "aba1", "" ], [ "ac40", "" ], [ "aca1", "" ], [ "ad40", "" ], [ "ada1", "" ], [ "ae40", "" ], [ "aea1", "" ], [ "af40", "" ], [ "afa1", "" ], [ "b040", "" ], [ "b0a1", "" ], [ "b140", "" ], [ "b1a1", "" ], [ "b240", "" ], [ "b2a1", "" ], [ "b340", "" ], [ "b3a1", "" ], [ "b440", "" ], [ "b4a1", "" ], [ "b540", "" ], [ "b5a1", "" ], [ "b640", "" ], [ "b6a1", "" ], [ "b740", "" ], [ "b7a1", "" ], [ "b840", "" ], [ "b8a1", "" ], [ "b940", "" ], [ "b9a1", "" ], [ "ba40", "" ], [ "baa1", "" ], [ "bb40", "" ], [ "bba1", "" ], [ "bc40", "" ], [ "bca1", "" ], [ "bd40", "" ], [ "bda1", "" ], [ "be40", "" ], [ "bea1", "" ], [ "bf40", "" ], [ "bfa1", "" ], [ "c040", "" ], [ "c0a1", "" ], [ "c140", "" ], [ "c1a1", "" ], [ "c240", "" ], [ "c2a1", "" ], [ "c340", "" ], [ "c3a1", "" ], [ "c440", "" ], [ "c4a1", "" ], [ "c540", "" ], [ "c5a1", "" ], [ "c640", "" ], [ "c940", "" ], [ "c9a1", "" ], [ "ca40", "" ], [ "caa1", "" ], [ "cb40", "" ], [ "cba1", "" ], [ "cc40", "" ], [ "cca1", "" ], [ "cd40", "" ], [ "cda1", "" ], [ "ce40", "" ], [ "cea1", "" ], [ "cf40", "" ], [ "cfa1", "" ], [ "d040", "" ], [ "d0a1", "" ], [ "d140", "" ], [ "d1a1", "" ], [ "d240", "" ], [ "d2a1", "" ], [ "d340", "" ], [ "d3a1", "" ], [ "d440", "" ], [ "d4a1", "" ], [ "d540", "" ], [ "d5a1", "" ], [ "d640", "" ], [ "d6a1", "" ], [ "d740", "" ], [ "d7a1", "" ], [ "d840", "" ], [ "d8a1", "" ], [ "d940", "" ], [ "d9a1", "" ], [ "da40", "" ], [ "daa1", "" ], [ "db40", "" ], [ "dba1", "" ], [ "dc40", "" ], [ "dca1", "" ], [ "dd40", "" ], [ "dda1", "" ], [ "de40", "" ], [ "dea1", "" ], [ "df40", "" ], [ "dfa1", "" ], [ "e040", "" ], [ "e0a1", "" ], [ "e140", "" ], [ "e1a1", "" ], [ "e240", "" ], [ "e2a1", "" ], [ "e340", "" ], [ "e3a1", "" ], [ "e440", "" ], [ "e4a1", "" ], [ "e540", "" ], [ "e5a1", "" ], [ "e640", "" ], [ "e6a1", "" ], [ "e740", "" ], [ "e7a1", "" ], [ "e840", "" ], [ "e8a1", "" ], [ "e940", "" ], [ "e9a1", "" ], [ "ea40", "" ], [ "eaa1", "" ], [ "eb40", "" ], [ "eba1", "" ], [ "ec40", "" ], [ "eca1", "" ], [ "ed40", "" ], [ "eda1", "" ], [ "ee40", "" ], [ "eea1", "" ], [ "ef40", "" ], [ "efa1", "" ], [ "f040", "" ], [ "f0a1", "" ], [ "f140", "" ], [ "f1a1", "" ], [ "f240", "" ], [ "f2a1", "" ], [ "f340", "" ], [ "f3a1", "" ], [ "f440", "" ], [ "f4a1", "" ], [ "f540", "" ], [ "f5a1", "" ], [ "f640", "" ], [ "f6a1", "" ], [ "f740", "" ], [ "f7a1", "" ], [ "f840", "" ], [ "f8a1", "" ], [ "f940", "" ], [ "f9a1", "" ] ]
        }, {} ],
        19: [ function( require, module, exports ) {
            module.exports = [ [ "0", "\0", 127 ], [ "8ea1", "", 62 ], [ "a1a1", "", 9, "" ], [ "a2a1", "" ], [ "a2ba", "" ], [ "a2ca", "" ], [ "a2dc", "" ], [ "a2f2", "" ], [ "a2fe", "" ], [ "a3b0", "", 9 ], [ "a3c1", "", 25 ], [ "a3e1", "", 25 ], [ "a4a1", "", 82 ], [ "a5a1", "", 85 ], [ "a6a1", "", 16, "", 6 ], [ "a6c1", "", 16, "", 6 ], [ "a7a1", "", 5, "", 25 ], [ "a7d1", "", 5, "", 25 ], [ "a8a1", "" ], [ "ada1", "", 19, "", 9 ], [ "adc0", "" ], [ "addf", "", 4, "" ], [ "b0a1", "" ], [ "b1a1", "" ], [ "b2a1", "" ], [ "b3a1", "" ], [ "b4a1", "" ], [ "b5a1", "" ], [ "b6a1", "" ], [ "b7a1", "" ], [ "b8a1", "" ], [ "b9a1", "" ], [ "baa1", "" ], [ "bba1", "" ], [ "bca1", "" ], [ "bda1", "" ], [ "bea1", "" ], [ "bfa1", "" ], [ "c0a1", "" ], [ "c1a1", "" ], [ "c2a1", "" ], [ "c3a1", "" ], [ "c4a1", "" ], [ "c5a1", "" ], [ "c6a1", "" ], [ "c7a1", "" ], [ "c8a1", "" ], [ "c9a1", "" ], [ "caa1", "" ], [ "cba1", "" ], [ "cca1", "" ], [ "cda1", "" ], [ "cea1", "" ], [ "cfa1", "" ], [ "d0a1", "" ], [ "d1a1", "" ], [ "d2a1", "" ], [ "d3a1", "" ], [ "d4a1", "" ], [ "d5a1", "" ], [ "d6a1", "" ], [ "d7a1", "" ], [ "d8a1", "" ], [ "d9a1", "" ], [ "daa1", "" ], [ "dba1", "" ], [ "dca1", "" ], [ "dda1", "" ], [ "dea1", "" ], [ "dfa1", "" ], [ "e0a1", "" ], [ "e1a1", "" ], [ "e2a1", "" ], [ "e3a1", "" ], [ "e4a1", "" ], [ "e5a1", "" ], [ "e6a1", "" ], [ "e7a1", "" ], [ "e8a1", "" ], [ "e9a1", "" ], [ "eaa1", "" ], [ "eba1", "" ], [ "eca1", "" ], [ "eda1", "" ], [ "eea1", "" ], [ "efa1", "" ], [ "f0a1", "" ], [ "f1a1", "" ], [ "f2a1", "" ], [ "f3a1", "" ], [ "f4a1", "" ], [ "f9a1", "" ], [ "faa1", "" ], [ "fba1", "" ], [ "fca1", "" ], [ "fcf1", "", 9, "" ], [ "8fa2af", "" ], [ "8fa2c2", "" ], [ "8fa2eb", "" ], [ "8fa6e1", "" ], [ "8fa6e7", "" ], [ "8fa6e9", "" ], [ "8fa6ec", "" ], [ "8fa6f1", "" ], [ "8fa7c2", "", 10, "" ], [ "8fa7f2", "", 10, "" ], [ "8fa9a1", "" ], [ "8fa9a4", "" ], [ "8fa9a6", "" ], [ "8fa9a8", "" ], [ "8fa9ab", "" ], [ "8fa9af", "" ], [ "8fa9c1", "" ], [ "8faaa1", "" ], [ "8faaba", "" ], [ "8faba1", "" ], [ "8fabbd", "" ], [ "8fabc5", "" ], [ "8fb0a1", "" ], [ "8fb1a1", "" ], [ "8fb2a1", "", 4, "" ], [ "8fb3a1", "" ], [ "8fb4a1", "" ], [ "8fb5a1", "" ], [ "8fb6a1", "", 5, "", 4, "" ], [ "8fb7a1", "", 4, "" ], [ "8fb8a1", "" ], [ "8fb9a1", "" ], [ "8fbaa1", "", 4, "" ], [ "8fbba1", "" ], [ "8fbca1", "", 4, "" ], [ "8fbda1", "", 4, "" ], [ "8fbea1", "", 4, "" ], [ "8fbfa1", "" ], [ "8fc0a1", "" ], [ "8fc1a1", "" ], [ "8fc2a1", "" ], [ "8fc3a1", "", 4, "" ], [ "8fc4a1", "" ], [ "8fc5a1", "" ], [ "8fc6a1", "" ], [ "8fc7a1", "" ], [ "8fc8a1", "" ], [ "8fc9a1", "", 4, "", 4, "" ], [ "8fcaa1", "" ], [ "8fcba1", "" ], [ "8fcca1", "", 9, "" ], [ "8fcda1", "", 5, "" ], [ "8fcea1", "", 6, "" ], [ "8fcfa1", "" ], [ "8fd0a1", "" ], [ "8fd1a1", "" ], [ "8fd2a1", "", 5 ], [ "8fd3a1", "" ], [ "8fd4a1", "", 4, "" ], [ "8fd5a1", "" ], [ "8fd6a1", "" ], [ "8fd7a1", "" ], [ "8fd8a1", "" ], [ "8fd9a1", "", 4, "", 6, "" ], [ "8fdaa1", "", 4, "" ], [ "8fdba1", "", 6, "" ], [ "8fdca1", "", 4, "" ], [ "8fdda1", "", 4, "" ], [ "8fdea1", "", 4, "" ], [ "8fdfa1", "" ], [ "8fe0a1", "" ], [ "8fe1a1", "", 4, "" ], [ "8fe2a1", "" ], [ "8fe3a1", "", 5, "", 4, "" ], [ "8fe4a1", "", 4, "" ], [ "8fe5a1", "", 4, "" ], [ "8fe6a1", "" ], [ "8fe7a1", "" ], [ "8fe8a1", "", 4, "" ], [ "8fe9a1", "", 4 ], [ "8feaa1", "", 4, "" ], [ "8feba1", "", 4, "" ], [ "8feca1", "" ], [ "8feda1", "", 4, "", 4, "" ] ]
        }, {} ],
        20: [ function( require, module, exports ) {
            module.exports = {
                uChars: [ 128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536 ],
                gbChars: [ 0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3 ]
            }
        }, {} ],
        21: [ function( require, module, exports ) {
            module.exports = [ [ "a140", "", 62 ], [ "a180", "", 32 ], [ "a240", "", 62 ], [ "a280", "", 32 ], [ "a2ab", "", 5 ], [ "a2e3", "" ], [ "a2ef", "" ], [ "a2fd", "" ], [ "a340", "", 62 ], [ "a380", "", 31, "" ], [ "a440", "", 62 ], [ "a480", "", 32 ], [ "a4f4", "", 10 ], [ "a540", "", 62 ], [ "a580", "", 32 ], [ "a5f7", "", 7 ], [ "a640", "", 62 ], [ "a680", "", 32 ], [ "a6b9", "", 7 ], [ "a6d9", "", 6 ], [ "a6ec", "" ], [ "a6f3", "" ], [ "a6f6", "", 8 ], [ "a740", "", 62 ], [ "a780", "", 32 ], [ "a7c2", "", 14 ], [ "a7f2", "", 12 ], [ "a896", "", 10 ], [ "a8bc", "" ], [ "a8bf", "" ], [ "a8c1", "" ], [ "a8ea", "", 20 ], [ "a958", "" ], [ "a95b", "" ], [ "a95d", "" ], [ "a989", "", 11 ], [ "a997", "", 12 ], [ "a9f0", "", 14 ], [ "aaa1", "", 93 ], [ "aba1", "", 93 ], [ "aca1", "", 93 ], [ "ada1", "", 93 ], [ "aea1", "", 93 ], [ "afa1", "", 93 ], [ "d7fa", "", 4 ], [ "f8a1", "", 93 ], [ "f9a1", "", 93 ], [ "faa1", "", 93 ], [ "fba1", "", 93 ], [ "fca1", "", 93 ], [ "fda1", "", 93 ], [ "fe50", "" ], [ "fe80", "", 6, "", 93 ] ]
        }, {} ],
        22: [ function( require, module, exports ) {
            module.exports = [ [ "0", "\0", 128 ], [ "a1", "", 62 ], [ "8140", "", 9, "" ], [ "8180", "" ], [ "81b8", "" ], [ "81c8", "" ], [ "81da", "" ], [ "81f0", "" ], [ "81fc", "" ], [ "824f", "", 9 ], [ "8260", "", 25 ], [ "8281", "", 25 ], [ "829f", "", 82 ], [ "8340", "", 62 ], [ "8380", "", 22 ], [ "839f", "", 16, "", 6 ], [ "83bf", "", 16, "", 6 ], [ "8440", "", 5, "", 25 ], [ "8470", "", 5, "", 7 ], [ "8480", "", 17 ], [ "849f", "" ], [ "8740", "", 19, "", 9 ], [ "875f", "" ], [ "877e", "" ], [ "8780", "", 4, "" ], [ "889f", "" ], [ "8940", "" ], [ "8980", "" ], [ "8a40", "" ], [ "8a80", "" ], [ "8b40", "" ], [ "8b80", "" ], [ "8c40", "" ], [ "8c80", "" ], [ "8d40", "" ], [ "8d80", "" ], [ "8e40", "" ], [ "8e80", "" ], [ "8f40", "" ], [ "8f80", "" ], [ "9040", "" ], [ "9080", "" ], [ "9140", "" ], [ "9180", "" ], [ "9240", "" ], [ "9280", "" ], [ "9340", "" ], [ "9380", "" ], [ "9440", "" ], [ "9480", "" ], [ "9540", "" ], [ "9580", "" ], [ "9640", "" ], [ "9680", "" ], [ "9740", "" ], [ "9780", "" ], [ "9840", "" ], [ "989f", "" ], [ "9940", "" ], [ "9980", "" ], [ "9a40", "" ], [ "9a80", "" ], [ "9b40", "" ], [ "9b80", "" ], [ "9c40", "" ], [ "9c80", "" ], [ "9d40", "" ], [ "9d80", "" ], [ "9e40", "" ], [ "9e80", "" ], [ "9f40", "" ], [ "9f80", "" ], [ "e040", "" ], [ "e080", "" ], [ "e140", "" ], [ "e180", "" ], [ "e240", "" ], [ "e280", "" ], [ "e340", "" ], [ "e380", "" ], [ "e440", "" ], [ "e480", "" ], [ "e540", "" ], [ "e580", "" ], [ "e640", "" ], [ "e680", "" ], [ "e740", "" ], [ "e780", "" ], [ "e840", "" ], [ "e880", "" ], [ "e940", "" ], [ "e980", "" ], [ "ea40", "" ], [ "ea80", "" ], [ "ed40", "" ], [ "ed80", "" ], [ "ee40", "" ], [ "ee80", "" ], [ "eeef", "", 9, "" ], [ "f040", "", 62 ], [ "f080", "", 124 ], [ "f140", "", 62 ], [ "f180", "", 124 ], [ "f240", "", 62 ], [ "f280", "", 124 ], [ "f340", "", 62 ], [ "f380", "", 124 ], [ "f440", "", 62 ], [ "f480", "", 124 ], [ "f540", "", 62 ], [ "f580", "", 124 ], [ "f640", "", 62 ], [ "f680", "", 124 ], [ "f740", "", 62 ], [ "f780", "", 124 ], [ "f840", "", 62 ], [ "f880", "", 124 ], [ "f940", "" ], [ "fa40", "", 9, "", 9, "" ], [ "fa80", "" ], [ "fb40", "" ], [ "fb80", "" ], [ "fc40", "" ] ]
        }, {} ],
        23: [ function( require, module, exports ) {
            "use strict";
            var Buffer = require( "buffer" ).Buffer;
            exports.utf16be = Utf16BECodec;

            function Utf16BECodec() {}
            Utf16BECodec.prototype.encoder = Utf16BEEncoder;
            Utf16BECodec.prototype.decoder = Utf16BEDecoder;
            Utf16BECodec.prototype.bomAware = true;

            function Utf16BEEncoder() {}
            Utf16BEEncoder.prototype.write = function( str ) {
                var buf = new Buffer( str, "ucs2" );
                for ( var i = 0; i < buf.length; i += 2 ) {
                    var tmp = buf[ i ];
                    buf[ i ] = buf[ i + 1 ];
                    buf[ i + 1 ] = tmp
                }
                return buf
            };
            Utf16BEEncoder.prototype.end = function() {};

            function Utf16BEDecoder() {
                this.overflowByte = -1
            }
            Utf16BEDecoder.prototype.write = function( buf ) {
                if ( buf.length == 0 ) return "";
                var buf2 = new Buffer( buf.length + 1 ),
                    i = 0,
                    j = 0;
                if ( this.overflowByte !== -1 ) {
                    buf2[ 0 ] = buf[ 0 ];
                    buf2[ 1 ] = this.overflowByte;
                    i = 1;
                    j = 2
                }
                for ( ; i < buf.length - 1; i += 2, j += 2 ) {
                    buf2[ j ] = buf[ i + 1 ];
                    buf2[ j + 1 ] = buf[ i ]
                }
                this.overflowByte = i == buf.length - 1 ? buf[ buf.length - 1 ] : -1;
                return buf2.slice( 0, j ).toString( "ucs2" )
            };
            Utf16BEDecoder.prototype.end = function() {};
            exports.utf16 = Utf16Codec;

            function Utf16Codec( codecOptions, iconv ) {
                this.iconv = iconv
            }
            Utf16Codec.prototype.encoder = Utf16Encoder;
            Utf16Codec.prototype.decoder = Utf16Decoder;

            function Utf16Encoder( options, codec ) {
                options = options || {};
                if ( options.addBOM === undefined ) options.addBOM = true;
                this.encoder = codec.iconv.getEncoder( "utf-16le", options )
            }
            Utf16Encoder.prototype.write = function( str ) {
                return this.encoder.write( str )
            };
            Utf16Encoder.prototype.end = function() {
                return this.encoder.end()
            };

            function Utf16Decoder( options, codec ) {
                this.decoder = null;
                this.initialBytes = [];
                this.initialBytesLen = 0;
                this.options = options || {};
                this.iconv = codec.iconv
            }
            Utf16Decoder.prototype.write = function( buf ) {
                if ( !this.decoder ) {
                    this.initialBytes.push( buf );
                    this.initialBytesLen += buf.length;
                    if ( this.initialBytesLen < 16 ) return "";
                    var buf = Buffer.concat( this.initialBytes ),
                        encoding = detectEncoding( buf, this.options.defaultEncoding );
                    this.decoder = this.iconv.getDecoder( encoding, this.options );
                    this.initialBytes.length = this.initialBytesLen = 0
                }
                return this.decoder.write( buf )
            };
            Utf16Decoder.prototype.end = function() {
                if ( !this.decoder ) {
                    var buf = Buffer.concat( this.initialBytes ),
                        encoding = detectEncoding( buf, this.options.defaultEncoding );
                    this.decoder = this.iconv.getDecoder( encoding, this.options );
                    var res = this.decoder.write( buf ),
                        trail = this.decoder.end();
                    return trail ? res + trail : res
                }
                return this.decoder.end()
            };

            function detectEncoding( buf, defaultEncoding ) {
                var enc = defaultEncoding || "utf-16le";
                if ( buf.length >= 2 ) {
                    if ( buf[ 0 ] == 254 && buf[ 1 ] == 255 ) enc = "utf-16be";
                    else if ( buf[ 0 ] == 255 && buf[ 1 ] == 254 ) enc = "utf-16le";
                    else {
                        var asciiCharsLE = 0,
                            asciiCharsBE = 0,
                            _len = Math.min( buf.length - buf.length % 2, 64 );
                        for ( var i = 0; i < _len; i += 2 ) {
                            if ( buf[ i ] === 0 && buf[ i + 1 ] !== 0 ) asciiCharsBE++;
                            if ( buf[ i ] !== 0 && buf[ i + 1 ] === 0 ) asciiCharsLE++
                        }
                        if ( asciiCharsBE > asciiCharsLE ) enc = "utf-16be";
                        else if ( asciiCharsBE < asciiCharsLE ) enc = "utf-16le"
                    }
                }
                return enc
            }
        }, {
            buffer: 4
        } ],
        24: [ function( require, module, exports ) {
            "use strict";
            var Buffer = require( "buffer" ).Buffer;
            exports.utf7 = Utf7Codec;
            exports.unicode11utf7 = "utf7";

            function Utf7Codec( codecOptions, iconv ) {
                this.iconv = iconv
            }
            Utf7Codec.prototype.encoder = Utf7Encoder;
            Utf7Codec.prototype.decoder = Utf7Decoder;
            Utf7Codec.prototype.bomAware = true;
            var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

            function Utf7Encoder( options, codec ) {
                this.iconv = codec.iconv
            }
            Utf7Encoder.prototype.write = function( str ) {
                return new Buffer( str.replace( nonDirectChars, function( chunk ) {
                    return "+" + ( chunk === "+" ? "" : this.iconv.encode( chunk, "utf16-be" ).toString( "base64" ).replace( /=+$/, "" ) ) + "-"
                }.bind( this ) ) )
            };
            Utf7Encoder.prototype.end = function() {};

            function Utf7Decoder( options, codec ) {
                this.iconv = codec.iconv;
                this.inBase64 = false;
                this.base64Accum = ""
            }
            var base64Regex = /[A-Za-z0-9\/+]/;
            var base64Chars = [];
            for ( var i = 0; i < 256; i++ ) base64Chars[ i ] = base64Regex.test( String.fromCharCode( i ) );
            var plusChar = "+".charCodeAt( 0 ),
                minusChar = "-".charCodeAt( 0 ),
                andChar = "&".charCodeAt( 0 );
            Utf7Decoder.prototype.write = function( buf ) {
                var res = "",
                    lastI = 0,
                    inBase64 = this.inBase64,
                    base64Accum = this.base64Accum;
                for ( var i = 0; i < buf.length; i++ ) {
                    if ( !inBase64 ) {
                        if ( buf[ i ] == plusChar ) {
                            res += this.iconv.decode( buf.slice( lastI, i ), "ascii" );
                            lastI = i + 1;
                            inBase64 = true
                        }
                    } else {
                        if ( !base64Chars[ buf[ i ] ] ) {
                            if ( i == lastI && buf[ i ] == minusChar ) {
                                res += "+"
                            } else {
                                var b64str = base64Accum + buf.slice( lastI, i ).toString();
                                res += this.iconv.decode( new Buffer( b64str, "base64" ), "utf16-be" )
                            }
                            if ( buf[ i ] != minusChar ) i--;
                            lastI = i + 1;
                            inBase64 = false;
                            base64Accum = ""
                        }
                    }
                }
                if ( !inBase64 ) {
                    res += this.iconv.decode( buf.slice( lastI ), "ascii" )
                } else {
                    var b64str = base64Accum + buf.slice( lastI ).toString();
                    var canBeDecoded = b64str.length - b64str.length % 8;
                    base64Accum = b64str.slice( canBeDecoded );
                    b64str = b64str.slice( 0, canBeDecoded );
                    res += this.iconv.decode( new Buffer( b64str, "base64" ), "utf16-be" )
                }
                this.inBase64 = inBase64;
                this.base64Accum = base64Accum;
                return res
            };
            Utf7Decoder.prototype.end = function() {
                var res = "";
                if ( this.inBase64 && this.base64Accum.length > 0 ) res = this.iconv.decode( new Buffer( this.base64Accum, "base64" ), "utf16-be" );
                this.inBase64 = false;
                this.base64Accum = "";
                return res
            };
            exports.utf7imap = Utf7IMAPCodec;

            function Utf7IMAPCodec( codecOptions, iconv ) {
                this.iconv = iconv
            }
            Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
            Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
            Utf7IMAPCodec.prototype.bomAware = true;

            function Utf7IMAPEncoder( options, codec ) {
                this.iconv = codec.iconv;
                this.inBase64 = false;
                this.base64Accum = new Buffer( 6 );
                this.base64AccumIdx = 0
            }
            Utf7IMAPEncoder.prototype.write = function( str ) {
                var inBase64 = this.inBase64,
                    base64Accum = this.base64Accum,
                    base64AccumIdx = this.base64AccumIdx,
                    buf = new Buffer( str.length * 5 + 10 ),
                    bufIdx = 0;
                for ( var i = 0; i < str.length; i++ ) {
                    var uChar = str.charCodeAt( i );
                    if ( 32 <= uChar && uChar <= 126 ) {
                        if ( inBase64 ) {
                            if ( base64AccumIdx > 0 ) {
                                bufIdx += buf.write( base64Accum.slice( 0, base64AccumIdx ).toString( "base64" ).replace( /\//g, "," ).replace( /=+$/, "" ), bufIdx );
                                base64AccumIdx = 0
                            }
                            buf[ bufIdx++ ] = minusChar;
                            inBase64 = false
                        }
                        if ( !inBase64 ) {
                            buf[ bufIdx++ ] = uChar;
                            if ( uChar === andChar ) buf[ bufIdx++ ] = minusChar
                        }
                    } else {
                        if ( !inBase64 ) {
                            buf[ bufIdx++ ] = andChar;
                            inBase64 = true
                        }
                        if ( inBase64 ) {
                            base64Accum[ base64AccumIdx++ ] = uChar >> 8;
                            base64Accum[ base64AccumIdx++ ] = uChar & 255;
                            if ( base64AccumIdx == base64Accum.length ) {
                                bufIdx += buf.write( base64Accum.toString( "base64" ).replace( /\//g, "," ), bufIdx );
                                base64AccumIdx = 0
                            }
                        }
                    }
                }
                this.inBase64 = inBase64;
                this.base64AccumIdx = base64AccumIdx;
                return buf.slice( 0, bufIdx )
            };
            Utf7IMAPEncoder.prototype.end = function() {
                var buf = new Buffer( 10 ),
                    bufIdx = 0;
                if ( this.inBase64 ) {
                    if ( this.base64AccumIdx > 0 ) {
                        bufIdx += buf.write( this.base64Accum.slice( 0, this.base64AccumIdx ).toString( "base64" ).replace( /\//g, "," ).replace( /=+$/, "" ), bufIdx );
                        this.base64AccumIdx = 0
                    }
                    buf[ bufIdx++ ] = minusChar;
                    this.inBase64 = false
                }
                return buf.slice( 0, bufIdx )
            };

            function Utf7IMAPDecoder( options, codec ) {
                this.iconv = codec.iconv;
                this.inBase64 = false;
                this.base64Accum = ""
            }
            var base64IMAPChars = base64Chars.slice();
            base64IMAPChars[ ",".charCodeAt( 0 ) ] = true;
            Utf7IMAPDecoder.prototype.write = function( buf ) {
                var res = "",
                    lastI = 0,
                    inBase64 = this.inBase64,
                    base64Accum = this.base64Accum;
                for ( var i = 0; i < buf.length; i++ ) {
                    if ( !inBase64 ) {
                        if ( buf[ i ] == andChar ) {
                            res += this.iconv.decode( buf.slice( lastI, i ), "ascii" );
                            lastI = i + 1;
                            inBase64 = true
                        }
                    } else {
                        if ( !base64IMAPChars[ buf[ i ] ] ) {
                            if ( i == lastI && buf[ i ] == minusChar ) {
                                res += "&"
                            } else {
                                var b64str = base64Accum + buf.slice( lastI, i ).toString().replace( /,/g, "/" );
                                res += this.iconv.decode( new Buffer( b64str, "base64" ), "utf16-be" )
                            }
                            if ( buf[ i ] != minusChar ) i--;
                            lastI = i + 1;
                            inBase64 = false;
                            base64Accum = ""
                        }
                    }
                }
                if ( !inBase64 ) {
                    res += this.iconv.decode( buf.slice( lastI ), "ascii" )
                } else {
                    var b64str = base64Accum + buf.slice( lastI ).toString().replace( /,/g, "/" );
                    var canBeDecoded = b64str.length - b64str.length % 8;
                    base64Accum = b64str.slice( canBeDecoded );
                    b64str = b64str.slice( 0, canBeDecoded );
                    res += this.iconv.decode( new Buffer( b64str, "base64" ), "utf16-be" )
                }
                this.inBase64 = inBase64;
                this.base64Accum = base64Accum;
                return res
            };
            Utf7IMAPDecoder.prototype.end = function() {
                var res = "";
                if ( this.inBase64 && this.base64Accum.length > 0 ) res = this.iconv.decode( new Buffer( this.base64Accum, "base64" ), "utf16-be" );
                this.inBase64 = false;
                this.base64Accum = "";
                return res
            }
        }, {
            buffer: 4
        } ],
        25: [ function( require, module, exports ) {
            "use strict";
            var BOMChar = "\ufeff";
            exports.PrependBOM = PrependBOMWrapper;

            function PrependBOMWrapper( encoder, options ) {
                this.encoder = encoder;
                this.addBOM = true
            }
            PrependBOMWrapper.prototype.write = function( str ) {
                if ( this.addBOM ) {
                    str = BOMChar + str;
                    this.addBOM = false
                }
                return this.encoder.write( str )
            };
            PrependBOMWrapper.prototype.end = function() {
                return this.encoder.end()
            };
            exports.StripBOM = StripBOMWrapper;

            function StripBOMWrapper( decoder, options ) {
                this.decoder = decoder;
                this.pass = false;
                this.options = options || {}
            }
            StripBOMWrapper.prototype.write = function( buf ) {
                var res = this.decoder.write( buf );
                if ( this.pass || !res ) return res;
                if ( res[ 0 ] === BOMChar ) {
                    res = res.slice( 1 );
                    if ( typeof this.options.stripBOM === "function" ) this.options.stripBOM()
                }
                this.pass = true;
                return res
            };
            StripBOMWrapper.prototype.end = function() {
                return this.decoder.end()
            }
        }, {} ],
        26: [ function( require, module, exports ) {
            "use strict";
            var Buffer = require( "buffer" ).Buffer;
            module.exports = function( iconv ) {
                var original = undefined;
                iconv.supportsNodeEncodingsExtension = !( new Buffer( 0 ) instanceof Uint8Array );
                iconv.extendNodeEncodings = function extendNodeEncodings() {
                    if ( original ) return;
                    original = {};
                    if ( !iconv.supportsNodeEncodingsExtension ) {
                        console.error( "ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node" );
                        console.error( "See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility" );
                        return
                    }
                    var nodeNativeEncodings = {
                        hex: true,
                        utf8: true,
                        "utf-8": true,
                        ascii: true,
                        binary: true,
                        base64: true,
                        ucs2: true,
                        "ucs-2": true,
                        utf16le: true,
                        "utf-16le": true
                    };
                    Buffer.isNativeEncoding = function( enc ) {
                        return enc && nodeNativeEncodings[ enc.toLowerCase() ]
                    };
                    var SlowBuffer = require( "buffer" ).SlowBuffer;
                    original.SlowBufferToString = SlowBuffer.prototype.toString;
                    SlowBuffer.prototype.toString = function( encoding, start, end ) {
                        encoding = String( encoding || "utf8" ).toLowerCase();
                        if ( Buffer.isNativeEncoding( encoding ) ) return original.SlowBufferToString.call( this, encoding, start, end );
                        if ( typeof start == "undefined" ) start = 0;
                        if ( typeof end == "undefined" ) end = this.length;
                        return iconv.decode( this.slice( start, end ), encoding )
                    };
                    original.SlowBufferWrite = SlowBuffer.prototype.write;
                    SlowBuffer.prototype.write = function( string, offset, length, encoding ) {
                        if ( isFinite( offset ) ) {
                            if ( !isFinite( length ) ) {
                                encoding = length;
                                length = undefined
                            }
                        } else {
                            var swap = encoding;
                            encoding = offset;
                            offset = length;
                            length = swap
                        }
                        offset = +offset || 0;
                        var remaining = this.length - offset;
                        if ( !length ) {
                            length = remaining
                        } else {
                            length = +length;
                            if ( length > remaining ) {
                                length = remaining
                            }
                        }
                        encoding = String( encoding || "utf8" ).toLowerCase();
                        if ( Buffer.isNativeEncoding( encoding ) ) return original.SlowBufferWrite.call( this, string, offset, length, encoding );
                        if ( string.length > 0 && ( length < 0 || offset < 0 ) ) throw new RangeError( "attempt to write beyond buffer bounds" );
                        var buf = iconv.encode( string, encoding );
                        if ( buf.length < length ) length = buf.length;
                        buf.copy( this, offset, 0, length );
                        return length
                    };
                    original.BufferIsEncoding = Buffer.isEncoding;
                    Buffer.isEncoding = function( encoding ) {
                        return Buffer.isNativeEncoding( encoding ) || iconv.encodingExists( encoding )
                    };
                    original.BufferByteLength = Buffer.byteLength;
                    Buffer.byteLength = SlowBuffer.byteLength = function( str, encoding ) {
                        encoding = String( encoding || "utf8" ).toLowerCase();
                        if ( Buffer.isNativeEncoding( encoding ) ) return original.BufferByteLength.call( this, str, encoding );
                        return iconv.encode( str, encoding ).length
                    };
                    original.BufferToString = Buffer.prototype.toString;
                    Buffer.prototype.toString = function( encoding, start, end ) {
                        encoding = String( encoding || "utf8" ).toLowerCase();
                        if ( Buffer.isNativeEncoding( encoding ) ) return original.BufferToString.call( this, encoding, start, end );
                        if ( typeof start == "undefined" ) start = 0;
                        if ( typeof end == "undefined" ) end = this.length;
                        return iconv.decode( this.slice( start, end ), encoding )
                    };
                    original.BufferWrite = Buffer.prototype.write;
                    Buffer.prototype.write = function( string, offset, length, encoding ) {
                        var _offset = offset,
                            _length = length,
                            _encoding = encoding;
                        if ( isFinite( offset ) ) {
                            if ( !isFinite( length ) ) {
                                encoding = length;
                                length = undefined
                            }
                        } else {
                            var swap = encoding;
                            encoding = offset;
                            offset = length;
                            length = swap
                        }
                        encoding = String( encoding || "utf8" ).toLowerCase();
                        if ( Buffer.isNativeEncoding( encoding ) ) return original.BufferWrite.call( this, string, _offset, _length, _encoding );
                        offset = +offset || 0;
                        var remaining = this.length - offset;
                        if ( !length ) {
                            length = remaining
                        } else {
                            length = +length;
                            if ( length > remaining ) {
                                length = remaining
                            }
                        }
                        if ( string.length > 0 && ( length < 0 || offset < 0 ) ) throw new RangeError( "attempt to write beyond buffer bounds" );
                        var buf = iconv.encode( string, encoding );
                        if ( buf.length < length ) length = buf.length;
                        buf.copy( this, offset, 0, length );
                        return length
                    };
                    if ( iconv.supportsStreams ) {
                        var Readable = require( "stream" ).Readable;
                        original.ReadableSetEncoding = Readable.prototype.setEncoding;
                        Readable.prototype.setEncoding = function setEncoding( enc, options ) {
                            this._readableState.decoder = iconv.getDecoder( enc, options );
                            this._readableState.encoding = enc
                        };
                        Readable.prototype.collect = iconv._collect
                    }
                };
                iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
                    if ( !iconv.supportsNodeEncodingsExtension ) return;
                    if ( !original ) throw new Error( "require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called." );
                    delete Buffer.isNativeEncoding;
                    var SlowBuffer = require( "buffer" ).SlowBuffer;
                    SlowBuffer.prototype.toString = original.SlowBufferToString;
                    SlowBuffer.prototype.write = original.SlowBufferWrite;
                    Buffer.isEncoding = original.BufferIsEncoding;
                    Buffer.byteLength = original.BufferByteLength;
                    Buffer.prototype.toString = original.BufferToString;
                    Buffer.prototype.write = original.BufferWrite;
                    if ( iconv.supportsStreams ) {
                        var Readable = require( "stream" ).Readable;
                        Readable.prototype.setEncoding = original.ReadableSetEncoding;
                        delete Readable.prototype.collect
                    }
                    original = undefined
                }
            }
        }, {
            buffer: 4,
            stream: 61
        } ],
        27: [ function( require, module, exports ) {
            ( function( process ) {
                "use strict";
                var Buffer = require( "buffer" ).Buffer;
                var bomHandling = require( "./bom-handling" ),
                    iconv = module.exports;
                iconv.encodings = null;
                iconv.defaultCharUnicode = "";
                iconv.defaultCharSingleByte = "?";
                iconv.encode = function encode( str, encoding, options ) {
                    str = "" + ( str || "" );
                    var encoder = iconv.getEncoder( encoding, options );
                    var res = encoder.write( str );
                    var trail = encoder.end();
                    return trail && trail.length > 0 ? Buffer.concat( [ res, trail ] ) : res
                };
                iconv.decode = function decode( buf, encoding, options ) {
                    if ( typeof buf === "string" ) {
                        if ( !iconv.skipDecodeWarning ) {
                            console.error( "Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding" );
                            iconv.skipDecodeWarning = true
                        }
                        buf = new Buffer( "" + ( buf || "" ), "binary" )
                    }
                    var decoder = iconv.getDecoder( encoding, options );
                    var res = decoder.write( buf );
                    var trail = decoder.end();
                    return trail ? res + trail : res
                };
                iconv.encodingExists = function encodingExists( enc ) {
                    try {
                        iconv.getCodec( enc );
                        return true
                    } catch ( e ) {
                        return false
                    }
                };
                iconv.toEncoding = iconv.encode;
                iconv.fromEncoding = iconv.decode;
                iconv._codecDataCache = {};
                iconv.getCodec = function getCodec( encoding ) {
                    if ( !iconv.encodings ) iconv.encodings = require( "../encodings" );
                    var enc = ( "" + encoding ).toLowerCase().replace( /[^0-9a-z]|:\d{4}$/g, "" );
                    var codecOptions = {};
                    while ( true ) {
                        var codec = iconv._codecDataCache[ enc ];
                        if ( codec ) return codec;
                        var codecDef = iconv.encodings[ enc ];
                        switch ( typeof codecDef ) {
                            case "string":
                                enc = codecDef;
                                break;
                            case "object":
                                for ( var key in codecDef ) codecOptions[ key ] = codecDef[ key ];
                                if ( !codecOptions.encodingName ) codecOptions.encodingName = enc;
                                enc = codecDef.type;
                                break;
                            case "function":
                                if ( !codecOptions.encodingName ) codecOptions.encodingName = enc;
                                codec = new codecDef( codecOptions, iconv );
                                iconv._codecDataCache[ codecOptions.encodingName ] = codec;
                                return codec;
                            default:
                                throw new Error( "Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')" )
                        }
                    }
                };
                iconv.getEncoder = function getEncoder( encoding, options ) {
                    var codec = iconv.getCodec( encoding ),
                        encoder = new codec.encoder( options, codec );
                    if ( codec.bomAware && options && options.addBOM ) encoder = new bomHandling.PrependBOM( encoder, options );
                    return encoder
                };
                iconv.getDecoder = function getDecoder( encoding, options ) {
                    var codec = iconv.getCodec( encoding ),
                        decoder = new codec.decoder( options, codec );
                    if ( codec.bomAware && !( options && options.stripBOM === false ) ) decoder = new bomHandling.StripBOM( decoder, options );
                    return decoder
                };
                var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
                if ( nodeVer ) {
                    var nodeVerArr = nodeVer.split( "." ).map( Number );
                    if ( nodeVerArr[ 0 ] > 0 || nodeVerArr[ 1 ] >= 10 ) {
                        require( "./streams" )( iconv )
                    }
                    require( "./extend-node" )( iconv )
                }
                if ( "" != "" ) {
                    console.error( "iconv-lite warning: javascript files use encoding different from utf-8. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info." )
                }
            } ).call( this, require( "_process" ) )
        }, {
            "../encodings": 10,
            "./bom-handling": 25,
            "./extend-node": 26,
            "./streams": 28,
            _process: 38,
            buffer: 4
        } ],
        28: [ function( require, module, exports ) {
            "use strict";
            var Buffer = require( "buffer" ).Buffer,
                Transform = require( "stream" ).Transform;
            module.exports = function( iconv ) {
                iconv.encodeStream = function encodeStream( encoding, options ) {
                    return new IconvLiteEncoderStream( iconv.getEncoder( encoding, options ), options )
                };
                iconv.decodeStream = function decodeStream( encoding, options ) {
                    return new IconvLiteDecoderStream( iconv.getDecoder( encoding, options ), options )
                };
                iconv.supportsStreams = true;
                iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
                iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
                iconv._collect = IconvLiteDecoderStream.prototype.collect
            };

            function IconvLiteEncoderStream( conv, options ) {
                this.conv = conv;
                options = options || {};
                options.decodeStrings = false;
                Transform.call( this, options )
            }
            IconvLiteEncoderStream.prototype = Object.create( Transform.prototype, {
                constructor: {
                    value: IconvLiteEncoderStream
                }
            } );
            IconvLiteEncoderStream.prototype._transform = function( chunk, encoding, done ) {
                if ( typeof chunk != "string" ) return done( new Error( "Iconv encoding stream needs strings as its input." ) );
                try {
                    var res = this.conv.write( chunk );
                    if ( res && res.length ) this.push( res );
                    done()
                } catch ( e ) {
                    done( e )
                }
            };
            IconvLiteEncoderStream.prototype._flush = function( done ) {
                try {
                    var res = this.conv.end();
                    if ( res && res.length ) this.push( res );
                    done()
                } catch ( e ) {
                    done( e )
                }
            };
            IconvLiteEncoderStream.prototype.collect = function( cb ) {
                var chunks = [];
                this.on( "error", cb );
                this.on( "data", function( chunk ) {
                    chunks.push( chunk )
                } );
                this.on( "end", function() {
                    cb( null, Buffer.concat( chunks ) )
                } );
                return this
            };

            function IconvLiteDecoderStream( conv, options ) {
                this.conv = conv;
                options = options || {};
                options.encoding = this.encoding = "utf8";
                Transform.call( this, options )
            }
            IconvLiteDecoderStream.prototype = Object.create( Transform.prototype, {
                constructor: {
                    value: IconvLiteDecoderStream
                }
            } );
            IconvLiteDecoderStream.prototype._transform = function( chunk, encoding, done ) {
                if ( !Buffer.isBuffer( chunk ) ) return done( new Error( "Iconv decoding stream needs buffers as its input." ) );
                try {
                    var res = this.conv.write( chunk );
                    if ( res && res.length ) this.push( res, this.encoding );
                    done()
                } catch ( e ) {
                    done( e )
                }
            };
            IconvLiteDecoderStream.prototype._flush = function( done ) {
                try {
                    var res = this.conv.end();
                    if ( res && res.length ) this.push( res, this.encoding );
                    done()
                } catch ( e ) {
                    done( e )
                }
            };
            IconvLiteDecoderStream.prototype.collect = function( cb ) {
                var res = "";
                this.on( "error", cb );
                this.on( "data", function( chunk ) {
                    res += chunk
                } );
                this.on( "end", function() {
                    cb( null, res )
                } );
                return this
            }
        }, {
            buffer: 4,
            stream: 61
        } ],
        29: [ function( require, module, exports ) {
            exports.read = function( buffer, offset, isLE, mLen, nBytes ) {
                var e, m;
                var eLen = nBytes * 8 - mLen - 1;
                var eMax = ( 1 << eLen ) - 1;
                var eBias = eMax >> 1;
                var nBits = -7;
                var i = isLE ? nBytes - 1 : 0;
                var d = isLE ? -1 : 1;
                var s = buffer[ offset + i ];
                i += d;
                e = s & ( 1 << -nBits ) - 1;
                s >>= -nBits;
                nBits += eLen;
                for ( ; nBits > 0; e = e * 256 + buffer[ offset + i ], i += d, nBits -= 8 ) {}
                m = e & ( 1 << -nBits ) - 1;
                e >>= -nBits;
                nBits += mLen;
                for ( ; nBits > 0; m = m * 256 + buffer[ offset + i ], i += d, nBits -= 8 ) {}
                if ( e === 0 ) {
                    e = 1 - eBias
                } else if ( e === eMax ) {
                    return m ? NaN : ( s ? -1 : 1 ) * Infinity
                } else {
                    m = m + Math.pow( 2, mLen );
                    e = e - eBias
                }
                return ( s ? -1 : 1 ) * m * Math.pow( 2, e - mLen )
            };
            exports.write = function( buffer, value, offset, isLE, mLen, nBytes ) {
                var e, m, c;
                var eLen = nBytes * 8 - mLen - 1;
                var eMax = ( 1 << eLen ) - 1;
                var eBias = eMax >> 1;
                var rt = mLen === 23 ? Math.pow( 2, -24 ) - Math.pow( 2, -77 ) : 0;
                var i = isLE ? 0 : nBytes - 1;
                var d = isLE ? 1 : -1;
                var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
                value = Math.abs( value );
                if ( isNaN( value ) || value === Infinity ) {
                    m = isNaN( value ) ? 1 : 0;
                    e = eMax
                } else {
                    e = Math.floor( Math.log( value ) / Math.LN2 );
                    if ( value * ( c = Math.pow( 2, -e ) ) < 1 ) {
                        e--;
                        c *= 2
                    }
                    if ( e + eBias >= 1 ) {
                        value += rt / c
                    } else {
                        value += rt * Math.pow( 2, 1 - eBias )
                    }
                    if ( value * c >= 2 ) {
                        e++;
                        c /= 2
                    }
                    if ( e + eBias >= eMax ) {
                        m = 0;
                        e = eMax
                    } else if ( e + eBias >= 1 ) {
                        m = ( value * c - 1 ) * Math.pow( 2, mLen );
                        e = e + eBias
                    } else {
                        m = value * Math.pow( 2, eBias - 1 ) * Math.pow( 2, mLen );
                        e = 0
                    }
                }
                for ( ; mLen >= 8; buffer[ offset + i ] = m & 255, i += d, m /= 256, mLen -= 8 ) {}
                e = e << mLen | m;
                eLen += mLen;
                for ( ; eLen > 0; buffer[ offset + i ] = e & 255, i += d, e /= 256, eLen -= 8 ) {}
                buffer[ offset + i - d ] |= s * 128
            }
        }, {} ],
        30: [ function( require, module, exports ) {
            if ( typeof Object.create === "function" ) {
                module.exports = function inherits( ctor, superCtor ) {
                    ctor.super_ = superCtor;
                    ctor.prototype = Object.create( superCtor.prototype, {
                        constructor: {
                            value: ctor,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    } )
                }
            } else {
                module.exports = function inherits( ctor, superCtor ) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {};
                    TempCtor.prototype = superCtor.prototype;
                    ctor.prototype = new TempCtor;
                    ctor.prototype.constructor = ctor
                }
            }
        }, {} ],
        31: [ function( require, module, exports ) {
            module.exports = function( obj ) {
                return obj != null && ( isBuffer( obj ) || isSlowBuffer( obj ) || !!obj._isBuffer )
            };

            function isBuffer( obj ) {
                return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer( obj )
            }

            function isSlowBuffer( obj ) {
                return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer( obj.slice( 0, 0 ) )
            }
        }, {} ],
        32: [ function( require, module, exports ) {
            var toString = {}.toString;
            module.exports = Array.isArray || function( arr ) {
                return toString.call( arr ) == "[object Array]"
            }
        }, {} ],
        33: [ function( require, module, exports ) {
            ( function() {
                "use strict";

                function rbush( maxEntries, format ) {
                    if ( !( this instanceof rbush ) ) return new rbush( maxEntries, format );
                    this._maxEntries = Math.max( 4, maxEntries || 9 );
                    this._minEntries = Math.max( 2, Math.ceil( this._maxEntries * .4 ) );
                    if ( format ) {
                        this._initFormat( format )
                    }
                    this.clear()
                }
                rbush.prototype = {
                    all: function() {
                        return this._all( this.data, [] )
                    },
                    search: function( bbox ) {
                        var node = this.data,
                            result = [],
                            toBBox = this.toBBox;
                        if ( !intersects( bbox, node.bbox ) ) return result;
                        var nodesToSearch = [],
                            i, len, child, childBBox;
                        while ( node ) {
                            for ( i = 0, len = node.children.length; i < len; i++ ) {
                                child = node.children[ i ];
                                childBBox = node.leaf ? toBBox( child ) : child.bbox;
                                if ( intersects( bbox, childBBox ) ) {
                                    if ( node.leaf ) result.push( child );
                                    else if ( contains( bbox, childBBox ) ) this._all( child, result );
                                    else nodesToSearch.push( child )
                                }
                            }
                            node = nodesToSearch.pop()
                        }
                        return result
                    },
                    collides: function( bbox ) {
                        var node = this.data,
                            toBBox = this.toBBox;
                        if ( !intersects( bbox, node.bbox ) ) return false;
                        var nodesToSearch = [],
                            i, len, child, childBBox;
                        while ( node ) {
                            for ( i = 0, len = node.children.length; i < len; i++ ) {
                                child = node.children[ i ];
                                childBBox = node.leaf ? toBBox( child ) : child.bbox;
                                if ( intersects( bbox, childBBox ) ) {
                                    if ( node.leaf || contains( bbox, childBBox ) ) return true;
                                    nodesToSearch.push( child )
                                }
                            }
                            node = nodesToSearch.pop()
                        }
                        return false
                    },
                    load: function( data ) {
                        if ( !( data && data.length ) ) return this;
                        if ( data.length < this._minEntries ) {
                            for ( var i = 0, len = data.length; i < len; i++ ) {
                                this.insert( data[ i ] )
                            }
                            return this
                        }
                        var node = this._build( data.slice(), 0, data.length - 1, 0 );
                        if ( !this.data.children.length ) {
                            this.data = node
                        } else if ( this.data.height === node.height ) {
                            this._splitRoot( this.data, node )
                        } else {
                            if ( this.data.height < node.height ) {
                                var tmpNode = this.data;
                                this.data = node;
                                node = tmpNode
                            }
                            this._insert( node, this.data.height - node.height - 1, true )
                        }
                        return this
                    },
                    insert: function( item ) {
                        if ( item ) this._insert( item, this.data.height - 1 );
                        return this
                    },
                    clear: function() {
                        this.data = {
                            children: [],
                            height: 1,
                            bbox: empty(),
                            leaf: true
                        };
                        return this
                    },
                    remove: function( item ) {
                        if ( !item ) return this;
                        var node = this.data,
                            bbox = this.toBBox( item ),
                            path = [],
                            indexes = [],
                            i, parent, index, goingUp;
                        while ( node || path.length ) {
                            if ( !node ) {
                                node = path.pop();
                                parent = path[ path.length - 1 ];
                                i = indexes.pop();
                                goingUp = true
                            }
                            if ( node.leaf ) {
                                index = node.children.indexOf( item );
                                if ( index !== -1 ) {
                                    node.children.splice( index, 1 );
                                    path.push( node );
                                    this._condense( path );
                                    return this
                                }
                            }
                            if ( !goingUp && !node.leaf && contains( node.bbox, bbox ) ) {
                                path.push( node );
                                indexes.push( i );
                                i = 0;
                                parent = node;
                                node = node.children[ 0 ]
                            } else if ( parent ) {
                                i++;
                                node = parent.children[ i ];
                                goingUp = false
                            } else node = null
                        }
                        return this
                    },
                    toBBox: function( item ) {
                        return item
                    },
                    compareMinX: function( a, b ) {
                        return a[ 0 ] - b[ 0 ]
                    },
                    compareMinY: function( a, b ) {
                        return a[ 1 ] - b[ 1 ]
                    },
                    toJSON: function() {
                        return this.data
                    },
                    fromJSON: function( data ) {
                        this.data = data;
                        return this
                    },
                    _all: function( node, result ) {
                        var nodesToSearch = [];
                        while ( node ) {
                            if ( node.leaf ) result.push.apply( result, node.children );
                            else nodesToSearch.push.apply( nodesToSearch, node.children );
                            node = nodesToSearch.pop()
                        }
                        return result
                    },
                    _build: function( items, left, right, height ) {
                        var N = right - left + 1,
                            M = this._maxEntries,
                            node;
                        if ( N <= M ) {
                            node = {
                                children: items.slice( left, right + 1 ),
                                height: 1,
                                bbox: null,
                                leaf: true
                            };
                            calcBBox( node, this.toBBox );
                            return node
                        }
                        if ( !height ) {
                            height = Math.ceil( Math.log( N ) / Math.log( M ) );
                            M = Math.ceil( N / Math.pow( M, height - 1 ) )
                        }
                        node = {
                            children: [],
                            height: height,
                            bbox: null,
                            leaf: false
                        };
                        var N2 = Math.ceil( N / M ),
                            N1 = N2 * Math.ceil( Math.sqrt( M ) ),
                            i, j, right2, right3;
                        multiSelect( items, left, right, N1, this.compareMinX );
                        for ( i = left; i <= right; i += N1 ) {
                            right2 = Math.min( i + N1 - 1, right );
                            multiSelect( items, i, right2, N2, this.compareMinY );
                            for ( j = i; j <= right2; j += N2 ) {
                                right3 = Math.min( j + N2 - 1, right2 );
                                node.children.push( this._build( items, j, right3, height - 1 ) )
                            }
                        }
                        calcBBox( node, this.toBBox );
                        return node
                    },
                    _chooseSubtree: function( bbox, node, level, path ) {
                        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
                        while ( true ) {
                            path.push( node );
                            if ( node.leaf || path.length - 1 === level ) break;
                            minArea = minEnlargement = Infinity;
                            for ( i = 0, len = node.children.length; i < len; i++ ) {
                                child = node.children[ i ];
                                area = bboxArea( child.bbox );
                                enlargement = enlargedArea( bbox, child.bbox ) - area;
                                if ( enlargement < minEnlargement ) {
                                    minEnlargement = enlargement;
                                    minArea = area < minArea ? area : minArea;
                                    targetNode = child
                                } else if ( enlargement === minEnlargement ) {
                                    if ( area < minArea ) {
                                        minArea = area;
                                        targetNode = child
                                    }
                                }
                            }
                            node = targetNode || node.children[ 0 ]
                        }
                        return node
                    },
                    _insert: function( item, level, isNode ) {
                        var toBBox = this.toBBox,
                            bbox = isNode ? item.bbox : toBBox( item ),
                            insertPath = [];
                        var node = this._chooseSubtree( bbox, this.data, level, insertPath );
                        node.children.push( item );
                        extend( node.bbox, bbox );
                        while ( level >= 0 ) {
                            if ( insertPath[ level ].children.length > this._maxEntries ) {
                                this._split( insertPath, level );
                                level--
                            } else break
                        }
                        this._adjustParentBBoxes( bbox, insertPath, level )
                    },
                    _split: function( insertPath, level ) {
                        var node = insertPath[ level ],
                            M = node.children.length,
                            m = this._minEntries;
                        this._chooseSplitAxis( node, m, M );
                        var splitIndex = this._chooseSplitIndex( node, m, M );
                        var newNode = {
                            children: node.children.splice( splitIndex, node.children.length - splitIndex ),
                            height: node.height,
                            bbox: null,
                            leaf: false
                        };
                        if ( node.leaf ) newNode.leaf = true;
                        calcBBox( node, this.toBBox );
                        calcBBox( newNode, this.toBBox );
                        if ( level ) insertPath[ level - 1 ].children.push( newNode );
                        else this._splitRoot( node, newNode )
                    },
                    _splitRoot: function( node, newNode ) {
                        this.data = {
                            children: [ node, newNode ],
                            height: node.height + 1,
                            bbox: null,
                            leaf: false
                        };
                        calcBBox( this.data, this.toBBox )
                    },
                    _chooseSplitIndex: function( node, m, M ) {
                        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
                        minOverlap = minArea = Infinity;
                        for ( i = m; i <= M - m; i++ ) {
                            bbox1 = distBBox( node, 0, i, this.toBBox );
                            bbox2 = distBBox( node, i, M, this.toBBox );
                            overlap = intersectionArea( bbox1, bbox2 );
                            area = bboxArea( bbox1 ) + bboxArea( bbox2 );
                            if ( overlap < minOverlap ) {
                                minOverlap = overlap;
                                index = i;
                                minArea = area < minArea ? area : minArea
                            } else if ( overlap === minOverlap ) {
                                if ( area < minArea ) {
                                    minArea = area;
                                    index = i
                                }
                            }
                        }
                        return index
                    },
                    _chooseSplitAxis: function( node, m, M ) {
                        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
                            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
                            xMargin = this._allDistMargin( node, m, M, compareMinX ),
                            yMargin = this._allDistMargin( node, m, M, compareMinY );
                        if ( xMargin < yMargin ) node.children.sort( compareMinX )
                    },
                    _allDistMargin: function( node, m, M, compare ) {
                        node.children.sort( compare );
                        var toBBox = this.toBBox,
                            leftBBox = distBBox( node, 0, m, toBBox ),
                            rightBBox = distBBox( node, M - m, M, toBBox ),
                            margin = bboxMargin( leftBBox ) + bboxMargin( rightBBox ),
                            i, child;
                        for ( i = m; i < M - m; i++ ) {
                            child = node.children[ i ];
                            extend( leftBBox, node.leaf ? toBBox( child ) : child.bbox );
                            margin += bboxMargin( leftBBox )
                        }
                        for ( i = M - m - 1; i >= m; i-- ) {
                            child = node.children[ i ];
                            extend( rightBBox, node.leaf ? toBBox( child ) : child.bbox );
                            margin += bboxMargin( rightBBox )
                        }
                        return margin
                    },
                    _adjustParentBBoxes: function( bbox, path, level ) {
                        for ( var i = level; i >= 0; i-- ) {
                            extend( path[ i ].bbox, bbox )
                        }
                    },
                    _condense: function( path ) {
                        for ( var i = path.length - 1, siblings; i >= 0; i-- ) {
                            if ( path[ i ].children.length === 0 ) {
                                if ( i > 0 ) {
                                    siblings = path[ i - 1 ].children;
                                    siblings.splice( siblings.indexOf( path[ i ] ), 1 )
                                } else this.clear()
                            } else calcBBox( path[ i ], this.toBBox )
                        }
                    },
                    _initFormat: function( format ) {
                        var compareArr = [ "return a", " - b", ";" ];
                        this.compareMinX = new Function( "a", "b", compareArr.join( format[ 0 ] ) );
                        this.compareMinY = new Function( "a", "b", compareArr.join( format[ 1 ] ) );
                        this.toBBox = new Function( "a", "return [a" + format.join( ", a" ) + "];" )
                    }
                };

                function calcBBox( node, toBBox ) {
                    node.bbox = distBBox( node, 0, node.children.length, toBBox )
                }

                function distBBox( node, k, p, toBBox ) {
                    var bbox = empty();
                    for ( var i = k, child; i < p; i++ ) {
                        child = node.children[ i ];
                        extend( bbox, node.leaf ? toBBox( child ) : child.bbox )
                    }
                    return bbox
                }

                function empty() {
                    return [ Infinity, Infinity, -Infinity, -Infinity ]
                }

                function extend( a, b ) {
                    a[ 0 ] = Math.min( a[ 0 ], b[ 0 ] );
                    a[ 1 ] = Math.min( a[ 1 ], b[ 1 ] );
                    a[ 2 ] = Math.max( a[ 2 ], b[ 2 ] );
                    a[ 3 ] = Math.max( a[ 3 ], b[ 3 ] );
                    return a
                }

                function compareNodeMinX( a, b ) {
                    return a.bbox[ 0 ] - b.bbox[ 0 ]
                }

                function compareNodeMinY( a, b ) {
                    return a.bbox[ 1 ] - b.bbox[ 1 ]
                }

                function bboxArea( a ) {
                    return ( a[ 2 ] - a[ 0 ] ) * ( a[ 3 ] - a[ 1 ] )
                }

                function bboxMargin( a ) {
                    return a[ 2 ] - a[ 0 ] + ( a[ 3 ] - a[ 1 ] )
                }

                function enlargedArea( a, b ) {
                    return ( Math.max( b[ 2 ], a[ 2 ] ) - Math.min( b[ 0 ], a[ 0 ] ) ) * ( Math.max( b[ 3 ], a[ 3 ] ) - Math.min( b[ 1 ], a[ 1 ] ) )
                }

                function intersectionArea( a, b ) {
                    var minX = Math.max( a[ 0 ], b[ 0 ] ),
                        minY = Math.max( a[ 1 ], b[ 1 ] ),
                        maxX = Math.min( a[ 2 ], b[ 2 ] ),
                        maxY = Math.min( a[ 3 ], b[ 3 ] );
                    return Math.max( 0, maxX - minX ) * Math.max( 0, maxY - minY )
                }

                function contains( a, b ) {
                    return a[ 0 ] <= b[ 0 ] && a[ 1 ] <= b[ 1 ] && b[ 2 ] <= a[ 2 ] && b[ 3 ] <= a[ 3 ]
                }

                function intersects( a, b ) {
                    return b[ 0 ] <= a[ 2 ] && b[ 1 ] <= a[ 3 ] && b[ 2 ] >= a[ 0 ] && b[ 3 ] >= a[ 1 ]
                }

                function multiSelect( arr, left, right, n, compare ) {
                    var stack = [ left, right ],
                        mid;
                    while ( stack.length ) {
                        right = stack.pop();
                        left = stack.pop();
                        if ( right - left <= n ) continue;
                        mid = left + Math.ceil( ( right - left ) / n / 2 ) * n;
                        select( arr, left, right, mid, compare );
                        stack.push( left, mid, mid, right )
                    }
                }

                function select( arr, left, right, k, compare ) {
                    var n, i, z, s, sd, newLeft, newRight, t, j;
                    while ( right > left ) {
                        if ( right - left > 600 ) {
                            n = right - left + 1;
                            i = k - left + 1;
                            z = Math.log( n );
                            s = .5 * Math.exp( 2 * z / 3 );
                            sd = .5 * Math.sqrt( z * s * ( n - s ) / n ) * ( i - n / 2 < 0 ? -1 : 1 );
                            newLeft = Math.max( left, Math.floor( k - i * s / n + sd ) );
                            newRight = Math.min( right, Math.floor( k + ( n - i ) * s / n + sd ) );
                            select( arr, newLeft, newRight, k, compare )
                        }
                        t = arr[ k ];
                        i = left;
                        j = right;
                        swap( arr, left, k );
                        if ( compare( arr[ right ], t ) > 0 ) swap( arr, left, right );
                        while ( i < j ) {
                            swap( arr, i, j );
                            i++;
                            j--;
                            while ( compare( arr[ i ], t ) < 0 ) i++;
                            while ( compare( arr[ j ], t ) > 0 ) j--
                        }
                        if ( compare( arr[ left ], t ) === 0 ) swap( arr, left, j );
                        else {
                            j++;
                            swap( arr, j, right )
                        }
                        if ( j <= k ) left = j + 1;
                        if ( k <= j ) right = j - 1
                    }
                }

                function swap( arr, i, j ) {
                    var tmp = arr[ i ];
                    arr[ i ] = arr[ j ];
                    arr[ j ] = tmp
                }
                if ( typeof define === "function" && define.amd ) define( "rbush", function() {
                    return rbush
                } );
                else if ( typeof module !== "undefined" ) module.exports = rbush;
                else if ( typeof self !== "undefined" ) self.rbush = rbush;
                else window.rbush = rbush
            } )()
        }, {} ],
        34: [ function( require, module, exports ) {
            ( function() {
                var VERSION = "0.3.43";
                var error = function() {
                    var msg = Utils.toArray( arguments ).join( " " );
                    throw new Error( msg )
                };
                var utils = {
                    getUniqueName: function( prefix ) {
                        var n = Utils.__uniqcount || 0;
                        Utils.__uniqcount = n + 1;
                        return ( prefix || "__id_" ) + n
                    },
                    isFunction: function( obj ) {
                        return typeof obj == "function"
                    },
                    isObject: function( obj ) {
                        return obj === Object( obj )
                    },
                    clamp: function( val, min, max ) {
                        return val < min ? min : val > max ? max : val
                    },
                    interpolate: function( val1, val2, pct ) {
                        return val1 * ( 1 - pct ) + val2 * pct
                    },
                    isArray: function( obj ) {
                        return Array.isArray( obj )
                    },
                    isNumber: function( obj ) {
                        return obj != null && obj.constructor == Number
                    },
                    isInteger: function( obj ) {
                        return Utils.isNumber( obj ) && ( obj | 0 ) === obj
                    },
                    isString: function( obj ) {
                        return obj != null && obj.toString === String.prototype.toString
                    },
                    isBoolean: function( obj ) {
                        return obj === true || obj === false
                    },
                    toArray: function( obj ) {
                        var arr;
                        if ( !Utils.isArrayLike( obj ) ) error( "Utils.toArray() requires an array-like object" );
                        try {
                            arr = Array.prototype.slice.call( obj, 0 )
                        } catch ( e ) {
                            arr = [];
                            for ( var i = 0, n = obj.length; i < n; i++ ) {
                                arr[ i ] = obj[ i ]
                            }
                        }
                        return arr
                    },
                    isArrayLike: function( obj ) {
                        if ( !obj ) return false;
                        if ( Utils.isArray( obj ) ) return true;
                        if ( Utils.isString( obj ) ) return false;
                        if ( obj.length === 0 ) return true;
                        if ( obj.length > 0 ) return true;
                        return false
                    },
                    addslashes: function( str ) {
                        return ( str + "" ).replace( /[\\"']/g, "\\$&" ).replace( /\u0000/g, "\\0" )
                    },
                    regexEscape: function( str ) {
                        return str.replace( /[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&" )
                    },
                    defaults: function( dest ) {
                        for ( var i = 1, n = arguments.length; i < n; i++ ) {
                            var src = arguments[ i ] || {};
                            for ( var key in src ) {
                                if ( key in dest === false && src.hasOwnProperty( key ) ) {
                                    dest[ key ] = src[ key ]
                                }
                            }
                        }
                        return dest
                    },
                    extend: function( o ) {
                        var dest = o || {},
                            n = arguments.length,
                            key, i, src;
                        for ( i = 1; i < n; i++ ) {
                            src = arguments[ i ] || {};
                            for ( key in src ) {
                                if ( src.hasOwnProperty( key ) ) {
                                    dest[ key ] = src[ key ]
                                }
                            }
                        }
                        return dest
                    },
                    inherit: function( targ, src ) {
                        var f = function() {
                            if ( this.__super__ == f ) {
                                this.__super__ = src.prototype.__super__;
                                src.apply( this, arguments );
                                delete this.__super__
                            }
                        };
                        f.prototype = src.prototype || src;
                        targ.prototype = Utils.extend( new f, targ.prototype );
                        targ.prototype.constructor = targ;
                        targ.prototype.__super__ = f
                    },
                    subclass: function( parent ) {
                        var child = function() {
                            this.__super__.apply( this, Utils.toArray( arguments ) )
                        };
                        Utils.inherit( child, parent );
                        for ( var i = 1; i < arguments.length; i++ ) {
                            Utils.extend( child.prototype, arguments[ i ] )
                        }
                        return child
                    }
                };
                var Utils = utils;
                var Env = function() {
                    var inNode = typeof module !== "undefined" && !!module.exports;
                    var inBrowser = typeof window !== "undefined" && !inNode;
                    var inPhantom = inBrowser && !!( window.phantom && window.phantom.exit );
                    var ieVersion = inBrowser && /MSIE ([0-9]+)/.exec( navigator.appVersion ) && parseInt( RegExp.$1 ) || NaN;
                    return {
                        iPhone: inBrowser && !!navigator.userAgent.match( /iPhone/i ),
                        iPad: inBrowser && !!navigator.userAgent.match( /iPad/i ),
                        canvas: inBrowser && !!document.createElement( "canvas" ).getContext,
                        inNode: inNode,
                        inPhantom: inPhantom,
                        inBrowser: inBrowser,
                        ieVersion: ieVersion,
                        ie: !isNaN( ieVersion )
                    }
                }();
                var T = {
                    stack: [],
                    verbose: true,
                    start: function( msg ) {
                        if ( T.verbose && msg ) verbose( T.prefix() + msg );
                        T.stack.push( +new Date )
                    },
                    stop: function( note ) {
                        var startTime = T.stack.pop();
                        var elapsed = +new Date - startTime;
                        if ( T.verbose ) {
                            var msg = T.prefix() + elapsed + "ms";
                            if ( note ) {
                                msg += " " + note
                            }
                            verbose( msg )
                        }
                        return elapsed
                    },
                    prefix: function() {
                        var str = "- ",
                            level = this.stack.length;
                        while ( level-- ) str = "-" + str;
                        return str
                    }
                };
                utils.merge = function( dest, src ) {
                    if ( !utils.isArray( dest ) || !utils.isArray( src ) ) {
                        error( "Usage: utils.merge(destArray, srcArray);" )
                    }
                    for ( var i = 0, n = src.length; i < n; i++ ) {
                        dest.push( src[ i ] )
                    }
                    return dest
                };
                utils.difference = function( arr, other ) {
                    var index = utils.arrayToIndex( other );
                    return arr.filter( function( el ) {
                        return !Object.prototype.hasOwnProperty.call( index, el )
                    } )
                };
                utils.contains = function( container, item ) {
                    if ( utils.isString( container ) ) {
                        return container.indexOf( item ) != -1
                    } else if ( utils.isArrayLike( container ) ) {
                        return utils.indexOf( container, item ) != -1
                    }
                    error( "Expected Array or String argument" )
                };
                utils.some = function( arr, test ) {
                    return arr.reduce( function( val, item ) {
                        return val || test( item )
                    }, false )
                };
                utils.every = function( arr, test ) {
                    return arr.reduce( function( val, item ) {
                        return val && test( item )
                    }, true )
                };
                utils.find = function( arr, test, ctx ) {
                    var matches = arr.filter( test, ctx );
                    return matches.length === 0 ? null : matches[ 0 ]
                };
                utils.indexOf = function( arr, item, prop ) {
                    if ( prop ) error( "utils.indexOf() No longer supports property argument" );
                    var nan = !( item === item );
                    for ( var i = 0, len = arr.length || 0; i < len; i++ ) {
                        if ( arr[ i ] === item ) return i;
                        if ( nan && !( arr[ i ] === arr[ i ] ) ) return i
                    }
                    return -1
                };
                utils.range = function( len, start, inc ) {
                    var arr = [],
                        v = start === void 0 ? 0 : start,
                        i = inc === void 0 ? 1 : inc;
                    while ( len-- ) {
                        arr.push( v );
                        v += i
                    }
                    return arr
                };
                utils.repeat = function( times, func ) {
                    var values = [],
                        val;
                    for ( var i = 0; i < times; i++ ) {
                        val = func( i );
                        if ( val !== void 0 ) {
                            values[ i ] = val
                        }
                    }
                    return values.length > 0 ? values : void 0
                };
                utils.sum = function( arr, info ) {
                    if ( !utils.isArrayLike( arr ) ) error( "utils.sum() expects an array, received:", arr );
                    var tot = 0,
                        nan = 0,
                        val;
                    for ( var i = 0, n = arr.length; i < n; i++ ) {
                        val = arr[ i ];
                        if ( val ) {
                            tot += val
                        } else if ( isNaN( val ) ) {
                            nan++
                        }
                    }
                    if ( info ) {
                        info.nan = nan
                    }
                    return tot
                };
                utils.getArrayBounds = function( arr ) {
                    var min = Infinity,
                        max = -Infinity,
                        nan = 0,
                        val;
                    for ( var i = 0, len = arr.length; i < len; i++ ) {
                        val = arr[ i ];
                        if ( val !== val ) nan++;
                        if ( val < min ) min = val;
                        if ( val > max ) max = val
                    }
                    return {
                        min: min,
                        max: max,
                        nan: nan
                    }
                };
                utils.uniq = function( src ) {
                    var index = {};
                    return src.reduce( function( memo, el ) {
                        if ( el in index === false ) {
                            index[ el ] = true;
                            memo.push( el )
                        }
                        return memo
                    }, [] )
                };
                utils.pluck = function( arr, key ) {
                    return arr.map( function( obj ) {
                        return obj[ key ]
                    } )
                };
                utils.countValues = function( arr ) {
                    return arr.reduce( function( memo, val ) {
                        memo[ val ] = val in memo ? memo[ val ] + 1 : 1;
                        return memo
                    }, {} )
                };
                utils.indexOn = function( arr, k ) {
                    return arr.reduce( function( index, o ) {
                        index[ o[ k ] ] = o;
                        return index
                    }, {} )
                };
                utils.groupBy = function( arr, k ) {
                    return arr.reduce( function( index, o ) {
                        var keyval = o[ k ];
                        if ( keyval in index ) {
                            index[ keyval ].push( o )
                        } else {
                            index[ keyval ] = [ o ]
                        }
                        return index
                    }, {} )
                };
                utils.arrayToIndex = function( arr, val ) {
                    var init = arguments.length > 1;
                    return arr.reduce( function( index, key ) {
                        index[ key ] = init ? val : true;
                        return index
                    }, {} )
                };
                utils.forEach = function( arr, func, ctx ) {
                    if ( !utils.isArrayLike( arr ) ) {
                        throw new Error( "#forEach() takes an array-like argument. " + arr )
                    }
                    for ( var i = 0, n = arr.length; i < n; i++ ) {
                        func.call( ctx, arr[ i ], i )
                    }
                };
                utils.forEachProperty = function( o, func, ctx ) {
                    Object.keys( o ).forEach( function( key ) {
                        func.call( ctx, o[ key ], key )
                    } )
                };
                utils.initializeArray = function( arr, init ) {
                    for ( var i = 0, len = arr.length; i < len; i++ ) {
                        arr[ i ] = init
                    }
                    return arr
                };
                utils.replaceArray = function( arr, arr2 ) {
                    arr.splice( 0, arr.length );
                    arr.push.apply( arr, arr2 )
                };
                Utils.repeatString = function( src, n ) {
                    var str = "";
                    for ( var i = 0; i < n; i++ ) str += src;
                    return str
                };
                Utils.pluralSuffix = function( count ) {
                    return count != 1 ? "s" : ""
                };
                Utils.endsWith = function( str, ending ) {
                    return str.indexOf( ending, str.length - ending.length ) !== -1
                };
                Utils.lpad = function( str, size, pad ) {
                    pad = pad || " ";
                    str = String( str );
                    return Utils.repeatString( pad, size - str.length ) + str
                };
                Utils.rpad = function( str, size, pad ) {
                    pad = pad || " ";
                    str = String( str );
                    return str + Utils.repeatString( pad, size - str.length )
                };
                Utils.trim = function( str ) {
                    return Utils.ltrim( Utils.rtrim( str ) )
                };
                var ltrimRxp = /^\s+/;
                Utils.ltrim = function( str ) {
                    return str.replace( ltrimRxp, "" )
                };
                var rtrimRxp = /\s+$/;
                Utils.rtrim = function( str ) {
                    return str.replace( rtrimRxp, "" )
                };
                Utils.addThousandsSep = function( str ) {
                    var fmt = "",
                        start = str[ 0 ] == "-" ? 1 : 0,
                        dec = str.indexOf( "." ),
                        end = str.length,
                        ins = ( dec == -1 ? end : dec ) - 3;
                    while ( ins > start ) {
                        fmt = "," + str.substring( ins, end ) + fmt;
                        end = ins;
                        ins -= 3
                    }
                    return str.substring( 0, end ) + fmt
                };
                Utils.numToStr = function( num, decimals ) {
                    return decimals >= 0 ? num.toFixed( decimals ) : String( num )
                };
                Utils.formatNumber = function( num, decimals, nullStr, showPos ) {
                    var fmt;
                    if ( isNaN( num ) ) {
                        fmt = nullStr || "-"
                    } else {
                        fmt = Utils.numToStr( num, decimals );
                        fmt = Utils.addThousandsSep( fmt );
                        if ( showPos && parseFloat( fmt ) > 0 ) {
                            fmt = "+" + fmt
                        }
                    }
                    return fmt
                };

                function Transform() {
                    this.mx = this.my = 1;
                    this.bx = this.by = 0
                }
                Transform.prototype.isNull = function() {
                    return !this.mx || !this.my || isNaN( this.bx ) || isNaN( this.by )
                };
                Transform.prototype.invert = function() {
                    var inv = new Transform;
                    inv.mx = 1 / this.mx;
                    inv.my = 1 / this.my;
                    inv.bx = -this.bx / this.mx;
                    inv.by = -this.by / this.my;
                    return inv
                };
                Transform.prototype.transform = function( x, y, xy ) {
                    xy = xy || [];
                    xy[ 0 ] = x * this.mx + this.bx;
                    xy[ 1 ] = y * this.my + this.by;
                    return xy
                };
                Transform.prototype.toString = function() {
                    return Utils.toString( Utils.extend( {}, this ) )
                };

                function Bounds() {
                    if ( arguments.length > 0 ) {
                        this.setBounds.apply( this, arguments )
                    }
                }
                Bounds.prototype.toString = function() {
                    return JSON.stringify( {
                        xmin: this.xmin,
                        xmax: this.xmax,
                        ymin: this.ymin,
                        ymax: this.ymax
                    } )
                };
                Bounds.prototype.toArray = function() {
                    return this.hasBounds() ? [ this.xmin, this.ymin, this.xmax, this.ymax ] : []
                };
                Bounds.prototype.hasBounds = function() {
                    return this.xmin <= this.xmax && this.ymin <= this.ymax
                };
                Bounds.prototype.sameBounds = Bounds.prototype.equals = function( bb ) {
                    return bb && this.xmin === bb.xmin && this.xmax === bb.xmax && this.ymin === bb.ymin && this.ymax === bb.ymax
                };
                Bounds.prototype.width = function() {
                    return this.xmax - this.xmin || 0
                };
                Bounds.prototype.height = function() {
                    return this.ymax - this.ymin || 0
                };
                Bounds.prototype.area = function() {
                    return this.width() * this.height() || 0
                };
                Bounds.prototype.empty = function() {
                    this.xmin = this.ymin = this.xmax = this.ymax = void 0;
                    return this
                };
                Bounds.prototype.setBounds = function( a, b, c, d ) {
                    if ( arguments.length == 1 ) {
                        if ( Utils.isArrayLike( a ) ) {
                            b = a[ 1 ];
                            c = a[ 2 ];
                            d = a[ 3 ];
                            a = a[ 0 ]
                        } else {
                            b = a.ymin;
                            c = a.xmax;
                            d = a.ymax;
                            a = a.xmin
                        }
                    }
                    this.xmin = a;
                    this.ymin = b;
                    this.xmax = c;
                    this.ymax = d;
                    if ( a > c || b > d ) this.update();
                    return this
                };
                Bounds.prototype.centerX = function() {
                    var x = ( this.xmin + this.xmax ) * .5;
                    return x
                };
                Bounds.prototype.centerY = function() {
                    var y = ( this.ymax + this.ymin ) * .5;
                    return y
                };
                Bounds.prototype.containsPoint = function( x, y ) {
                    if ( x >= this.xmin && x <= this.xmax && y <= this.ymax && y >= this.ymin ) {
                        return true
                    }
                    return false
                };
                Bounds.prototype.containsBufferedPoint = Bounds.prototype.containsCircle = function( x, y, buf ) {
                    if ( x + buf > this.xmin && x - buf < this.xmax ) {
                        if ( y - buf < this.ymax && y + buf > this.ymin ) {
                            return true
                        }
                    }
                    return false
                };
                Bounds.prototype.intersects = function( bb ) {
                    if ( bb.xmin <= this.xmax && bb.xmax >= this.xmin && bb.ymax >= this.ymin && bb.ymin <= this.ymax ) {
                        return true
                    }
                    return false
                };
                Bounds.prototype.contains = function( bb ) {
                    if ( bb.xmin >= this.xmin && bb.ymax <= this.ymax && bb.xmax <= this.xmax && bb.ymin >= this.ymin ) {
                        return true
                    }
                    return false
                };
                Bounds.prototype.shift = function( x, y ) {
                    this.setBounds( this.xmin + x, this.ymin + y, this.xmax + x, this.ymax + y )
                };
                Bounds.prototype.padBounds = function( a, b, c, d ) {
                    this.xmin -= a;
                    this.ymin -= b;
                    this.xmax += c;
                    this.ymax += d
                };
                Bounds.prototype.scale = function( pct, pctY ) {
                    var halfWidth = ( this.xmax - this.xmin ) * .5;
                    var halfHeight = ( this.ymax - this.ymin ) * .5;
                    var kx = pct - 1;
                    var ky = pctY === undefined ? kx : pctY - 1;
                    this.xmin -= halfWidth * kx;
                    this.ymin -= halfHeight * ky;
                    this.xmax += halfWidth * kx;
                    this.ymax += halfHeight * ky
                };
                Bounds.prototype.cloneBounds = Bounds.prototype.clone = function() {
                    return new Bounds( this.xmin, this.ymin, this.xmax, this.ymax )
                };
                Bounds.prototype.clearBounds = function() {
                    this.setBounds( new Bounds )
                };
                Bounds.prototype.mergePoint = function( x, y ) {
                    if ( this.xmin === void 0 ) {
                        this.setBounds( x, y, x, y )
                    } else {
                        if ( x < this.xmin ) this.xmin = x;
                        else if ( x > this.xmax ) this.xmax = x;
                        if ( y < this.ymin ) this.ymin = y;
                        else if ( y > this.ymax ) this.ymax = y
                    }
                };
                Bounds.prototype.fillOut = function( aspect, focusX, focusY ) {
                    if ( arguments.length < 3 ) {
                        focusX = .5;
                        focusY = .5
                    }
                    var w = this.width(),
                        h = this.height(),
                        currAspect = w / h,
                        pad;
                    if ( isNaN( aspect ) || aspect <= 0 ) {} else if ( currAspect < aspect ) {
                        pad = h * aspect - w;
                        this.xmin -= ( 1 - focusX ) * pad;
                        this.xmax += focusX * pad
                    } else {
                        pad = w / aspect - h;
                        this.ymin -= ( 1 - focusY ) * pad;
                        this.ymax += focusY * pad
                    }
                    return this
                };
                Bounds.prototype.update = function() {
                    var tmp;
                    if ( this.xmin > this.xmax ) {
                        tmp = this.xmin;
                        this.xmin = this.xmax;
                        this.xmax = tmp
                    }
                    if ( this.ymin > this.ymax ) {
                        tmp = this.ymin;
                        this.ymin = this.ymax;
                        this.ymax = tmp
                    }
                };
                Bounds.prototype.transform = function( t ) {
                    this.xmin = this.xmin * t.mx + t.bx;
                    this.xmax = this.xmax * t.mx + t.bx;
                    this.ymin = this.ymin * t.my + t.by;
                    this.ymax = this.ymax * t.my + t.by;
                    this.update();
                    return this
                };
                Bounds.prototype.getTransform = function( b2, flipY ) {
                    var t = new Transform;
                    t.mx = b2.width() / this.width() || 1;
                    t.bx = b2.xmin - t.mx * this.xmin;
                    if ( flipY ) {
                        t.my = -b2.height() / this.height() || 1;
                        t.by = b2.ymax - t.my * this.ymin
                    } else {
                        t.my = b2.height() / this.height() || 1;
                        t.by = b2.ymin - t.my * this.ymin
                    }
                    return t
                };
                Bounds.prototype.mergeCircle = function( x, y, r ) {
                    if ( r < 0 ) r = -r;
                    this.mergeBounds( [ x - r, y - r, x + r, y + r ] )
                };
                Bounds.prototype.mergeBounds = function( bb ) {
                    var a, b, c, d;
                    if ( bb instanceof Bounds ) {
                        a = bb.xmin, b = bb.ymin, c = bb.xmax, d = bb.ymax
                    } else if ( arguments.length == 4 ) {
                        a = arguments[ 0 ];
                        b = arguments[ 1 ];
                        c = arguments[ 2 ];
                        d = arguments[ 3 ]
                    } else if ( bb.length == 4 ) {
                        a = bb[ 0 ], b = bb[ 1 ], c = bb[ 2 ], d = bb[ 3 ]
                    } else {
                        error( "Bounds#mergeBounds() invalid argument:", bb )
                    }
                    if ( this.xmin === void 0 ) {
                        this.setBounds( a, b, c, d )
                    } else {
                        if ( a < this.xmin ) this.xmin = a;
                        if ( b < this.ymin ) this.ymin = b;
                        if ( c > this.xmax ) this.xmax = c;
                        if ( d > this.ymax ) this.ymax = d
                    }
                    return this
                };
                Utils.sortOn = function( arr ) {
                    var comparators = [];
                    for ( var i = 1; i < arguments.length; i += 2 ) {
                        comparators.push( Utils.getKeyComparator( arguments[ i ], arguments[ i + 1 ] ) )
                    }
                    arr.sort( function( a, b ) {
                        var cmp = 0,
                            i = 0,
                            n = comparators.length;
                        while ( i < n && cmp === 0 ) {
                            cmp = comparators[ i ]( a, b );
                            i++
                        }
                        return cmp
                    } );
                    return arr
                };
                Utils.genericSort = function( arr, asc ) {
                    var compare = Utils.getGenericComparator( asc );
                    Array.prototype.sort.call( arr, compare );
                    return arr
                };
                Utils.sortOnKey = function( arr, getter, asc ) {
                    var compare = Utils.getGenericComparator( asc !== false );
                    arr.sort( function( a, b ) {
                        return compare( getter( a ), getter( b ) )
                    } )
                };
                Utils.sortOnKey2 = function( arr, getKey, asc ) {
                    Utils.sortArrayByKeys( arr, arr.map( getKey ), asc )
                };
                Utils.sortArrayByKeys = function( arr, keys, asc ) {
                    var ids = Utils.getSortedIds( keys, asc );
                    Utils.reorderArray( arr, ids )
                };
                Utils.getSortedIds = function( arr, asc ) {
                    var ids = Utils.range( arr.length );
                    Utils.sortArrayIndex( ids, arr, asc );
                    return ids
                };
                Utils.sortArrayIndex = function( ids, arr, asc ) {
                    var compare = Utils.getGenericComparator( asc );
                    ids.sort( function( i, j ) {
                        var cmp = compare( arr[ i ], arr[ j ] );
                        return cmp > 0 || cmp === 0 && i < j ? 1 : -1
                    } )
                };
                Utils.reorderArray = function( arr, idxs ) {
                    var len = idxs.length;
                    var arr2 = [];
                    for ( var i = 0; i < len; i++ ) {
                        var idx = idxs[ i ];
                        if ( idx < 0 || idx >= len ) error( "Out-of-bounds array idx" );
                        arr2[ i ] = arr[ idx ]
                    }
                    Utils.replaceArray( arr, arr2 )
                };
                Utils.getKeyComparator = function( key, asc ) {
                    var compare = Utils.getGenericComparator( asc );
                    return function( a, b ) {
                        return compare( a[ key ], b[ key ] )
                    }
                };
                Utils.getGenericComparator = function( asc ) {
                    asc = asc !== false;
                    return function( a, b ) {
                        var retn = 0;
                        if ( b == null ) {
                            retn = a == null ? 0 : -1
                        } else if ( a == null ) {
                            retn = 1
                        } else if ( a < b ) {
                            retn = asc ? -1 : 1
                        } else if ( a > b ) {
                            retn = asc ? 1 : -1
                        } else if ( a !== a ) {
                            retn = 1
                        } else if ( b !== b ) {
                            retn = -1
                        }
                        return retn
                    }
                };
                Utils.quicksort = function( arr, asc ) {
                    Utils.quicksortPartition( arr, 0, arr.length - 1 );
                    if ( asc === false ) Array.prototype.reverse.call( arr );
                    return arr
                };
                Utils.quicksortPartition = function( a, lo, hi ) {
                    var i = lo,
                        j = hi,
                        pivot, tmp;
                    while ( i < hi ) {
                        pivot = a[ lo + hi >> 1 ];
                        while ( i <= j ) {
                            while ( a[ i ] < pivot ) i++;
                            while ( a[ j ] > pivot ) j--;
                            if ( i <= j ) {
                                tmp = a[ i ];
                                a[ i ] = a[ j ];
                                a[ j ] = tmp;
                                i++;
                                j--
                            }
                        }
                        if ( lo < j ) Utils.quicksortPartition( a, lo, j );
                        lo = i;
                        j = hi
                    }
                };
                Utils.findRankByValue = function( arr, value ) {
                    if ( isNaN( value ) ) return arr.length;
                    var rank = 1;
                    for ( var i = 0, n = arr.length; i < n; i++ ) {
                        if ( value > arr[ i ] ) rank++
                    }
                    return rank
                };
                Utils.findValueByPct = function( arr, pct ) {
                    var rank = Math.ceil( ( 1 - pct ) * arr.length );
                    return Utils.findValueByRank( arr, rank )
                };
                Utils.findValueByRank = function( arr, rank ) {
                    if ( !arr.length || rank < 1 || rank > arr.length ) error( "[findValueByRank()] invalid input" );
                    rank = Utils.clamp( rank | 0, 1, arr.length );
                    var k = rank - 1,
                        n = arr.length,
                        l = 0,
                        m = n - 1,
                        i, j, val, tmp;
                    while ( l < m ) {
                        val = arr[ k ];
                        i = l;
                        j = m;
                        do {
                            while ( arr[ i ] < val ) {
                                i++
                            }
                            while ( val < arr[ j ] ) {
                                j--
                            }
                            if ( i <= j ) {
                                tmp = arr[ i ];
                                arr[ i ] = arr[ j ];
                                arr[ j ] = tmp;
                                i++;
                                j--
                            }
                        } while ( i <= j );
                        if ( j < k ) l = i;
                        if ( k < i ) m = j
                    }
                    return arr[ k ]
                };
                Utils.findMedian = function( arr ) {
                    var n = arr.length,
                        rank = Math.floor( n / 2 ) + 1,
                        median = Utils.findValueByRank( arr, rank );
                    if ( ( n & 1 ) == 0 ) {
                        median = ( median + Utils.findValueByRank( arr, rank - 1 ) ) / 2
                    }
                    return median
                };
                Utils.mean = function( arr ) {
                    var count = 0,
                        avg = NaN,
                        val;
                    for ( var i = 0, n = arr.length; i < n; i++ ) {
                        val = arr[ i ];
                        if ( isNaN( val ) ) continue;
                        avg = ++count == 1 ? val : val / count + ( count - 1 ) / count * avg
                    }
                    return avg
                };

                function BinArray( buf, le ) {
                    if ( Utils.isNumber( buf ) ) {
                        buf = new ArrayBuffer( buf )
                    } else if ( typeof Buffer == "function" && buf instanceof Buffer ) {
                        buf = BinArray.toArrayBuffer( buf )
                    }
                    if ( buf instanceof ArrayBuffer == false ) {
                        error( "BinArray constructor takes an integer, ArrayBuffer or Buffer argument" )
                    }
                    this._buffer = buf;
                    this._bytes = new Uint8Array( buf );
                    this._view = new DataView( buf );
                    this._idx = 0;
                    this._le = le !== false
                }
                BinArray.bufferToUintArray = function( buf, wordLen ) {
                    if ( wordLen == 4 ) return new Uint32Array( buf );
                    if ( wordLen == 2 ) return new Uint16Array( buf );
                    if ( wordLen == 1 ) return new Uint8Array( buf );
                    error( "BinArray.bufferToUintArray() invalid word length:", wordLen )
                };
                BinArray.uintSize = function( i ) {
                    return i & 1 || i & 2 || 4
                };
                BinArray.bufferCopy = function( dest, destId, src, srcId, bytes ) {
                    srcId = srcId || 0;
                    bytes = bytes || src.byteLength - srcId;
                    if ( dest.byteLength - destId < bytes ) error( "Buffer overflow; tried to write:", bytes );
                    var wordSize = Math.min( BinArray.uintSize( bytes ), BinArray.uintSize( srcId ), BinArray.uintSize( dest.byteLength ), BinArray.uintSize( destId ), BinArray.uintSize( src.byteLength ) );
                    var srcArr = BinArray.bufferToUintArray( src, wordSize ),
                        destArr = BinArray.bufferToUintArray( dest, wordSize ),
                        count = bytes / wordSize,
                        i = srcId / wordSize,
                        j = destId / wordSize;
                    while ( count-- ) {
                        destArr[ j++ ] = srcArr[ i++ ]
                    }
                    return bytes
                };
                BinArray.toArrayBuffer = function( src ) {
                    var n = src.length,
                        dest = new ArrayBuffer( n ),
                        view = new Uint8Array( dest );
                    for ( var i = 0; i < n; i++ ) {
                        view[ i ] = src[ i ]
                    }
                    return dest
                };
                BinArray.bufferSize = function( buf ) {
                    return buf instanceof ArrayBuffer ? buf.byteLength : buf.length | 0
                };
                Utils.buffersAreIdentical = function( a, b ) {
                    var alen = BinArray.bufferSize( a );
                    var blen = BinArray.bufferSize( b );
                    if ( alen != blen ) {
                        return false
                    }
                    for ( var i = 0; i < alen; i++ ) {
                        if ( a[ i ] !== b[ i ] ) {
                            return false
                        }
                    }
                    return true
                };
                BinArray.prototype = {
                    size: function() {
                        return this._buffer.byteLength
                    },
                    littleEndian: function() {
                        this._le = true;
                        return this
                    },
                    bigEndian: function() {
                        this._le = false;
                        return this
                    },
                    buffer: function() {
                        return this._buffer
                    },
                    bytesLeft: function() {
                        return this._buffer.byteLength - this._idx
                    },
                    skipBytes: function( bytes ) {
                        this._idx += bytes + 0;
                        return this
                    },
                    readUint8: function() {
                        return this._bytes[ this._idx++ ]
                    },
                    writeUint8: function( val ) {
                        this._bytes[ this._idx++ ] = val;
                        return this
                    },
                    readInt8: function() {
                        return this._view.getInt8( this._idx++ )
                    },
                    writeInt8: function( val ) {
                        this._view.setInt8( this._idx++, val );
                        return this
                    },
                    readUint16: function() {
                        var val = this._view.getUint16( this._idx, this._le );
                        this._idx += 2;
                        return val
                    },
                    writeUint16: function( val ) {
                        this._view.setUint16( this._idx, val, this._le );
                        this._idx += 2;
                        return this
                    },
                    readUint32: function() {
                        var val = this._view.getUint32( this._idx, this._le );
                        this._idx += 4;
                        return val
                    },
                    writeUint32: function( val ) {
                        this._view.setUint32( this._idx, val, this._le );
                        this._idx += 4;
                        return this
                    },
                    readInt32: function() {
                        var val = this._view.getInt32( this._idx, this._le );
                        this._idx += 4;
                        return val
                    },
                    writeInt32: function( val ) {
                        this._view.setInt32( this._idx, val, this._le );
                        this._idx += 4;
                        return this
                    },
                    readFloat64: function() {
                        var val = this._view.getFloat64( this._idx, this._le );
                        this._idx += 8;
                        return val
                    },
                    writeFloat64: function( val ) {
                        this._view.setFloat64( this._idx, val, this._le );
                        this._idx += 8;
                        return this
                    },
                    readFloat64Array: function( len ) {
                        var bytes = len * 8,
                            i = this._idx,
                            buf = this._buffer,
                            arr;
                        if ( i % 8 === 0 ) {
                            arr = new Float64Array( buf, i, len )
                        } else if ( buf.slice ) {
                            arr = new Float64Array( buf.slice( i, i + bytes ) )
                        } else {
                            var dest = new ArrayBuffer( bytes );
                            BinArray.bufferCopy( dest, 0, buf, i, bytes );
                            arr = new Float64Array( dest )
                        }
                        this._idx += bytes;
                        return arr
                    },
                    readUint32Array: function( len ) {
                        var arr = [];
                        for ( var i = 0; i < len; i++ ) {
                            arr.push( this.readUint32() )
                        }
                        return arr
                    },
                    peek: function( i ) {
                        return this._view.getUint8( i >= 0 ? i : this._idx )
                    },
                    position: function( i ) {
                        if ( i != null ) {
                            this._idx = i;
                            return this
                        }
                        return this._idx
                    },
                    readCString: function( fixedLen, asciiOnly ) {
                        var str = "",
                            count = fixedLen >= 0 ? fixedLen : this.bytesLeft();
                        while ( count > 0 ) {
                            var byteVal = this.readUint8();
                            count--;
                            if ( byteVal == 0 ) {
                                break
                            } else if ( byteVal > 127 && asciiOnly ) {
                                str = null;
                                break
                            }
                            str += String.fromCharCode( byteVal )
                        }
                        if ( fixedLen > 0 && count > 0 ) {
                            this.skipBytes( count )
                        }
                        return str
                    },
                    writeString: function( str, maxLen ) {
                        var bytesWritten = 0,
                            charsToWrite = str.length,
                            cval;
                        if ( maxLen ) {
                            charsToWrite = Math.min( charsToWrite, maxLen )
                        }
                        for ( var i = 0; i < charsToWrite; i++ ) {
                            cval = str.charCodeAt( i );
                            if ( cval > 127 ) {
                                trace( "#writeCString() Unicode value beyond ascii range" );
                                cval = "?".charCodeAt( 0 )
                            }
                            this.writeUint8( cval );
                            bytesWritten++
                        }
                        return bytesWritten
                    },
                    writeCString: function( str, fixedLen ) {
                        var maxChars = fixedLen ? fixedLen - 1 : null,
                            bytesWritten = this.writeString( str, maxChars );
                        this.writeUint8( 0 );
                        bytesWritten++;
                        if ( fixedLen ) {
                            while ( bytesWritten < fixedLen ) {
                                this.writeUint8( 0 );
                                bytesWritten++
                            }
                        }
                        return this
                    },
                    writeBuffer: function( buf, bytes, startIdx ) {
                        this._idx += BinArray.bufferCopy( this._buffer, this._idx, buf, startIdx, bytes );
                        return this
                    }
                };
                Utils.format = function( fmt ) {
                    var fn = Utils.formatter( fmt );
                    var str = fn.apply( null, Array.prototype.slice.call( arguments, 1 ) );
                    return str
                };

                function formatValue( val, matches ) {
                    var flags = matches[ 1 ];
                    var padding = matches[ 2 ];
                    var decimals = matches[ 3 ] ? parseInt( matches[ 3 ].substr( 1 ) ) : void 0;
                    var type = matches[ 4 ];
                    var isString = type == "s",
                        isHex = type == "x" || type == "X",
                        isInt = type == "d" || type == "i",
                        isFloat = type == "f",
                        isNumber = !isString;
                    var sign = "",
                        padDigits = 0,
                        isZero = false,
                        isNeg = false;
                    var str;
                    if ( isString ) {
                        str = String( val )
                    } else if ( isHex ) {
                        str = val.toString( 16 );
                        if ( type == "X" ) str = str.toUpperCase()
                    } else if ( isNumber ) {
                        str = Utils.numToStr( val, isInt ? 0 : decimals );
                        if ( str[ 0 ] == "-" ) {
                            isNeg = true;
                            str = str.substr( 1 )
                        }
                        isZero = parseFloat( str ) == 0;
                        if ( flags.indexOf( "'" ) != -1 || flags.indexOf( "," ) != -1 ) {
                            str = Utils.addThousandsSep( str )
                        }
                        if ( !isZero ) {
                            if ( isNeg ) {
                                sign = ""
                            } else if ( flags.indexOf( "+" ) != -1 ) {
                                sign = "+"
                            }
                        }
                    }
                    if ( padding ) {
                        var strLen = str.length + sign.length;
                        var minWidth = parseInt( padding, 10 );
                        if ( strLen < minWidth ) {
                            padDigits = minWidth - strLen;
                            var padChar = flags.indexOf( "0" ) == -1 ? " " : "0";
                            var padStr = Utils.repeatString( padChar, padDigits )
                        }
                    }
                    if ( padDigits == 0 ) {
                        str = sign + str
                    } else if ( padChar == "0" ) {
                        str = sign + padStr + str
                    } else {
                        str = padStr + sign + str
                    }
                    return str
                }
                Utils.formatter = function( fmt ) {
                    var codeRxp = /%([\',+0]*)([1-9]?)((?:\.[1-9])?)([sdifxX%])/g;
                    var literals = [],
                        formatCodes = [],
                        startIdx = 0,
                        prefix = "",
                        literal, matches;
                    while ( matches = codeRxp.exec( fmt ) ) {
                        literal = fmt.substring( startIdx, codeRxp.lastIndex - matches[ 0 ].length );
                        if ( matches[ 0 ] == "%%" ) {
                            prefix += literal + "%"
                        } else {
                            literals.push( prefix + literal );
                            prefix = "";
                            formatCodes.push( matches )
                        }
                        startIdx = codeRxp.lastIndex
                    }
                    literals.push( prefix + fmt.substr( startIdx ) );
                    return function() {
                        var str = literals[ 0 ],
                            n = arguments.length;
                        if ( n != formatCodes.length ) {
                            error( "[format()] Data does not match format string; format:", fmt, "data:", arguments )
                        }
                        for ( var i = 0; i < n; i++ ) {
                            str += formatValue( arguments[ i ], formatCodes[ i ] ) + literals[ i + 1 ]
                        }
                        return str
                    }
                };
                utils.wildcardToRegExp = function( name ) {
                    var rxp = name.split( "*" ).map( function( str ) {
                        return utils.regexEscape( str )
                    } ).join( ".*" );
                    return new RegExp( "^" + rxp + "$" )
                };
                utils.expandoBuffer = function( constructor, rate ) {
                    var capacity = 0,
                        k = rate >= 1 ? rate : 1.2,
                        buf;
                    return function( size ) {
                        if ( size > capacity ) {
                            capacity = Math.ceil( size * k );
                            buf = new constructor( capacity )
                        }
                        return buf
                    }
                };
                utils.copyElements = function( src, i, dest, j, n, rev ) {
                    if ( src === dest && j > i ) error( "copy error" );
                    var inc = 1,
                        offs = 0;
                    if ( rev ) {
                        inc = -1;
                        offs = n - 1
                    }
                    for ( var k = 0; k < n; k++, offs += inc ) {
                        dest[ k + j ] = src[ i + offs ]
                    }
                };
                utils.extendBuffer = function( src, newLen, copyLen ) {
                    var len = Math.max( src.length, newLen );
                    var n = copyLen || src.length;
                    var dest = new src.constructor( len );
                    utils.copyElements( src, 0, dest, 0, n );
                    return dest
                };
                utils.mergeNames = function( name1, name2 ) {
                    var merged = "";
                    if ( name1 && name2 ) {
                        merged = utils.findStringPrefix( name1, name2 ).replace( /[-_]$/, "" )
                    }
                    return merged
                };
                utils.findStringPrefix = function( a, b ) {
                    var i = 0;
                    for ( var n = a.length; i < n; i++ ) {
                        if ( a[ i ] !== b[ i ] ) break
                    }
                    return a.substr( 0, i )
                };
                utils.isFiniteNumber = function( val ) {
                    return val === 0 || !!val && val.constructor == Number && val !== Infinity && val !== -Infinity
                };
                utils.parsePercent = function( o ) {
                    var str = String( o );
                    var isPct = str.indexOf( "%" ) > 0;
                    var pct;
                    if ( isPct ) {
                        pct = Number( str.replace( "%", "" ) ) / 100
                    } else {
                        pct = Number( str )
                    }
                    if ( !( pct >= 0 && pct <= 1 ) ) {
                        error( utils.format( "Invalid pct value: %s", str ) )
                    }
                    return pct
                };
                var api = {};
                var MapShaper = {
                    VERSION: VERSION,
                    LOGGING: false,
                    TRACING: false,
                    VERBOSE: false
                };
                new Float64Array( 1 );
                var Buffer = require( "buffer" ).Buffer;

                function error() {
                    MapShaper.error.apply( null, utils.toArray( arguments ) )
                }

                function stop() {
                    MapShaper.stop.apply( null, utils.toArray( arguments ) )
                }

                function APIError( msg ) {
                    var err = new Error( msg );
                    err.name = "APIError";
                    return err
                }

                function message() {
                    MapShaper.message.apply( null, utils.toArray( arguments ) )
                }

                function verbose() {
                    if ( MapShaper.VERBOSE && MapShaper.LOGGING ) {
                        MapShaper.logArgs( arguments )
                    }
                }

                function trace() {
                    if ( MapShaper.TRACING ) {
                        MapShaper.logArgs( arguments )
                    }
                }

                function absArcId( arcId ) {
                    return arcId >= 0 ? arcId : ~arcId
                }
                api.enableLogging = function() {
                    MapShaper.LOGGING = true;
                    return api
                };
                api.printError = function( err ) {
                    var msg;
                    if ( utils.isString( err ) ) {
                        err = new APIError( err )
                    }
                    if ( MapShaper.LOGGING && err.name == "APIError" ) {
                        msg = err.message;
                        if ( !/Error/.test( msg ) ) {
                            msg = "Error: " + msg
                        }
                        message( msg );
                        message( "Run mapshaper -h to view help" )
                    } else {
                        throw err
                    }
                };
                MapShaper.error = function() {
                    var msg = Utils.toArray( arguments ).join( " " );
                    throw new Error( msg )
                };
                MapShaper.stop = function() {
                    throw new APIError( MapShaper.formatLogArgs( arguments ) )
                };
                MapShaper.message = function() {
                    if ( MapShaper.LOGGING ) {
                        MapShaper.logArgs( arguments )
                    }
                };
                MapShaper.formatLogArgs = function( args ) {
                    return utils.toArray( args ).join( " " )
                };
                MapShaper.formatStringsAsGrid = function( arr ) {
                    var longest = arr.reduce( function( len, str ) {
                            return Math.max( len, str.length )
                        }, 0 ),
                        colWidth = longest + 2,
                        perLine = Math.floor( 80 / colWidth ) || 1;
                    return arr.reduce( function( memo, name, i ) {
                        var col = i % perLine;
                        if ( i > 0 && col === 0 ) memo += "\n";
                        if ( col < perLine - 1 ) {
                            name = utils.rpad( name, colWidth - 2, " " )
                        }
                        return memo + "  " + name
                    }, "" )
                };
                MapShaper.logArgs = function( args ) {
                    if ( utils.isArrayLike( args ) ) {
                        ( console.error || console.log ).call( console, MapShaper.formatLogArgs( args ) )
                    }
                };
                MapShaper.getWorldBounds = function( e ) {
                    e = utils.isFiniteNumber( e ) ? e : 1e-10;
                    return [ -180 + e, -90 + e, 180 - e, 90 - e ]
                };
                MapShaper.probablyDecimalDegreeBounds = function( b ) {
                    var world = MapShaper.getWorldBounds( -1 ),
                        bbox = b instanceof Bounds ? b.toArray() : b;
                    return containsBounds( world, bbox )
                };
                MapShaper.layerHasGeometry = function( lyr ) {
                    return MapShaper.layerHasPaths( lyr ) || MapShaper.layerHasPoints( lyr )
                };
                MapShaper.layerHasPaths = function( lyr ) {
                    return ( lyr.geometry_type == "polygon" || lyr.geometry_type == "polyline" ) && MapShaper.layerHasNonNullShapes( lyr )
                };
                MapShaper.layerHasPoints = function( lyr ) {
                    return lyr.geometry_type == "point" && MapShaper.layerHasNonNullShapes( lyr )
                };
                MapShaper.layerHasNonNullShapes = function( lyr ) {
                    return utils.some( lyr.shapes || [], function( shp ) {
                        return !!shp
                    } )
                };
                MapShaper.requireDataFields = function( table, fields, cmd ) {
                    var prefix = cmd ? "[" + cmd + "] " : "";
                    if ( !table ) {
                        stop( prefix + "Missing attribute data" )
                    }
                    var dataFields = table.getFields(),
                        missingFields = utils.difference( fields, dataFields );
                    if ( missingFields.length > 0 ) {
                        stop( prefix + "Table is missing one or more fields:\n", missingFields, "\nExisting fields:", "\n" + MapShaper.formatStringsAsGrid( dataFields ) )
                    }
                };
                MapShaper.requirePolygonLayer = function( lyr, msg ) {
                    if ( !lyr || lyr.geometry_type !== "polygon" ) stop( msg || "Expected a polygon layer" )
                };
                MapShaper.requirePathLayer = function( lyr, msg ) {
                    if ( !lyr || !MapShaper.layerHasPaths( lyr ) ) stop( msg || "Expected a polygon or polyline layer" )
                };
                var R = 6378137;
                var D2R = Math.PI / 180;

                function degreesToMeters( deg ) {
                    return deg * D2R * R
                }

                function distance3D( ax, ay, az, bx, by, bz ) {
                    var dx = ax - bx,
                        dy = ay - by,
                        dz = az - bz;
                    return Math.sqrt( dx * dx + dy * dy + dz * dz )
                }

                function distanceSq( ax, ay, bx, by ) {
                    var dx = ax - bx,
                        dy = ay - by;
                    return dx * dx + dy * dy
                }

                function distance2D( ax, ay, bx, by ) {
                    var dx = ax - bx,
                        dy = ay - by;
                    return Math.sqrt( dx * dx + dy * dy )
                }

                function distanceSq3D( ax, ay, az, bx, by, bz ) {
                    var dx = ax - bx,
                        dy = ay - by,
                        dz = az - bz;
                    return dx * dx + dy * dy + dz * dz
                }

                function getRoundingFunction( inc ) {
                    if ( !utils.isNumber( inc ) || inc === 0 ) {
                        error( "Rounding increment must be a non-zero number." )
                    }
                    var inv = 1 / inc;
                    if ( inv > 1 ) inv = Math.round( inv );
                    return function( x ) {
                        return Math.round( x * inv ) / inv
                    }
                }

                function nearestPoint( x, y, x0, y0 ) {
                    var minIdx = -1,
                        minDist = Infinity,
                        dist;
                    for ( var i = 0, j = 2, n = arguments.length; j < n; i++, j += 2 ) {
                        dist = distanceSq( x, y, arguments[ j ], arguments[ j + 1 ] );
                        if ( dist < minDist ) {
                            minDist = dist;
                            minIdx = i
                        }
                    }
                    return minIdx
                }

                function innerAngle2( ax, ay, bx, by, cx, cy ) {
                    var a1 = Math.atan2( ay - by, ax - bx ),
                        a2 = Math.atan2( cy - by, cx - bx ),
                        a3 = Math.abs( a1 - a2 );
                    if ( a3 > Math.PI ) {
                        a3 = 2 * Math.PI - a3
                    }
                    return a3
                }

                function standardAngle( a ) {
                    var twoPI = Math.PI * 2;
                    while ( a < 0 ) {
                        a += twoPI
                    }
                    while ( a >= twoPI ) {
                        a -= twoPI
                    }
                    return a
                }

                function signedAngle( ax, ay, bx, by, cx, cy ) {
                    if ( ax == bx && ay == by || bx == cx && by == cy ) {
                        return NaN
                    }
                    var abx = ax - bx,
                        aby = ay - by,
                        cbx = cx - bx,
                        cby = cy - by,
                        dotp = abx * cbx + aby * cby,
                        crossp = abx * cby - aby * cbx,
                        a = Math.atan2( crossp, dotp );
                    return standardAngle( a )
                }

                function bearing( lng1, lat1, lng2, lat2 ) {
                    var D2R = Math.PI / 180;
                    lng1 *= D2R;
                    lng2 *= D2R;
                    lat1 *= D2R;
                    lat2 *= D2R;
                    var y = Math.sin( lng2 - lng1 ) * Math.cos( lat2 ),
                        x = Math.cos( lat1 ) * Math.sin( lat2 ) - Math.sin( lat1 ) * Math.cos( lat2 ) * Math.cos( lng2 - lng1 );
                    return Math.atan2( y, x )
                }

                function signedAngleSph( alng, alat, blng, blat, clng, clat ) {
                    if ( alng == blng && alat == blat || blng == clng && blat == clat ) {
                        return NaN
                    }
                    var b1 = bearing( blng, blat, alng, alat ),
                        b2 = bearing( blng, blat, clng, clat ),
                        a = Math.PI * 2 + b1 - b2;
                    return standardAngle( a )
                }

                function convLngLatToSph( xsrc, ysrc, xbuf, ybuf, zbuf ) {
                    var p = [];
                    for ( var i = 0, len = xsrc.length; i < len; i++ ) {
                        lngLatToXYZ( xsrc[ i ], ysrc[ i ], p );
                        xbuf[ i ] = p[ 0 ];
                        ybuf[ i ] = p[ 1 ];
                        zbuf[ i ] = p[ 2 ]
                    }
                }

                function xyzToLngLat( x, y, z, p ) {
                    var d = distance3D( 0, 0, 0, x, y, z );
                    var lat = Math.asin( z / d ) / D2R;
                    var lng = Math.atan2( y / d, x / d ) / D2R;
                    p[ 0 ] = lng;
                    p[ 1 ] = lat
                }

                function lngLatToXYZ( lng, lat, p ) {
                    var cosLat;
                    lng *= D2R;
                    lat *= D2R;
                    cosLat = Math.cos( lat );
                    p[ 0 ] = Math.cos( lng ) * cosLat * R;
                    p[ 1 ] = Math.sin( lng ) * cosLat * R;
                    p[ 2 ] = Math.sin( lat ) * R
                }

                function sphericalDistance( lam1, phi1, lam2, phi2 ) {
                    var dlam = lam2 - lam1,
                        dphi = phi2 - phi1,
                        a = Math.sin( dphi / 2 ) * Math.sin( dphi / 2 ) + Math.cos( phi1 ) * Math.cos( phi2 ) * Math.sin( dlam / 2 ) * Math.sin( dlam / 2 ),
                        c = 2 * Math.atan2( Math.sqrt( a ), Math.sqrt( 1 - a ) );
                    return c
                }

                function greatCircleDistance( lng1, lat1, lng2, lat2 ) {
                    var D2R = Math.PI / 180,
                        dist = sphericalDistance( lng1 * D2R, lat1 * D2R, lng2 * D2R, lat2 * D2R );
                    return dist * R
                }

                function innerAngle( ax, ay, bx, by, cx, cy ) {
                    var ab = distance2D( ax, ay, bx, by ),
                        bc = distance2D( bx, by, cx, cy ),
                        theta, dotp;
                    if ( ab === 0 || bc === 0 ) {
                        theta = 0
                    } else {
                        dotp = ( ( ax - bx ) * ( cx - bx ) + ( ay - by ) * ( cy - by ) ) / ( ab * bc );
                        if ( dotp >= 1 - 1e-14 ) {
                            theta = 0
                        } else if ( dotp <= -1 + 1e-14 ) {
                            theta = Math.PI
                        } else {
                            theta = Math.acos( dotp )
                        }
                    }
                    return theta
                }

                function innerAngle3D( ax, ay, az, bx, by, bz, cx, cy, cz ) {
                    var ab = distance3D( ax, ay, az, bx, by, bz ),
                        bc = distance3D( bx, by, bz, cx, cy, cz ),
                        theta, dotp;
                    if ( ab === 0 || bc === 0 ) {
                        theta = 0
                    } else {
                        dotp = ( ( ax - bx ) * ( cx - bx ) + ( ay - by ) * ( cy - by ) + ( az - bz ) * ( cz - bz ) ) / ( ab * bc );
                        if ( dotp >= 1 ) {
                            theta = 0
                        } else if ( dotp <= -1 ) {
                            theta = Math.PI
                        } else {
                            theta = Math.acos( dotp )
                        }
                    }
                    return theta
                }

                function triangleArea( ax, ay, bx, by, cx, cy ) {
                    var area = Math.abs( ( ( ay - cy ) * ( bx - cx ) + ( by - cy ) * ( cx - ax ) ) / 2 );
                    return area
                }

                function detSq( ax, ay, bx, by, cx, cy ) {
                    var det = ax * by - ax * cy + bx * cy - bx * ay + cx * ay - cx * by;
                    return det * det
                }

                function cosine( ax, ay, bx, by, cx, cy ) {
                    var den = distance2D( ax, ay, bx, by ) * distance2D( bx, by, cx, cy ),
                        cos = 0;
                    if ( den > 0 ) {
                        cos = ( ( ax - bx ) * ( cx - bx ) + ( ay - by ) * ( cy - by ) ) / den;
                        if ( cos > 1 ) cos = 1;
                        else if ( cos < -1 ) cos = -1
                    }
                    return cos
                }

                function cosine3D( ax, ay, az, bx, by, bz, cx, cy, cz ) {
                    var den = distance3D( ax, ay, az, bx, by, bz ) * distance3D( bx, by, bz, cx, cy, cz ),
                        cos = 0;
                    if ( den > 0 ) {
                        cos = ( ( ax - bx ) * ( cx - bx ) + ( ay - by ) * ( cy - by ) + ( az - bz ) * ( cz - bz ) ) / den;
                        if ( cos > 1 ) cos = 1;
                        else if ( cos < -1 ) cos = -1
                    }
                    return cos
                }

                function triangleArea3D( ax, ay, az, bx, by, bz, cx, cy, cz ) {
                    var area = .5 * Math.sqrt( detSq( ax, ay, bx, by, cx, cy ) + detSq( ax, az, bx, bz, cx, cz ) + detSq( ay, az, by, bz, cy, cz ) );
                    return area
                }

                function apexDistSq( ab2, bc2, ac2 ) {
                    var dist2;
                    if ( ac2 === 0 ) {
                        dist2 = ab2
                    } else if ( ab2 >= bc2 + ac2 ) {
                        dist2 = bc2
                    } else if ( bc2 >= ab2 + ac2 ) {
                        dist2 = ab2
                    } else {
                        var dval = ab2 + ac2 - bc2;
                        dist2 = ab2 - dval * dval / ac2 * .25
                    }
                    if ( dist2 < 0 ) {
                        dist2 = 0
                    }
                    return dist2
                }

                function pointSegDistSq( ax, ay, bx, by, cx, cy ) {
                    var ab2 = distanceSq( ax, ay, bx, by ),
                        ac2 = distanceSq( ax, ay, cx, cy ),
                        bc2 = distanceSq( bx, by, cx, cy );
                    return apexDistSq( ab2, ac2, bc2 )
                }

                function pointSegDistSq3D( ax, ay, az, bx, by, bz, cx, cy, cz ) {
                    var ab2 = distanceSq3D( ax, ay, az, bx, by, bz ),
                        ac2 = distanceSq3D( ax, ay, az, cx, cy, cz ),
                        bc2 = distanceSq3D( bx, by, bz, cx, cy, cz );
                    return apexDistSq( ab2, ac2, bc2 )
                }
                MapShaper.calcArcBounds = function( xx, yy, start, len ) {
                    var i = start | 0,
                        n = isNaN( len ) ? xx.length - i : len + i,
                        x, y, xmin, ymin, xmax, ymax;
                    if ( n > 0 ) {
                        xmin = xmax = xx[ i ];
                        ymin = ymax = yy[ i ]
                    }
                    for ( i++; i < n; i++ ) {
                        x = xx[ i ];
                        y = yy[ i ];
                        if ( x < xmin ) xmin = x;
                        if ( x > xmax ) xmax = x;
                        if ( y < ymin ) ymin = y;
                        if ( y > ymax ) ymax = y
                    }
                    return [ xmin, ymin, xmax, ymax ]
                };
                MapShaper.reversePathCoords = function( arr, start, len ) {
                    var i = start,
                        j = start + len - 1,
                        tmp;
                    while ( i < j ) {
                        tmp = arr[ i ];
                        arr[ i ] = arr[ j ];
                        arr[ j ] = tmp;
                        i++;
                        j--
                    }
                };

                function mergeBounds( a, b ) {
                    if ( b[ 0 ] < a[ 0 ] ) a[ 0 ] = b[ 0 ];
                    if ( b[ 1 ] < a[ 1 ] ) a[ 1 ] = b[ 1 ];
                    if ( b[ 2 ] > a[ 2 ] ) a[ 2 ] = b[ 2 ];
                    if ( b[ 3 ] > a[ 3 ] ) a[ 3 ] = b[ 3 ]
                }

                function containsBounds( a, b ) {
                    return a[ 0 ] <= b[ 0 ] && a[ 2 ] >= b[ 2 ] && a[ 1 ] <= b[ 1 ] && a[ 3 ] >= b[ 3 ]
                }

                function boundsArea( b ) {
                    return ( b[ 2 ] - b[ 0 ] ) * ( b[ 3 ] - b[ 1 ] )
                }
                var geom = {
                    R: R,
                    D2R: D2R,
                    degreesToMeters: degreesToMeters,
                    getRoundingFunction: getRoundingFunction,
                    segmentHit: segmentHit,
                    segmentIntersection: segmentIntersection,
                    distanceSq: distanceSq,
                    distance2D: distance2D,
                    distance3D: distance3D,
                    innerAngle: innerAngle,
                    innerAngle2: innerAngle2,
                    signedAngle: signedAngle,
                    bearing: bearing,
                    signedAngleSph: signedAngleSph,
                    standardAngle: standardAngle,
                    convLngLatToSph: convLngLatToSph,
                    lngLatToXYZ: lngLatToXYZ,
                    xyzToLngLat: xyzToLngLat,
                    sphericalDistance: sphericalDistance,
                    greatCircleDistance: greatCircleDistance,
                    pointSegDistSq: pointSegDistSq,
                    pointSegDistSq3D: pointSegDistSq3D,
                    innerAngle3D: innerAngle3D,
                    triangleArea: triangleArea,
                    triangleArea3D: triangleArea3D,
                    cosine: cosine,
                    cosine3D: cosine3D
                };

                function ArcIter( xx, yy ) {
                    this._i = 0;
                    this._n = 0;
                    this._inc = 1;
                    this._xx = xx;
                    this._yy = yy;
                    this.i = 0;
                    this.x = 0;
                    this.y = 0
                }
                ArcIter.prototype.init = function( i, len, fw ) {
                    if ( fw ) {
                        this._i = i;
                        this._inc = 1
                    } else {
                        this._i = i + len - 1;
                        this._inc = -1
                    }
                    this._n = len;
                    return this
                };
                ArcIter.prototype.hasNext = function() {
                    var i = this._i;
                    if ( this._n > 0 ) {
                        this._i = i + this._inc;
                        this.x = this._xx[ i ];
                        this.y = this._yy[ i ];
                        this.i = i;
                        this._n--;
                        return true
                    }
                    return false
                };

                function FilteredArcIter( xx, yy, zz ) {
                    var _zlim = 0,
                        _i = 0,
                        _inc = 1,
                        _stop = 0;
                    this.init = function( i, len, fw, zlim ) {
                        _zlim = zlim || 0;
                        if ( fw ) {
                            _i = i;
                            _inc = 1;
                            _stop = i + len
                        } else {
                            _i = i + len - 1;
                            _inc = -1;
                            _stop = i - 1
                        }
                        return this
                    };
                    this.hasNext = function() {
                        var zarr = zz,
                            i = _i,
                            j = i,
                            zlim = _zlim,
                            stop = _stop,
                            inc = _inc;
                        if ( i == stop ) return false;
                        do {
                            j += inc
                        } while ( j != stop && zarr[ j ] < zlim );
                        _i = j;
                        this.x = xx[ i ];
                        this.y = yy[ i ];
                        this.i = i;
                        return true
                    }
                }

                function ShapeIter( arcs ) {
                    this._arcs = arcs;
                    this._i = 0;
                    this._n = 0;
                    this.x = 0;
                    this.y = 0
                }
                ShapeIter.prototype.hasNext = function() {
                    var arc = this._arc;
                    if ( this._i < this._n === false ) {
                        return false
                    }
                    if ( arc.hasNext() ) {
                        this.x = arc.x;
                        this.y = arc.y;
                        return true
                    }
                    this.nextArc();
                    return this.hasNext()
                };
                ShapeIter.prototype.init = function( ids ) {
                    this._ids = ids;
                    this._n = ids.length;
                    this.reset();
                    return this
                };
                ShapeIter.prototype.nextArc = function() {
                    var i = this._i + 1;
                    if ( i < this._n ) {
                        this._arc = this._arcs.getArcIter( this._ids[ i ] );
                        if ( i > 0 ) this._arc.hasNext()
                    }
                    this._i = i
                };
                ShapeIter.prototype.reset = function() {
                    this._i = -1;
                    this.nextArc()
                };

                function ArcCollection() {
                    var _xx, _yy, _ii, _nn, _zz, _zlimit = 0,
                        _bb, _allBounds, _arcIter, _filteredArcIter;
                    if ( arguments.length == 1 ) {
                        initLegacyArcs( arguments[ 0 ] )
                    } else if ( arguments.length == 3 ) {
                        initXYData.apply( this, arguments )
                    } else {
                        error( "ArcCollection() Invalid arguments" )
                    }

                    function initLegacyArcs( arcs ) {
                        var xx = [],
                            yy = [];
                        var nn = arcs.map( function( points ) {
                            var n = points ? points.length : 0;
                            for ( var i = 0; i < n; i++ ) {
                                xx.push( points[ i ][ 0 ] );
                                yy.push( points[ i ][ 1 ] )
                            }
                            return n
                        } );
                        initXYData( nn, xx, yy )
                    }

                    function initXYData( nn, xx, yy ) {
                        var size = nn.length;
                        if ( nn instanceof Array ) nn = new Uint32Array( nn );
                        if ( xx instanceof Array ) xx = new Float64Array( xx );
                        if ( yy instanceof Array ) yy = new Float64Array( yy );
                        _xx = xx;
                        _yy = yy;
                        _nn = nn;
                        _zz = null;
                        _zlimit = 0;
                        _filteredArcIter = null;
                        _ii = new Uint32Array( size );
                        for ( var idx = 0, j = 0; j < size; j++ ) {
                            _ii[ j ] = idx;
                            idx += nn[ j ]
                        }
                        if ( idx != _xx.length || _xx.length != _yy.length ) {
                            error( "ArcCollection#initXYData() Counting error" )
                        }
                        initBounds();
                        _arcIter = new ArcIter( _xx, _yy );
                        return this
                    }

                    function initZData( zz ) {
                        if ( !zz ) {
                            _zz = null;
                            _zlimit = 0;
                            _filteredArcIter = null
                        } else {
                            if ( zz.length != _xx.length ) error( "ArcCollection#initZData() mismatched arrays" );
                            if ( zz instanceof Array ) zz = new Float64Array( zz );
                            _zz = zz;
                            _filteredArcIter = new FilteredArcIter( _xx, _yy, _zz )
                        }
                    }

                    function initBounds() {
                        var data = calcArcBounds( _xx, _yy, _nn );
                        _bb = data.bb;
                        _allBounds = data.bounds
                    }

                    function calcArcBounds( xx, yy, nn ) {
                        var numArcs = nn.length,
                            bb = new Float64Array( numArcs * 4 ),
                            bounds = new Bounds,
                            arcOffs = 0,
                            arcLen, j, b;
                        for ( var i = 0; i < numArcs; i++ ) {
                            arcLen = nn[ i ];
                            if ( arcLen > 0 ) {
                                j = i * 4;
                                b = MapShaper.calcArcBounds( xx, yy, arcOffs, arcLen );
                                bb[ j++ ] = b[ 0 ];
                                bb[ j++ ] = b[ 1 ];
                                bb[ j++ ] = b[ 2 ];
                                bb[ j ] = b[ 3 ];
                                arcOffs += arcLen;
                                bounds.mergeBounds( b )
                            }
                        }
                        return {
                            bb: bb,
                            bounds: bounds
                        }
                    }
                    this.updateVertexData = function( nn, xx, yy, zz ) {
                        initXYData( nn, xx, yy );
                        initZData( zz || null )
                    };
                    this.getVertexData = function() {
                        return {
                            xx: _xx,
                            yy: _yy,
                            zz: _zz,
                            bb: _bb,
                            nn: _nn,
                            ii: _ii
                        }
                    };
                    this.getCopy = function() {
                        var copy = new ArcCollection( new Int32Array( _nn ), new Float64Array( _xx ), new Float64Array( _yy ) );
                        if ( _zz ) copy.setThresholds( new Float64Array( _zz ) );
                        return copy
                    };

                    function getFilteredPointCount() {
                        var zz = _zz,
                            z = _zlimit;
                        if ( !zz || !z ) return this.getPointCount();
                        var count = 0;
                        for ( var i = 0, n = zz.length; i < n; i++ ) {
                            if ( zz[ i ] >= z ) count++
                        }
                        return count
                    }

                    function getFilteredVertexData() {
                        var len2 = getFilteredPointCount();
                        var arcCount = _nn.length;
                        var xx2 = new Float64Array( len2 ),
                            yy2 = new Float64Array( len2 ),
                            zz2 = new Float64Array( len2 ),
                            nn2 = new Int32Array( arcCount ),
                            i = 0,
                            i2 = 0,
                            n, n2;
                        for ( var arcId = 0; arcId < arcCount; arcId++ ) {
                            n2 = 0;
                            n = _nn[ arcId ];
                            for ( var end = i + n; i < end; i++ ) {
                                if ( _zz[ i ] >= _zlimit ) {
                                    xx2[ i2 ] = _xx[ i ];
                                    yy2[ i2 ] = _yy[ i ];
                                    zz2[ i2 ] = _zz[ i ];
                                    i2++;
                                    n2++
                                }
                            }
                            if ( n2 < 2 ) error( "Collapsed arc" );
                            nn2[ arcId ] = n2
                        }
                        return {
                            xx: xx2,
                            yy: yy2,
                            zz: zz2,
                            nn: nn2
                        }
                    }
                    this.getFilteredCopy = function() {
                        if ( !_zz || _zlimit === 0 ) return this.getCopy();
                        var data = getFilteredVertexData();
                        var copy = new ArcCollection( data.nn, data.xx, data.yy );
                        copy.setThresholds( data.zz );
                        return copy
                    };
                    this.toArray = function() {
                        var arr = [];
                        this.forEach( function( iter ) {
                            var arc = [];
                            while ( iter.hasNext() ) {
                                arc.push( [ iter.x, iter.y ] )
                            }
                            arr.push( arc )
                        } );
                        return arr
                    };
                    this.toJSON = function() {
                        return this.toArray()
                    };
                    this.forEachArcSegment = function( arcId, cb ) {
                        var fw = arcId >= 0,
                            absId = fw ? arcId : ~arcId,
                            zlim = this.getRetainedInterval(),
                            n = _nn[ absId ],
                            step = fw ? 1 : -1,
                            v1 = fw ? _ii[ absId ] : _ii[ absId ] + n - 1,
                            v2 = v1,
                            count = 0;
                        for ( var j = 1; j < n; j++ ) {
                            v2 += step;
                            if ( zlim === 0 || _zz[ v2 ] >= zlim ) {
                                cb( v1, v2, _xx, _yy );
                                v1 = v2;
                                count++
                            }
                        }
                        return count
                    };
                    this.forEachSegment = function( cb ) {
                        var count = 0;
                        for ( var i = 0, n = this.size(); i < n; i++ ) {
                            count += this.forEachArcSegment( i, cb )
                        }
                        return count
                    };
                    this.transformPoints = function( f ) {
                        var xx = _xx,
                            yy = _yy,
                            p;
                        for ( var i = 0, n = xx.length; i < n; i++ ) {
                            p = f( xx[ i ], yy[ i ] );
                            xx[ i ] = p[ 0 ];
                            yy[ i ] = p[ 1 ]
                        }
                        initBounds()
                    };
                    this.forEach = function( cb ) {
                        for ( var i = 0, n = this.size(); i < n; i++ ) {
                            cb( this.getArcIter( i ), i )
                        }
                    };
                    this.forEach2 = function( cb ) {
                        for ( var arcId = 0, n = this.size(); arcId < n; arcId++ ) {
                            cb( _ii[ arcId ], _nn[ arcId ], _xx, _yy, _zz, arcId )
                        }
                    };
                    this.forEach3 = function( cb ) {
                        var start, end, xx, yy, zz;
                        for ( var arcId = 0, n = this.size(); arcId < n; arcId++ ) {
                            start = _ii[ arcId ];
                            end = start + _nn[ arcId ];
                            xx = _xx.subarray( start, end );
                            yy = _yy.subarray( start, end );
                            if ( _zz ) zz = _zz.subarray( start, end );
                            cb( xx, yy, zz, arcId )
                        }
                    };
                    this.filter = function( cb ) {
                        var map = new Int32Array( this.size() ),
                            goodArcs = 0,
                            goodPoints = 0;
                        for ( var i = 0, n = this.size(); i < n; i++ ) {
                            if ( cb( this.getArcIter( i ), i ) ) {
                                map[ i ] = goodArcs++;
                                goodPoints += _nn[ i ]
                            } else {
                                map[ i ] = -1
                            }
                        }
                        if ( goodArcs === this.size() ) {
                            return null
                        } else {
                            condenseArcs( map );
                            if ( goodArcs === 0 ) {}
                            return map
                        }
                    };

                    function condenseArcs( map ) {
                        var goodPoints = 0,
                            goodArcs = 0,
                            copyElements = utils.copyElements,
                            k, arcLen;
                        for ( var i = 0, n = map.length; i < n; i++ ) {
                            k = map[ i ];
                            arcLen = _nn[ i ];
                            if ( k > -1 ) {
                                copyElements( _xx, _ii[ i ], _xx, goodPoints, arcLen );
                                copyElements( _yy, _ii[ i ], _yy, goodPoints, arcLen );
                                if ( _zz ) copyElements( _zz, _ii[ i ], _zz, goodPoints, arcLen );
                                _nn[ k ] = arcLen;
                                goodPoints += arcLen;
                                goodArcs++
                            }
                        }
                        initXYData( _nn.subarray( 0, goodArcs ), _xx.subarray( 0, goodPoints ), _yy.subarray( 0, goodPoints ) );
                        if ( _zz ) initZData( _zz.subarray( 0, goodPoints ) )
                    }
                    this.dedupCoords = function() {
                        var arcId = 0,
                            i = 0,
                            i2 = 0,
                            arcCount = this.size(),
                            zz = _zz,
                            arcLen, arcLen2;
                        while ( arcId < arcCount ) {
                            arcLen = _nn[ arcId ];
                            arcLen2 = MapShaper.dedupArcCoords( i, i2, arcLen, _xx, _yy, zz );
                            _nn[ arcId ] = arcLen2;
                            i += arcLen;
                            i2 += arcLen2;
                            arcId++
                        }
                        if ( i > i2 ) {
                            initXYData( _nn, _xx.subarray( 0, i2 ), _yy.subarray( 0, i2 ) );
                            if ( zz ) initZData( zz.subarray( 0, i2 ) )
                        }
                        return i - i2
                    };
                    this.getVertex = function( arcId, nth ) {
                        var i = this.indexOfVertex( arcId, nth );
                        return {
                            x: _xx[ i ],
                            y: _yy[ i ]
                        }
                    };
                    this.indexOfVertex = function( arcId, nth ) {
                        var absId = arcId < 0 ? ~arcId : arcId,
                            len = _nn[ absId ];
                        if ( nth < 0 ) nth = len + nth;
                        if ( absId != arcId ) nth = len - nth - 1;
                        if ( nth < 0 || nth >= len ) error( "[ArcCollection] out-of-range vertex id" );
                        return _ii[ absId ] + nth
                    };
                    this.pointIsEndpoint = function( idx ) {
                        var ii = _ii,
                            nn = _nn;
                        for ( var j = 0, n = ii.length; j < n; j++ ) {
                            if ( idx === ii[ j ] || idx === ii[ j ] + nn[ j ] - 1 ) return true
                        }
                        return false
                    };
                    this.arcIsClosed = function( arcId ) {
                        var i = this.indexOfVertex( arcId, 0 ),
                            j = this.indexOfVertex( arcId, -1 );
                        return i != j && _xx[ i ] == _xx[ j ] && _yy[ i ] == _yy[ j ]
                    };
                    this.arcIsLollipop = function( arcId ) {
                        var len = this.getArcLength( arcId ),
                            i, j;
                        if ( len <= 2 || !this.arcIsClosed( arcId ) ) return false;
                        i = this.indexOfVertex( arcId, 1 );
                        j = this.indexOfVertex( arcId, -2 );
                        return _xx[ i ] == _xx[ j ] && _yy[ i ] == _yy[ j ]
                    };
                    this.arcIsDegenerate = function( arcId ) {
                        var iter = this.getArcIter( arcId );
                        var i = 0,
                            x, y;
                        while ( iter.hasNext() ) {
                            if ( i > 0 ) {
                                if ( x != iter.x || y != iter.y ) return false
                            }
                            x = iter.x;
                            y = iter.y;
                            i++
                        }
                        return true
                    };
                    this.getArcLength = function( arcId ) {
                        return _nn[ absArcId( arcId ) ]
                    };
                    this.getArcIter = function( arcId ) {
                        var fw = arcId >= 0,
                            i = fw ? arcId : ~arcId,
                            iter = _zz && _zlimit ? _filteredArcIter : _arcIter;
                        if ( i >= _nn.length ) {
                            error( "#getArcId() out-of-range arc id:", arcId )
                        }
                        return iter.init( _ii[ i ], _nn[ i ], fw, _zlimit )
                    };
                    this.getShapeIter = function( ids ) {
                        return new ShapeIter( this ).init( ids )
                    };
                    this.setThresholds = function( thresholds ) {
                        var n = this.getPointCount(),
                            zz = null;
                        if ( !thresholds ) {} else if ( thresholds.length == n ) {
                            zz = thresholds
                        } else if ( thresholds.length == this.size() ) {
                            zz = flattenThresholds( thresholds, n )
                        } else {
                            error( "Invalid threshold data" )
                        }
                        initZData( zz );
                        return this
                    };

                    function flattenThresholds( arr, n ) {
                        var zz = new Float64Array( n ),
                            i = 0;
                        arr.forEach( function( arr ) {
                            for ( var j = 0, n = arr.length; j < n; i++, j++ ) {
                                zz[ i ] = arr[ j ]
                            }
                        } );
                        if ( i != n ) error( "Mismatched thresholds" );
                        return zz
                    }
                    this.flatten = function() {
                        if ( _zlimit > 0 ) {
                            var data = getFilteredVertexData();
                            this.updateVertexData( data.nn, data.xx, data.yy );
                            _zlimit = 0
                        } else {
                            _zz = null
                        }
                    };
                    this.getRetainedInterval = function() {
                        return _zlimit
                    };
                    this.setRetainedInterval = function( z ) {
                        _zlimit = z;
                        return this
                    };
                    this.getRetainedPct = function() {
                        return this.getPctByThreshold( _zlimit )
                    };
                    this.setRetainedPct = function( pct ) {
                        if ( pct >= 1 ) {
                            _zlimit = 0
                        } else {
                            _zlimit = this.getThresholdByPct( pct );
                            _zlimit = MapShaper.clampIntervalByPct( _zlimit, pct )
                        }
                        return this
                    };
                    this.getRemovableThresholds = function( nth ) {
                        if ( !_zz ) error( "[arcs] Missing simplification data." );
                        var skip = nth | 1,
                            arr = new Float64Array( Math.ceil( _zz.length / skip ) ),
                            z;
                        for ( var i = 0, j = 0, n = this.getPointCount(); i < n; i += skip ) {
                            z = _zz[ i ];
                            if ( z != Infinity ) {
                                arr[ j++ ] = z
                            }
                        }
                        return arr.subarray( 0, j )
                    };
                    this.getArcThresholds = function( arcId ) {
                        if ( !( arcId >= 0 && arcId < this.size() ) ) {
                            error( "[arcs] Invalid arc id:", arcId )
                        }
                        var start = _ii[ arcId ],
                            end = start + _nn[ arcId ];
                        return _zz.subarray( start, end )
                    };
                    this.getPctByThreshold = function( val ) {
                        var arr, rank, pct;
                        if ( val > 0 ) {
                            arr = this.getRemovableThresholds();
                            rank = utils.findRankByValue( arr, val );
                            pct = arr.length > 0 ? 1 - ( rank - 1 ) / arr.length : 1
                        } else {
                            pct = 1
                        }
                        return pct
                    };
                    this.getThresholdByPct = function( pct ) {
                        var tmp = this.getRemovableThresholds(),
                            rank, z;
                        if ( tmp.length === 0 ) {
                            rank = 0
                        } else {
                            rank = Math.floor( ( 1 - pct ) * ( tmp.length + 2 ) )
                        }
                        if ( rank <= 0 ) {
                            z = 0
                        } else if ( rank > tmp.length ) {
                            z = Infinity
                        } else {
                            z = utils.findValueByRank( tmp, rank )
                        }
                        return z
                    };
                    this.arcIntersectsBBox = function( i, b1 ) {
                        var b2 = _bb,
                            j = i * 4;
                        return b2[ j ] <= b1[ 2 ] && b2[ j + 2 ] >= b1[ 0 ] && b2[ j + 3 ] >= b1[ 1 ] && b2[ j + 1 ] <= b1[ 3 ]
                    };
                    this.arcIsContained = function( i, b1 ) {
                        var b2 = _bb,
                            j = i * 4;
                        return b2[ j ] >= b1[ 0 ] && b2[ j + 2 ] <= b1[ 2 ] && b2[ j + 1 ] >= b1[ 1 ] && b2[ j + 3 ] <= b1[ 3 ]
                    };
                    this.arcIsSmaller = function( i, units ) {
                        var bb = _bb,
                            j = i * 4;
                        return bb[ j + 2 ] - bb[ j ] < units && bb[ j + 3 ] - bb[ j + 1 ] < units
                    };
                    this.isPlanar = function() {
                        return !MapShaper.probablyDecimalDegreeBounds( this.getBounds() )
                    };
                    this.size = function() {
                        return _ii && _ii.length || 0
                    };
                    this.getPointCount = function() {
                        return _xx && _xx.length || 0
                    };
                    this.getBounds = function() {
                        return _allBounds.clone()
                    };
                    this.getSimpleShapeBounds = function( arcIds, bounds ) {
                        bounds = bounds || new Bounds;
                        for ( var i = 0, n = arcIds.length; i < n; i++ ) {
                            this.mergeArcBounds( arcIds[ i ], bounds )
                        }
                        return bounds
                    };
                    this.getSimpleShapeBounds2 = function( arcIds, arr ) {
                        var bbox = arr || [],
                            bb = _bb,
                            id = absArcId( arcIds[ 0 ] ) * 4;
                        bbox[ 0 ] = bb[ id ];
                        bbox[ 1 ] = bb[ ++id ];
                        bbox[ 2 ] = bb[ ++id ];
                        bbox[ 3 ] = bb[ ++id ];
                        for ( var i = 1, n = arcIds.length; i < n; i++ ) {
                            id = absArcId( arcIds[ i ] ) * 4;
                            if ( bb[ id ] < bbox[ 0 ] ) bbox[ 0 ] = bb[ id ];
                            if ( bb[ ++id ] < bbox[ 1 ] ) bbox[ 1 ] = bb[ id ];
                            if ( bb[ ++id ] > bbox[ 2 ] ) bbox[ 2 ] = bb[ id ];
                            if ( bb[ ++id ] > bbox[ 3 ] ) bbox[ 3 ] = bb[ id ]
                        }
                        return bbox
                    };
                    this.getMultiShapeBounds = function( shapeIds, bounds ) {
                        bounds = bounds || new Bounds;
                        if ( shapeIds ) {
                            for ( var i = 0, n = shapeIds.length; i < n; i++ ) {
                                this.getSimpleShapeBounds( shapeIds[ i ], bounds )
                            }
                        }
                        return bounds
                    };
                    this.mergeArcBounds = function( arcId, bounds ) {
                        if ( arcId < 0 ) arcId = ~arcId;
                        var offs = arcId * 4;
                        bounds.mergeBounds( _bb[ offs ], _bb[ offs + 1 ], _bb[ offs + 2 ], _bb[ offs + 3 ] )
                    }
                }
                ArcCollection.prototype.inspect = function() {
                    var n = this.getPointCount(),
                        str;
                    if ( n < 50 ) {
                        str = JSON.stringify( this.toArray() )
                    } else {
                        str = "[ArcCollection (" + this.size() + ")]"
                    }
                    return str
                };
                MapShaper.dedupArcCoords = function( src, dest, arcLen, xx, yy, zz ) {
                    var n = 0,
                        n2 = 0;
                    var x, y, i, j, keep;
                    while ( n < arcLen ) {
                        j = src + n;
                        x = xx[ j ];
                        y = yy[ j ];
                        keep = x == x && y == y && ( n2 === 0 || x != xx[ j - 1 ] || y != yy[ j - 1 ] );
                        if ( keep ) {
                            i = dest + n2;
                            xx[ i ] = x;
                            yy[ i ] = y;
                            n2++
                        }
                        if ( zz && n2 > 0 && ( keep || zz[ j ] > zz[ i ] ) ) {
                            zz[ i ] = zz[ j ]
                        }
                        n++
                    }
                    return n2 > 1 ? n2 : 0
                };
                MapShaper.countPointsInLayer = function( lyr ) {
                    var count = 0;
                    if ( MapShaper.layerHasPoints( lyr ) ) {
                        MapShaper.forEachPoint( lyr.shapes, function() {
                            count++
                        } )
                    }
                    return count
                };
                MapShaper.getPointBounds = function( shapes ) {
                    var bounds = new Bounds;
                    MapShaper.forEachPoint( shapes, function( p ) {
                        bounds.mergePoint( p[ 0 ], p[ 1 ] )
                    } );
                    return bounds
                };
                MapShaper.forEachPoint = function( shapes, cb ) {
                    shapes.forEach( function( shape, id ) {
                        var n = shape ? shape.length : 0;
                        for ( var i = 0; i < n; i++ ) {
                            cb( shape[ i ], id )
                        }
                    } )
                };
                MapShaper.transformPointsInLayer = function( lyr, f ) {
                    if ( MapShaper.layerHasPoints( lyr ) ) {
                        MapShaper.forEachPoint( lyr.shapes, function( p ) {
                            var p2 = f( p[ 0 ], p[ 1 ] );
                            p[ 0 ] = p2[ 0 ];
                            p[ 1 ] = p2[ 1 ]
                        } )
                    }
                };
                MapShaper.getAvgSegment = function( arcs ) {
                    var sum = 0;
                    var count = arcs.forEachSegment( function( i, j, xx, yy ) {
                        var dx = xx[ i ] - xx[ j ],
                            dy = yy[ i ] - yy[ j ];
                        sum += Math.sqrt( dx * dx + dy * dy )
                    } );
                    return sum / count || 0
                };
                MapShaper.getAvgSegment2 = function( arcs ) {
                    var dx = 0,
                        dy = 0;
                    var count = arcs.forEachSegment( function( i, j, xx, yy ) {
                        dx += Math.abs( xx[ i ] - xx[ j ] );
                        dy += Math.abs( yy[ i ] - yy[ j ] )
                    } );
                    return [ dx / count || 0, dy / count || 0 ]
                };
                MapShaper.countArcsInShapes = function( shapes, counts ) {
                    MapShaper.traversePaths( shapes, null, function( obj ) {
                        var arcs = obj.arcs,
                            id;
                        for ( var i = 0; i < arcs.length; i++ ) {
                            id = arcs[ i ];
                            if ( id < 0 ) id = ~id;
                            counts[ id ]++
                        }
                    } )
                };
                MapShaper.findShapesByArcId = function( shapes, arcIds, numArcs ) {
                    var index = numArcs ? new Uint8Array( numArcs ) : [],
                        found = [];
                    arcIds.forEach( function( id ) {
                        index[ absArcId( id ) ] = 1
                    } );
                    shapes.forEach( function( shp, shpId ) {
                        var isHit = false;
                        MapShaper.forEachArcId( shp || [], function( id ) {
                            isHit = isHit || index[ absArcId( id ) ] == 1
                        } );
                        if ( isHit ) {
                            found.push( shpId )
                        }
                    } );
                    return found
                };
                MapShaper.cloneShape = function( shp ) {
                    if ( !shp ) return null;
                    return shp.map( function( part ) {
                        return part.concat()
                    } )
                };
                MapShaper.cloneShapes = function( arr ) {
                    return utils.isArray( arr ) ? arr.map( MapShaper.cloneShape ) : null
                };
                MapShaper.pathsAreIdentical = function( a, b ) {
                    if ( a.length != b.length ) return false;
                    for ( var i = 0, n = a.length; i < n; i++ ) {
                        if ( a[ i ] != b[ i ] ) return false
                    }
                    return true
                };
                MapShaper.reversePath = function( ids ) {
                    ids.reverse();
                    for ( var i = 0, n = ids.length; i < n; i++ ) {
                        ids[ i ] = ~ids[ i ]
                    }
                };
                MapShaper.clampIntervalByPct = function( z, pct ) {
                    if ( pct <= 0 ) z = Infinity;
                    else if ( pct >= 1 ) z = 0;
                    return z
                };
                MapShaper.findNextRemovableVertices = function( zz, zlim, start, end ) {
                    var i = MapShaper.findNextRemovableVertex( zz, zlim, start, end ),
                        arr, k;
                    if ( i > -1 ) {
                        k = zz[ i ];
                        arr = [ i ];
                        while ( ++i < end ) {
                            if ( zz[ i ] == k ) {
                                arr.push( i )
                            }
                        }
                    }
                    return arr || null
                };
                MapShaper.findNextRemovableVertex = function( zz, zlim, start, end ) {
                    var tmp, jz = 0,
                        j = -1,
                        z;
                    if ( start > end ) {
                        tmp = start;
                        start = end;
                        end = tmp
                    }
                    for ( var i = start + 1; i < end; i++ ) {
                        z = zz[ i ];
                        if ( z < zlim && z > jz ) {
                            j = i;
                            jz = z
                        }
                    }
                    return j
                };
                MapShaper.forEachArcId = function( arr, cb ) {
                    var item;
                    for ( var i = 0; i < arr.length; i++ ) {
                        item = arr[ i ];
                        if ( item instanceof Array ) {
                            MapShaper.forEachArcId( item, cb )
                        } else if ( utils.isInteger( item ) ) {
                            var val = cb( item );
                            if ( val !== void 0 ) {
                                arr[ i ] = val
                            }
                        } else if ( item ) {
                            error( "Non-integer arc id in:", arr )
                        }
                    }
                };
                MapShaper.forEachPath = function( paths, cb ) {
                    MapShaper.editPaths( paths, cb )
                };
                MapShaper.editShapes = function( shapes, editPath ) {
                    for ( var i = 0, n = shapes.length; i < n; i++ ) {
                        shapes[ i ] = MapShaper.editPaths( shapes[ i ], editPath )
                    }
                };
                MapShaper.editPaths = function( paths, cb ) {
                    if ( !paths ) return null;
                    if ( !utils.isArray( paths ) ) error( "[editPaths()] Expected an array, found:", arr );
                    var nulls = 0,
                        n = paths.length,
                        retn;
                    for ( var i = 0; i < n; i++ ) {
                        retn = cb( paths[ i ], i, paths );
                        if ( retn === null ) {
                            nulls++;
                            paths[ i ] = null
                        } else if ( utils.isArray( retn ) ) {
                            paths[ i ] = retn
                        }
                    }
                    if ( nulls == n ) {
                        return null
                    } else if ( nulls > 0 ) {
                        return paths.filter( function( ids ) {
                            return !!ids
                        } )
                    } else {
                        return paths
                    }
                };
                MapShaper.forEachPathSegment = function( shape, arcs, cb ) {
                    MapShaper.forEachArcId( shape, function( arcId ) {
                        arcs.forEachArcSegment( arcId, cb )
                    } )
                };
                MapShaper.traversePaths = function traversePaths( shapes, cbArc, cbPart, cbShape ) {
                    var segId = 0;
                    shapes.forEach( function( parts, shapeId ) {
                        if ( !parts || parts.length === 0 ) return;
                        var arcIds, arcId;
                        if ( cbShape ) {
                            cbShape( shapeId )
                        }
                        for ( var i = 0, m = parts.length; i < m; i++ ) {
                            arcIds = parts[ i ];
                            if ( cbPart ) {
                                cbPart( {
                                    i: i,
                                    shapeId: shapeId,
                                    shape: parts,
                                    arcs: arcIds
                                } )
                            }
                            if ( cbArc ) {
                                for ( var j = 0, n = arcIds.length; j < n; j++, segId++ ) {
                                    arcId = arcIds[ j ];
                                    cbArc( {
                                        i: j,
                                        shapeId: shapeId,
                                        partId: i,
                                        arcId: arcId,
                                        segId: segId
                                    } )
                                }
                            }
                        }
                    } )
                };
                MapShaper.arcHasLength = function( id, coords ) {
                    var iter = coords.getArcIter( id ),
                        x, y;
                    if ( iter.hasNext() ) {
                        x = iter.x;
                        y = iter.y;
                        while ( iter.hasNext() ) {
                            if ( iter.x != x || iter.y != y ) return true
                        }
                    }
                    return false
                };
                MapShaper.filterEmptyArcs = function( shape, coords ) {
                    if ( !shape ) return null;
                    var shape2 = [];
                    shape.forEach( function( ids ) {
                        var path = [];
                        for ( var i = 0; i < ids.length; i++ ) {
                            if ( MapShaper.arcHasLength( ids[ i ], coords ) ) {
                                path.push( ids[ i ] )
                            }
                        }
                        if ( path.length > 0 ) shape2.push( path )
                    } );
                    return shape2.length > 0 ? shape2 : null
                };
                MapShaper.groupPolygonRings = function( paths ) {
                    var pos = [],
                        neg = [];
                    if ( paths ) {
                        paths.forEach( function( path ) {
                            if ( path.area > 0 ) {
                                pos.push( path )
                            } else if ( path.area < 0 ) {
                                neg.push( path )
                            } else {}
                        } )
                    }
                    var output = pos.map( function( part ) {
                        return [ part ]
                    } );
                    neg.forEach( function( hole ) {
                        var containerId = -1,
                            containerArea = 0;
                        for ( var i = 0, n = pos.length; i < n; i++ ) {
                            var part = pos[ i ],
                                contained = part.bounds.contains( hole.bounds ) && part.area > -hole.area;
                            if ( contained && ( containerArea === 0 || part.area < containerArea ) ) {
                                containerArea = part.area;
                                containerId = i
                            }
                        }
                        if ( containerId == -1 ) {
                            verbose( "[groupPolygonRings()] polygon hole is missing a containing ring, dropping." )
                        } else {
                            output[ containerId ].push( hole )
                        }
                    } );
                    return output
                };
                MapShaper.getPathMetadata = function( shape, arcs, type ) {
                    var data = [],
                        ids;
                    for ( var i = 0, n = shape && shape.length; i < n; i++ ) {
                        ids = shape[ i ];
                        data.push( {
                            ids: ids,
                            area: type == "polygon" ? geom.getPlanarPathArea( ids, arcs ) : 0,
                            bounds: arcs.getSimpleShapeBounds( ids )
                        } )
                    }
                    return data
                };
                MapShaper.quantizeArcs = function( arcs, quanta ) {
                    var bb1 = arcs.getBounds(),
                        bb2 = new Bounds( 0, 0, quanta - 1, quanta - 1 ),
                        fw = bb1.getTransform( bb2 ),
                        inv = fw.invert();
                    arcs.transformPoints( function( x, y ) {
                        var p = fw.transform( x, y );
                        return inv.transform( Math.round( p[ 0 ] ), Math.round( p[ 1 ] ) )
                    } )
                };
                MapShaper.divideFeaturesByType = function( shapes, properties, types ) {
                    var typeSet = utils.uniq( types );
                    var layers = typeSet.map( function( geoType ) {
                        var p = [],
                            s = [],
                            dataNulls = 0,
                            rec;
                        for ( var i = 0, n = shapes.length; i < n; i++ ) {
                            if ( types[ i ] != geoType ) continue;
                            if ( geoType ) s.push( shapes[ i ] );
                            rec = properties[ i ];
                            p.push( rec );
                            if ( !rec ) dataNulls++
                        }
                        return {
                            geometry_type: geoType,
                            shapes: s,
                            data: dataNulls < s.length ? new DataTable( p ) : null
                        }
                    } );
                    return layers
                };
                MapShaper.splitDataset = function( dataset ) {
                    return dataset.layers.map( function( lyr ) {
                        var split = {
                            arcs: dataset.arcs,
                            layers: [ lyr ],
                            info: dataset.info
                        };
                        MapShaper.dissolveArcs( split );
                        return split
                    } )
                };
                MapShaper.copyDataset = function( dataset ) {
                    var d2 = utils.extend( {}, dataset );
                    d2.layers = d2.layers.map( MapShaper.copyLayer );
                    if ( d2.arcs ) {
                        d2.arcs = d2.arcs.getFilteredCopy()
                    }
                    return d2
                };
                MapShaper.copyDatasetForExport = function( dataset ) {
                    var d2 = utils.extend( {}, dataset );
                    d2.layers = d2.layers.map( MapShaper.copyLayerShapes );
                    if ( d2.arcs ) {
                        d2.arcs = d2.arcs.getFilteredCopy()
                    }
                    return d2
                };
                MapShaper.getOutputLayer = function( src, opts ) {
                    return opts && opts.no_replace ? {
                        geometry_type: src.geometry_type
                    } : src
                };
                MapShaper.copyLayer = function( lyr ) {
                    var copy = MapShaper.copyLayerShapes( lyr );
                    if ( copy.data ) {
                        copy.data = copy.data.clone()
                    }
                    return copy
                };
                MapShaper.copyLayerShapes = function( lyr ) {
                    var copy = utils.extend( {}, lyr );
                    if ( lyr.shapes ) {
                        copy.shapes = MapShaper.cloneShapes( lyr.shapes )
                    }
                    return copy
                };
                MapShaper.getDatasetBounds = function( data ) {
                    var bounds = new Bounds;
                    data.layers.forEach( function( lyr ) {
                        var lyrbb = MapShaper.getLayerBounds( lyr, data.arcs );
                        if ( lyrbb ) bounds.mergeBounds( lyrbb )
                    } );
                    return bounds
                };
                MapShaper.datasetHasPaths = function( dataset ) {
                    return utils.some( dataset.layers, function( lyr ) {
                        return MapShaper.layerHasPaths( lyr )
                    } )
                };
                MapShaper.countMultiPartFeatures = function( shapes ) {
                    var count = 0;
                    for ( var i = 0, n = shapes.length; i < n; i++ ) {
                        if ( shapes[ i ] && shapes[ i ].length > 1 ) count++
                    }
                    return count
                };
                MapShaper.getFeatureCount = function( lyr ) {
                    var count = 0;
                    if ( lyr.data ) {
                        count = lyr.data.size()
                    } else if ( lyr.shapes ) {
                        count = lyr.shapes.length
                    }
                    return count
                };
                MapShaper.getLayerBounds = function( lyr, arcs ) {
                    var bounds = null;
                    if ( lyr.geometry_type == "point" ) {
                        bounds = MapShaper.getPointBounds( lyr.shapes )
                    } else if ( lyr.geometry_type == "polygon" || lyr.geometry_type == "polyline" ) {
                        bounds = MapShaper.getPathBounds( lyr.shapes, arcs )
                    } else {}
                    return bounds
                };
                MapShaper.getPathBounds = function( shapes, arcs ) {
                    var bounds = new Bounds;
                    MapShaper.forEachArcId( shapes, function( id ) {
                        arcs.mergeArcBounds( id, bounds )
                    } );
                    return bounds
                };
                MapShaper.replaceLayers = function( dataset, cutLayers, newLayers ) {
                    var currLayers = dataset.layers.concat();
                    utils.repeat( Math.max( cutLayers.length, newLayers.length ), function( i ) {
                        var cutLyr = cutLayers[ i ],
                            newLyr = newLayers[ i ],
                            idx = cutLyr ? currLayers.indexOf( cutLyr ) : currLayers.length;
                        if ( cutLyr ) {
                            currLayers.splice( idx, 1 )
                        }
                        if ( newLyr ) {
                            currLayers.splice( idx, 0, newLyr )
                        }
                    } );
                    dataset.layers = currLayers
                };
                MapShaper.isolateLayer = function( layer, dataset ) {
                    return utils.defaults( {
                        layers: dataset.layers.filter( function( lyr ) {
                            return lyr == layer
                        } )
                    }, dataset )
                };
                MapShaper.findMatchingLayers = function( layers, target ) {
                    var ii = [];
                    String( target ).split( "," ).forEach( function( id ) {
                        var i = Number( id ),
                            rxp = utils.wildcardToRegExp( id );
                        if ( utils.isInteger( i ) ) {
                            ii.push( i )
                        } else {
                            layers.forEach( function( lyr, i ) {
                                if ( rxp.test( lyr.name ) ) ii.push( i )
                            } )
                        }
                    } );
                    ii = utils.uniq( ii );
                    return ii.map( function( i ) {
                        return layers[ i ]
                    } )
                };
                MapShaper.transformPoints = function( dataset, f ) {
                    if ( dataset.arcs ) {
                        dataset.arcs.transformPoints( f )
                    }
                    dataset.layers.forEach( function( lyr ) {
                        if ( MapShaper.layerHasPoints( lyr ) ) {
                            MapShaper.transformPointsInLayer( lyr, f )
                        }
                    } )
                };
                MapShaper.initDataTable = function( lyr ) {
                    lyr.data = new DataTable( MapShaper.getFeatureCount( lyr ) )
                };

                function NodeCollection( arcs, filter ) {
                    if ( utils.isArray( arcs ) ) {
                        arcs = new ArcCollection( arcs )
                    }
                    var arcData = arcs.getVertexData(),
                        nn = arcData.nn,
                        xx = arcData.xx,
                        yy = arcData.yy,
                        chains;
                    Object.defineProperty( this, "arcs", {
                        value: arcs
                    } );
                    this.toArray = function() {
                        var nodes = MapShaper.findNodeTopology( arcs, filter ),
                            flags = new Uint8Array( nodes.xx.length ),
                            arr = [];
                        utils.forEach( nodes.chains, function( next, i ) {
                            if ( flags[ i ] == 1 ) return;
                            arr.push( [ nodes.xx[ i ], nodes.yy[ i ] ] );
                            while ( flags[ next ] != 1 ) {
                                flags[ next ] = 1;
                                next = nodes.chains[ next ]
                            }
                        } );
                        return arr
                    };
                    this.size = function() {
                        return this.toArray().length
                    };
                    this.debugNode = function( arcId ) {
                        var ids = [ arcId ];
                        this.forEachConnectedArc( arcId, function( id ) {
                            ids.push( id )
                        } );
                        message( "node ids:", ids );
                        ids.forEach( printArc );

                        function printArc( id ) {
                            var str = id + ": ";
                            var len = arcs.getArcLength( id );
                            if ( len > 0 ) {
                                var p1 = arcs.getVertex( id, -1 );
                                str += utils.format( "[%f, %f]", p1.x, p1.y );
                                if ( len > 1 ) {
                                    var p2 = arcs.getVertex( id, -2 );
                                    str += utils.format( ", [%f, %f]", p2.x, p2.y );
                                    if ( len > 2 ) {
                                        var p3 = arcs.getVertex( id, 0 );
                                        str += utils.format( ", [%f, %f]", p3.x, p3.y )
                                    }
                                    str += " len: " + distance2D( p1.x, p1.y, p2.x, p2.y )
                                }
                            } else {
                                str = "[]"
                            }
                            message( str )
                        }
                    };
                    this.forEachConnectedArc = function( arcId, cb ) {
                        var nextId = nextConnectedArc( arcId ),
                            i = 0;
                        while ( nextId != arcId ) {
                            cb( nextId, i++ );
                            nextId = nextConnectedArc( nextId )
                        }
                    };
                    this.getConnectedArcs = function( arcId ) {
                        var ids = [];
                        var nextId = nextConnectedArc( arcId );
                        while ( nextId != arcId ) {
                            ids.push( nextId );
                            nextId = nextConnectedArc( nextId )
                        }
                        return ids
                    };
                    this.findMatchingArc = function( arcId ) {
                        var nextId = nextConnectedArc( arcId ),
                            match = arcId;
                        while ( nextId != arcId ) {
                            if ( testArcMatch( arcId, nextId ) ) {
                                if ( absArcId( nextId ) < absArcId( match ) ) match = nextId
                            }
                            nextId = nextConnectedArc( nextId )
                        }
                        if ( match != arcId ) {}
                        return match
                    };

                    function getNodeChains() {
                        var nodeData;
                        if ( !chains ) {
                            nodeData = MapShaper.findNodeTopology( arcs, filter );
                            chains = nodeData.chains;
                            if ( nn.length * 2 != chains.length ) error( "[NodeCollection] count error" )
                        }
                        return chains
                    }

                    function testArcMatch( a, b ) {
                        var absA = a >= 0 ? a : ~a,
                            absB = b >= 0 ? b : ~b,
                            lenA = nn[ absA ];
                        if ( lenA < 2 ) {
                            return false
                        }
                        if ( lenA != nn[ absB ] ) return false;
                        if ( testVertexMatch( a, b, -1 ) && testVertexMatch( a, b, 1 ) && testVertexMatch( a, b, -2 ) ) {
                            return true
                        }
                        return false
                    }

                    function testVertexMatch( a, b, i ) {
                        var ai = arcs.indexOfVertex( a, i ),
                            bi = arcs.indexOfVertex( b, i );
                        return xx[ ai ] == xx[ bi ] && yy[ ai ] == yy[ bi ]
                    }

                    function nextConnectedArc( arcId ) {
                        var fw = arcId >= 0,
                            absId = fw ? arcId : ~arcId,
                            nodeId = fw ? absId * 2 + 1 : absId * 2,
                            chains = getNodeChains(),
                            chainedId = chains[ nodeId ],
                            nextAbsId = chainedId >> 1,
                            nextArcId = chainedId & 1 == 1 ? nextAbsId : ~nextAbsId;
                        if ( chainedId < 0 || chainedId >= chains.length ) error( "out-of-range chain id" );
                        if ( absId >= nn.length ) error( "out-of-range arc id" );
                        if ( chains.length <= nodeId ) error( "out-of-bounds node id" );
                        return nextArcId
                    }
                    this.internal = {
                        testArcMatch: testArcMatch,
                        testVertexMatch: testVertexMatch
                    }
                }
                MapShaper.findNodeTopology = function( arcs, filter ) {
                    var n = arcs.size() * 2,
                        xx2 = new Float64Array( n ),
                        yy2 = new Float64Array( n ),
                        ids2 = new Int32Array( n );
                    arcs.forEach2( function( i, n, xx, yy, zz, arcId ) {
                        if ( filter && !filter( arcId ) ) {
                            return
                        }
                        var start = i,
                            end = i + n - 1,
                            start2 = arcId * 2,
                            end2 = start2 + 1;
                        xx2[ start2 ] = xx[ start ];
                        yy2[ start2 ] = yy[ start ];
                        ids2[ start2 ] = arcId;
                        xx2[ end2 ] = xx[ end ];
                        yy2[ end2 ] = yy[ end ];
                        ids2[ end2 ] = arcId
                    } );
                    var chains = initPointChains( xx2, yy2 );
                    return {
                        xx: xx2,
                        yy: yy2,
                        ids: ids2,
                        chains: chains
                    }
                };
                geom.getShapeArea = function( shp, arcs ) {
                    return ( arcs.isPlanar() ? geom.getPlanarShapeArea : geom.getSphericalShapeArea )( shp, arcs )
                };
                geom.getPlanarShapeArea = function( shp, arcs ) {
                    return ( shp || [] ).reduce( function( area, ids ) {
                        return area + geom.getPlanarPathArea( ids, arcs )
                    }, 0 )
                };
                geom.getSphericalShapeArea = function( shp, arcs ) {
                    if ( arcs.isPlanar() ) {
                        error( "[getSphericalShapeArea()] Function requires decimal degree coordinates" )
                    }
                    return ( shp || [] ).reduce( function( area, ids ) {
                        return area + geom.getSphericalPathArea( ids, arcs )
                    }, 0 )
                };
                geom.getMaxPath = function( shp, arcs ) {
                    var maxArea = 0;
                    return ( shp || [] ).reduce( function( maxPath, path ) {
                        var bbArea = arcs.getSimpleShapeBounds( path ).area();
                        if ( bbArea > maxArea ) {
                            maxArea = bbArea;
                            maxPath = path
                        }
                        return maxPath
                    }, null )
                };
                geom.getAvgPathXY = function( ids, arcs ) {
                    var iter = arcs.getShapeIter( ids );
                    if ( !iter.hasNext() ) return null;
                    var x0 = iter.x,
                        y0 = iter.y,
                        count = 0,
                        sumX = 0,
                        sumY = 0;
                    while ( iter.hasNext() ) {
                        count++;
                        sumX += iter.x;
                        sumY += iter.y
                    }
                    if ( count === 0 || iter.x !== x0 || iter.y !== y0 ) {
                        sumX += x0;
                        sumY += y0;
                        count++
                    }
                    return {
                        x: sumX / count,
                        y: sumY / count
                    }
                };
                geom.testPointInPolygon = function( x, y, shp, arcs ) {
                    var isIn = false,
                        isOn = false;
                    if ( shp ) {
                        shp.forEach( function( ids ) {
                            var inRing = geom.testPointInRing( x, y, ids, arcs );
                            if ( inRing == 1 ) {
                                isIn = !isIn
                            } else if ( inRing == -1 ) {
                                isOn = true
                            }
                        } )
                    }
                    return isOn || isIn
                };
                geom.getPointToPathDistance = function( px, py, ids, arcs ) {
                    var iter = arcs.getShapeIter( ids );
                    if ( !iter.hasNext() ) return Infinity;
                    var ax = iter.x,
                        ay = iter.y,
                        paSq = distanceSq( px, py, ax, ay ),
                        pPathSq = paSq,
                        pbSq, abSq, bx, by;
                    while ( iter.hasNext() ) {
                        bx = iter.x;
                        by = iter.y;
                        pbSq = distanceSq( px, py, bx, by );
                        abSq = distanceSq( ax, ay, bx, by );
                        pPathSq = Math.min( pPathSq, apexDistSq( paSq, pbSq, abSq ) );
                        ax = bx;
                        ay = by;
                        paSq = pbSq
                    }
                    return Math.sqrt( pPathSq )
                };
                geom.getYIntercept = function( x, ax, ay, bx, by ) {
                    return ay + ( x - ax ) * ( by - ay ) / ( bx - ax )
                };
                geom.getXIntercept = function( y, ax, ay, bx, by ) {
                    return ax + ( y - ay ) * ( bx - ax ) / ( by - ay )
                };
                geom.getPointToShapeDistance = function( x, y, shp, arcs ) {
                    var minDist = ( shp || [] ).reduce( function( minDist, ids ) {
                        var pathDist = geom.getPointToPathDistance( x, y, ids, arcs );
                        return Math.min( minDist, pathDist )
                    }, Infinity );
                    return minDist
                };
                geom.testPointInRing = function( x, y, ids, arcs ) {
                    var isIn = false,
                        isOn = false;
                    MapShaper.forEachPathSegment( ids, arcs, function( a, b, xx, yy ) {
                        var result = geom.testRayIntersection( x, y, xx[ a ], yy[ a ], xx[ b ], yy[ b ] );
                        if ( result == 1 ) {
                            isIn = !isIn
                        } else if ( isNaN( result ) ) {
                            isOn = true
                        }
                    } );
                    return isOn ? -1 : isIn ? 1 : 0
                };
                geom.testRayIntersection = function( x, y, ax, ay, bx, by ) {
                    var val = geom.getRayIntersection( x, y, ax, ay, bx, by );
                    if ( val != val ) {
                        return NaN
                    }
                    return val == -Infinity ? 0 : 1
                };
                geom.getRayIntersection = function( x, y, ax, ay, bx, by ) {
                    var hit = -Infinity,
                        yInt;
                    if ( x < ax && x < bx || x > ax && x > bx || y > ay && y > by ) {} else if ( x === ax || x === bx ) {
                        if ( x === ax && x === bx ) {
                            if ( y == ay || y == by || y > ay != y > by ) {
                                hit = NaN
                            }
                        } else if ( x === ax ) {
                            if ( y === ay ) {
                                hit = NaN
                            } else if ( bx < ax && y < ay ) {
                                hit = ay
                            }
                        } else {
                            if ( y === by ) {
                                hit = NaN
                            } else if ( ax < bx && y < by ) {
                                hit = by
                            }
                        }
                    } else {
                        yInt = geom.getYIntercept( x, ax, ay, bx, by );
                        if ( yInt > y ) {
                            hit = yInt
                        } else if ( yInt == y ) {
                            hit = NaN
                        }
                    }
                    return hit
                };
                geom.getSphericalPathArea = function( ids, arcs ) {
                    var iter = arcs.getShapeIter( ids ),
                        sum = 0,
                        started = false,
                        deg2rad = Math.PI / 180,
                        x, y, xp, yp;
                    while ( iter.hasNext() ) {
                        x = iter.x * deg2rad;
                        y = Math.sin( iter.y * deg2rad );
                        if ( started ) {
                            sum += ( x - xp ) * ( 2 + y + yp )
                        } else {
                            started = true
                        }
                        xp = x;
                        yp = y
                    }
                    return sum / 2 * 6378137 * 6378137
                };
                geom.getPlanarPathArea2 = function( points ) {
                    var sum = 0,
                        ax, ay, bx, by, dx, dy, p;
                    for ( var i = 0, n = points.length; i < n; i++ ) {
                        p = points[ i ];
                        if ( i === 0 ) {
                            ax = 0;
                            ay = 0;
                            dx = -p[ 0 ];
                            dy = -p[ 1 ]
                        } else {
                            ax = p[ 0 ] + dx;
                            ay = p[ 1 ] + dy;
                            sum += ax * by - bx * ay
                        }
                        bx = ax;
                        by = ay
                    }
                    return sum / 2
                };
                geom.getPlanarPathArea = function( ids, arcs ) {
                    var iter = arcs.getShapeIter( ids ),
                        sum = 0,
                        ax, ay, bx, by, dx, dy;
                    if ( iter.hasNext() ) {
                        ax = 0;
                        ay = 0;
                        dx = -iter.x;
                        dy = -iter.y;
                        while ( iter.hasNext() ) {
                            bx = ax;
                            by = ay;
                            ax = iter.x + dx;
                            ay = iter.y + dy;
                            sum += ax * by - bx * ay
                        }
                    }
                    return sum / 2
                };
                geom.countVerticesInPath = function( ids, arcs ) {
                    var iter = arcs.getShapeIter( ids ),
                        count = 0;
                    while ( iter.hasNext() ) count++;
                    return count
                };
                geom.getPathBounds = function( points ) {
                    var bounds = new Bounds;
                    for ( var i = 0, n = points.length; i < n; i++ ) {
                        bounds.mergePoint( points[ i ][ 0 ], points[ i ][ 1 ] )
                    }
                    return bounds
                };
                geom.transposePoints = function( points ) {
                    var xx = [],
                        yy = [],
                        n = points.length;
                    for ( var i = 0; i < n; i++ ) {
                        xx.push( points[ i ][ 0 ] );
                        yy.push( points[ i ][ 1 ] )
                    }
                    return [ xx, yy ]
                };
                geom.calcPathLen = function() {
                    var len;

                    function addSegLen( i, j, xx, yy ) {
                        len += distance2D( xx[ i ], yy[ i ], xx[ j ], yy[ j ] )
                    }
                    return function( path, arcs ) {
                        len = 0;
                        for ( var i = 0, n = path.length; i < n; i++ ) {
                            arcs.forEachArcSegment( path[ i ], addSegLen )
                        }
                        return len
                    }
                }();
                MapShaper.sortSegmentIds = function( xx, ids ) {
                    MapShaper.orderSegmentIds( xx, ids );
                    MapShaper.quicksortSegmentIds( xx, ids, 0, ids.length - 2 )
                };
                MapShaper.orderSegmentIds = function( xx, ids, spherical ) {
                    function swap( i, j ) {
                        var tmp = ids[ i ];
                        ids[ i ] = ids[ j ];
                        ids[ j ] = tmp
                    }
                    for ( var i = 0, n = ids.length; i < n; i += 2 ) {
                        if ( xx[ ids[ i ] ] > xx[ ids[ i + 1 ] ] ) {
                            swap( i, i + 1 )
                        }
                    }
                };
                MapShaper.insertionSortSegmentIds = function( arr, ids, start, end ) {
                    var id, id2;
                    for ( var j = start + 2; j <= end; j += 2 ) {
                        id = ids[ j ];
                        id2 = ids[ j + 1 ];
                        for ( var i = j - 2; i >= start && arr[ id ] < arr[ ids[ i ] ]; i -= 2 ) {
                            ids[ i + 2 ] = ids[ i ];
                            ids[ i + 3 ] = ids[ i + 1 ]
                        }
                        ids[ i + 2 ] = id;
                        ids[ i + 3 ] = id2
                    }
                };
                MapShaper.quicksortSegmentIds = function( a, ids, lo, hi ) {
                    var i = lo,
                        j = hi,
                        pivot, tmp;
                    while ( i < hi ) {
                        pivot = a[ ids[ lo + hi >> 2 << 1 ] ];
                        while ( i <= j ) {
                            while ( a[ ids[ i ] ] < pivot ) i += 2;
                            while ( a[ ids[ j ] ] > pivot ) j -= 2;
                            if ( i <= j ) {
                                tmp = ids[ i ];
                                ids[ i ] = ids[ j ];
                                ids[ j ] = tmp;
                                tmp = ids[ i + 1 ];
                                ids[ i + 1 ] = ids[ j + 1 ];
                                ids[ j + 1 ] = tmp;
                                i += 2;
                                j -= 2
                            }
                        }
                        if ( j - lo < 40 ) MapShaper.insertionSortSegmentIds( a, ids, lo, j );
                        else MapShaper.quicksortSegmentIds( a, ids, lo, j );
                        if ( hi - i < 40 ) {
                            MapShaper.insertionSortSegmentIds( a, ids, i, hi );
                            return
                        }
                        lo = i;
                        j = hi
                    }
                };

                function PolygonIndex( shape, arcs, opts ) {
                    var data = arcs.getVertexData(),
                        polygonBounds = arcs.getMultiShapeBounds( shape ),
                        boundsLeft, xminIds, xmaxIds, bucketCount, bucketOffsets, bucketWidth;
                    init();
                    this.pointInPolygon = function( x, y ) {
                        if ( !polygonBounds.containsPoint( x, y ) ) {
                            return false
                        }
                        var bucketId = getBucketId( x );
                        var count = countCrosses( x, y, bucketId );
                        if ( bucketId > 0 ) {
                            count += countCrosses( x, y, bucketId - 1 )
                        }
                        count += countCrosses( x, y, bucketCount );
                        if ( isNaN( count ) ) return -1;
                        return count % 2 == 1 ? 1 : 0
                    };

                    function countCrosses( x, y, bucketId ) {
                        var offs = bucketOffsets[ bucketId ],
                            count = 0,
                            xx = data.xx,
                            yy = data.yy,
                            n, a, b;
                        if ( bucketId == bucketCount ) {
                            n = xminIds.length - offs
                        } else {
                            n = bucketOffsets[ bucketId + 1 ] - offs
                        }
                        for ( var i = 0; i < n; i++ ) {
                            a = xminIds[ i + offs ];
                            b = xmaxIds[ i + offs ];
                            count += geom.testRayIntersection( x, y, xx[ a ], yy[ a ], xx[ b ], yy[ b ] )
                        }
                        return count
                    }

                    function getBucketId( x ) {
                        var i = Math.floor( ( x - boundsLeft ) / bucketWidth );
                        if ( i < 0 ) i = 0;
                        if ( i >= bucketCount ) i = bucketCount - 1;
                        return i
                    }

                    function getBucketCount( segCount ) {
                        var buckets = opts && opts.buckets > 0 ? opts.buckets : segCount / 100;
                        return Math.ceil( buckets )
                    }

                    function init() {
                        var xx = data.xx,
                            segCount = 0,
                            segId = 0,
                            bucketId = -1,
                            prevBucketId, segments, head, tail, a, b, i, j, xmin, xmax;
                        MapShaper.forEachPathSegment( shape, arcs, function() {
                            segCount++
                        } );
                        segments = new Uint32Array( segCount * 2 );
                        i = 0;
                        MapShaper.forEachPathSegment( shape, arcs, function( a, b, xx, yy ) {
                            segments[ i++ ] = a;
                            segments[ i++ ] = b
                        } );
                        MapShaper.sortSegmentIds( xx, segments );
                        xminIds = new Uint32Array( segCount );
                        xmaxIds = new Uint32Array( segCount );
                        bucketCount = getBucketCount( segCount );
                        bucketOffsets = new Uint32Array( bucketCount + 1 );
                        boundsLeft = xx[ segments[ 0 ] ];
                        bucketWidth = ( xx[ segments[ segments.length - 2 ] ] - boundsLeft ) / bucketCount;
                        head = 0;
                        tail = segCount - 1;
                        while ( segId < segCount ) {
                            j = segId * 2;
                            a = segments[ j ];
                            b = segments[ j + 1 ];
                            xmin = xx[ a ];
                            xmax = xx[ b ];
                            prevBucketId = bucketId;
                            bucketId = getBucketId( xmin );
                            while ( bucketId > prevBucketId ) {
                                prevBucketId++;
                                bucketOffsets[ prevBucketId ] = head
                            }
                            if ( xmax - xmin >= 0 === false ) error( "Invalid segment" );
                            if ( getBucketId( xmax ) - bucketId > 1 ) {
                                xminIds[ tail ] = a;
                                xmaxIds[ tail ] = b;
                                tail--
                            } else {
                                xminIds[ head ] = a;
                                xmaxIds[ head ] = b;
                                head++
                            }
                            segId++
                        }
                        bucketOffsets[ bucketCount ] = head;
                        if ( head != tail + 1 ) error( "Segment indexing error" )
                    }
                }

                function PathIndex( shapes, arcs ) {
                    var _index;
                    var totalArea = MapShaper.getPathBounds( shapes, arcs ).area();
                    init( shapes );

                    function init( shapes ) {
                        var boxes = [];
                        shapes.forEach( function( shp, shpId ) {
                            var n = shp ? shp.length : 0;
                            for ( var i = 0; i < n; i++ ) {
                                addPath( shp[ i ], shpId )
                            }
                        } );
                        _index = require( "rbush" )();
                        _index.load( boxes );

                        function addPath( ids, shpId ) {
                            var bounds = arcs.getSimpleShapeBounds( ids );
                            var bbox = bounds.toArray();
                            bbox.ids = ids;
                            bbox.bounds = bounds;
                            bbox.id = shpId;
                            boxes.push( bbox );
                            if ( bounds.area() > totalArea * .02 ) {
                                bbox.index = new PolygonIndex( [ ids ], arcs )
                            }
                        }
                    }
                    this.findEnclosingShape = function( p ) {
                        var shpId = -1;
                        var shapes = findPointHitShapes( p );
                        shapes.forEach( function( paths ) {
                            if ( testPointInRings( p, paths ) ) {
                                shpId = paths[ 0 ].id
                            }
                        } );
                        return shpId
                    };
                    this.pointIsEnclosed = function( p ) {
                        return testPointInRings( p, findPointHitRings( p ) )
                    };
                    this.arcIsEnclosed = function( arcId ) {
                        return this.pointIsEnclosed( getTestPoint( arcId ) )
                    };
                    this.pathIsEnclosed = function( pathIds ) {
                        var arcId = pathIds[ 0 ];
                        var p = getTestPoint( arcId );
                        return this.pointIsEnclosed( p )
                    };
                    this.findEnclosedPaths = function( pathIds ) {
                        var pathBounds = arcs.getSimpleShapeBounds( pathIds ),
                            cands = _index.search( pathBounds.toArray() ),
                            paths = [],
                            index;
                        if ( cands.length > 6 ) {
                            index = new PolygonIndex( [ pathIds ], arcs )
                        }
                        cands.forEach( function( cand ) {
                            var p = getTestPoint( cand.ids[ 0 ] );
                            var isEnclosed = index ? index.pointInPolygon( p[ 0 ], p[ 1 ] ) : pathContainsPoint( pathIds, pathBounds, p );
                            if ( isEnclosed ) {
                                paths.push( cand.ids )
                            }
                        } );
                        return paths.length > 0 ? paths : null
                    };
                    this.findPathsInsideShape = function( shape ) {
                        var paths = [];
                        shape.forEach( function( ids ) {
                            var enclosed = this.findEnclosedPaths( ids );
                            if ( enclosed ) {
                                paths = xorArrays( paths, enclosed )
                            }
                        }, this );
                        return paths.length > 0 ? paths : null
                    };

                    function testPointInRings( p, cands ) {
                        var isOn = false,
                            isIn = false;
                        cands.forEach( function( cand ) {
                            var inRing = cand.index ? cand.index.pointInPolygon( p[ 0 ], p[ 1 ] ) : pathContainsPoint( cand.ids, cand.bounds, p );
                            if ( inRing == -1 ) {
                                isOn = true
                            } else if ( inRing == 1 ) {
                                isIn = !isIn
                            }
                        } );
                        return isOn || isIn
                    }

                    function findPointHitShapes( p ) {
                        var rings = findPointHitRings( p ),
                            shapes = [],
                            shape, bbox;
                        if ( rings.length > 0 ) {
                            rings.sort( function( a, b ) {
                                return a.id - b.id
                            } );
                            for ( var i = 0; i < rings.length; i++ ) {
                                bbox = rings[ i ];
                                if ( i === 0 || bbox.id != rings[ i - 1 ].id ) {
                                    shapes.push( shape = [] )
                                }
                                shape.push( bbox )
                            }
                        }
                        return shapes
                    }

                    function findPointHitRings( p ) {
                        var x = p[ 0 ],
                            y = p[ 1 ];
                        return _index.search( [ x, y, x, y ] )
                    }

                    function getTestPoint( arcId ) {
                        var p0 = arcs.getVertex( arcId, 0 ),
                            p1 = arcs.getVertex( arcId, 1 );
                        return [ ( p0.x + p1.x ) / 2, ( p0.y + p1.y ) / 2 ]
                    }

                    function pathContainsPoint( pathIds, pathBounds, p ) {
                        if ( pathBounds.containsPoint( p[ 0 ], p[ 1 ] ) === false ) return 0;
                        return geom.testPointInRing( p[ 0 ], p[ 1 ], pathIds, arcs )
                    }

                    function xorArrays( a, b ) {
                        var xor = [];
                        a.forEach( function( el ) {
                            if ( b.indexOf( el ) == -1 ) xor.push( el )
                        } );
                        b.forEach( function( el ) {
                            if ( xor.indexOf( el ) == -1 ) xor.push( el )
                        } );
                        return xor
                    }
                }
                geom.segmentIntersection = segmentIntersection;
                geom.segmentHit = segmentHit;
                geom.lineIntersection = lineIntersection;
                geom.orient2D = orient2D;
                geom.outsideRange = outsideRange;

                function segmentIntersection( ax, ay, bx, by, cx, cy, dx, dy ) {
                    var hit = segmentHit( ax, ay, bx, by, cx, cy, dx, dy ),
                        p = null;
                    if ( hit ) {
                        p = crossIntersection( ax, ay, bx, by, cx, cy, dx, dy );
                        if ( !p ) {
                            p = collinearIntersection( ax, ay, bx, by, cx, cy, dx, dy )
                        } else if ( endpointHit( ax, ay, bx, by, cx, cy, dx, dy ) ) {
                            p = null
                        }
                    }
                    return p
                }

                function lineIntersection( ax, ay, bx, by, cx, cy, dx, dy ) {
                    var den = determinant2D( bx - ax, by - ay, dx - cx, dy - cy );
                    var eps = 1e-18;
                    var m, p;
                    if ( den === 0 ) return null;
                    m = orient2D( cx, cy, dx, dy, ax, ay ) / den;
                    if ( den <= eps && den >= -eps ) {
                        p = findEndpointInRange( ax, ay, bx, by, cx, cy, dx, dy );
                        if ( !p ) {
                            trace( "[lineIntersection()]" );
                            geom.debugSegmentIntersection( [], ax, ay, bx, by, cx, cy, dx, dy )
                        }
                    } else {
                        p = [ ax + m * ( bx - ax ), ay + m * ( by - ay ) ]
                    }
                    return p
                }

                function findEndpointInRange( ax, ay, bx, by, cx, cy, dx, dy ) {
                    var p = null;
                    if ( !outsideRange( ax, cx, dx ) && !outsideRange( ay, cy, dy ) ) {
                        p = [ ax, ay ]
                    } else if ( !outsideRange( bx, cx, dx ) && !outsideRange( by, cy, dy ) ) {
                        p = [ bx, by ]
                    } else if ( !outsideRange( cx, ax, bx ) && !outsideRange( cy, ay, by ) ) {
                        p = [ cx, cy ]
                    } else if ( !outsideRange( dx, ax, bx ) && !outsideRange( dy, ay, by ) ) {
                        p = [ dx, dy ]
                    }
                    return p
                }

                function crossIntersection( ax, ay, bx, by, cx, cy, dx, dy ) {
                    var p = lineIntersection( ax, ay, bx, by, cx, cy, dx, dy );
                    var nearest;
                    if ( p ) {
                        nearest = nearestPoint( p[ 0 ], p[ 1 ], ax, ay, bx, by, cx, cy, dx, dy );
                        if ( nearest == 1 ) {
                            p = lineIntersection( bx, by, ax, ay, cx, cy, dx, dy )
                        } else if ( nearest == 2 ) {
                            p = lineIntersection( cx, cy, dx, dy, ax, ay, bx, by )
                        } else if ( nearest == 3 ) {
                            p = lineIntersection( dx, dy, cx, cy, ax, ay, bx, by )
                        }
                    }
                    if ( p ) {
                        clampIntersectionPoint( p, ax, ay, bx, by, cx, cy, dx, dy )
                    }
                    return p
                }

                function clampIntersectionPoint( p, ax, ay, bx, by, cx, cy, dx, dy ) {
                    var x = p[ 0 ],
                        y = p[ 1 ];
                    x = geom.clampToCloseRange( x, ax, bx );
                    x = geom.clampToCloseRange( x, cx, dx );
                    y = geom.clampToCloseRange( y, ay, by );
                    y = geom.clampToCloseRange( y, cy, dy );
                    p[ 0 ] = x;
                    p[ 1 ] = y
                }
                geom.debugSegmentIntersection = function( p, ax, ay, bx, by, cx, cy, dx, dy ) {
                    trace( "[debugSegmentIntersection()]" );
                    trace( "  s1\n  dx:", Math.abs( ax - bx ), "\n  dy:", Math.abs( ay - by ) );
                    trace( "  s2\n  dx:", Math.abs( cx - dx ), "\n  dy:", Math.abs( cy - dy ) );
                    trace( "  s1 xx:", ax, bx );
                    trace( "  s2 xx:", cx, dx );
                    trace( "  s1 yy:", ay, by );
                    trace( "  s2 yy:", cy, dy );
                    trace( "  angle:", geom.signedAngle( ax, ay, bx, by, dx - cx + bx, dy - cy + by ) )
                };

                function outsideRange( a, b, c ) {
                    var out;
                    if ( b < c ) {
                        out = a < b || a > c
                    } else if ( b > c ) {
                        out = a > b || a < c
                    } else {
                        out = a != b
                    }
                    return out
                }
                geom.clampToCloseRange = function( a, b, c ) {
                    var lim;
                    if ( geom.outsideRange( a, b, c ) ) {
                        lim = Math.abs( a - b ) < Math.abs( a - c ) ? b : c;
                        if ( Math.abs( a - lim ) > 1e-16 ) {
                            trace( "[clampToCloseRange()] large clamping interval", a, b, c )
                        }
                        a = lim
                    }
                    return a
                };

                function determinant2D( a, b, c, d ) {
                    return a * d - b * c
                }

                function orient2D( ax, ay, bx, by, cx, cy ) {
                    return determinant2D( ax - cx, ay - cy, bx - cx, by - cy )
                }

                function segmentHit( ax, ay, bx, by, cx, cy, dx, dy ) {
                    return orient2D( ax, ay, bx, by, cx, cy ) * orient2D( ax, ay, bx, by, dx, dy ) <= 0 && orient2D( cx, cy, dx, dy, ax, ay ) * orient2D( cx, cy, dx, dy, bx, by ) <= 0
                }

                function inside( x, minX, maxX ) {
                    return x > minX && x < maxX
                }

                function sortSeg( x1, y1, x2, y2 ) {
                    return x1 < x2 || x1 == x2 && y1 < y2 ? [ x1, y1, x2, y2 ] : [ x2, y2, x1, y1 ]
                }

                function collinearIntersection( ax, ay, bx, by, cx, cy, dx, dy ) {
                    var minX = Math.min( ax, bx, cx, dx ),
                        maxX = Math.max( ax, bx, cx, dx ),
                        minY = Math.min( ay, by, cy, dy ),
                        maxY = Math.max( ay, by, cy, dy ),
                        useY = maxY - minY > maxX - minX,
                        coords = [];
                    if ( useY ? inside( ay, minY, maxY ) : inside( ax, minX, maxX ) ) {
                        coords.push( ax, ay )
                    }
                    if ( useY ? inside( by, minY, maxY ) : inside( bx, minX, maxX ) ) {
                        coords.push( bx, by )
                    }
                    if ( useY ? inside( cy, minY, maxY ) : inside( cx, minX, maxX ) ) {
                        coords.push( cx, cy )
                    }
                    if ( useY ? inside( dy, minY, maxY ) : inside( dx, minX, maxX ) ) {
                        coords.push( dx, dy )
                    }
                    if ( coords.length != 2 && coords.length != 4 ) {
                        coords = null;
                        trace( "Invalid collinear segment intersection", coords )
                    } else if ( coords.length == 4 && coords[ 0 ] == coords[ 2 ] && coords[ 1 ] == coords[ 3 ] ) {
                        coords = null
                    }
                    return coords
                }

                function endpointHit( ax, ay, bx, by, cx, cy, dx, dy ) {
                    return ax == cx && ay == cy || ax == dx && ay == dy || bx == cx && by == cy || bx == dx && by == dy
                }
                MapShaper.getIntersectionPoints = function( intersections ) {
                    return intersections.map( function( obj ) {
                        return [ obj.x, obj.y ]
                    } )
                };
                MapShaper.findSegmentIntersections = function() {
                    var buf;

                    function getUint32Array( count ) {
                        var bytes = count * 4;
                        if ( !buf || buf.byteLength < bytes ) {
                            buf = new ArrayBuffer( bytes )
                        }
                        return new Uint32Array( buf, 0, count )
                    }
                    return function( arcs ) {
                        var bounds = arcs.getBounds(),
                            spherical = !arcs.isPlanar() && containsBounds( MapShaper.getWorldBounds(), bounds.toArray() ),
                            ymin = bounds.ymin,
                            yrange = bounds.ymax - ymin,
                            stripeCount = MapShaper.calcSegmentIntersectionStripeCount( arcs ),
                            stripeSizes = new Uint32Array( stripeCount ),
                            stripeId = stripeCount > 1 ? multiStripeId : singleStripeId,
                            i, j;

                        function multiStripeId( y ) {
                            return Math.floor( ( stripeCount - 1 ) * ( y - ymin ) / yrange )
                        }

                        function singleStripeId( y ) {
                            return 0
                        }
                        arcs.forEachSegment( function( id1, id2, xx, yy ) {
                            var s1 = stripeId( yy[ id1 ] ),
                                s2 = stripeId( yy[ id2 ] );
                            while ( true ) {
                                stripeSizes[ s1 ] = stripeSizes[ s1 ] + 2;
                                if ( s1 == s2 ) break;
                                s1 += s2 > s1 ? 1 : -1
                            }
                        } );
                        var stripeData = getUint32Array( utils.sum( stripeSizes ) ),
                            offs = 0;
                        var stripes = [];
                        utils.forEach( stripeSizes, function( stripeSize ) {
                            var start = offs;
                            offs += stripeSize;
                            stripes.push( stripeData.subarray( start, offs ) )
                        } );
                        utils.initializeArray( stripeSizes, 0 );
                        arcs.forEachSegment( function( id1, id2, xx, yy ) {
                            var s1 = stripeId( yy[ id1 ] ),
                                s2 = stripeId( yy[ id2 ] ),
                                count, stripe;
                            while ( true ) {
                                count = stripeSizes[ s1 ];
                                stripeSizes[ s1 ] = count + 2;
                                stripe = stripes[ s1 ];
                                stripe[ count ] = id1;
                                stripe[ count + 1 ] = id2;
                                if ( s1 == s2 ) break;
                                s1 += s2 > s1 ? 1 : -1
                            }
                        } );
                        var raw = arcs.getVertexData(),
                            intersections = [],
                            arr;
                        for ( i = 0; i < stripeCount; i++ ) {
                            arr = MapShaper.intersectSegments( stripes[ i ], raw.xx, raw.yy );
                            for ( j = 0; j < arr.length; j++ ) {
                                intersections.push( arr[ j ] )
                            }
                        }
                        return MapShaper.dedupIntersections( intersections )
                    }
                }();
                MapShaper.sortIntersections = function( arr ) {
                    arr.sort( function( a, b ) {
                        return a.x - b.x || a.y - b.y
                    } )
                };
                MapShaper.dedupIntersections = function( arr ) {
                    var index = {};
                    return arr.filter( function( o ) {
                        var key = MapShaper.getIntersectionKey( o );
                        if ( key in index ) {
                            return false
                        }
                        index[ key ] = true;
                        return true
                    } )
                };
                MapShaper.getIntersectionKey = function( o ) {
                    return o.a.join( "," ) + ";" + o.b.join( "," )
                };
                MapShaper.calcSegmentIntersectionStripeCount = function( arcs ) {
                    var yrange = arcs.getBounds().height(),
                        segLen = MapShaper.getAvgSegment2( arcs )[ 1 ],
                        count = 1;
                    if ( segLen > 0 && yrange > 0 ) {
                        count = Math.ceil( yrange / segLen / 20 )
                    }
                    return count || 1
                };
                MapShaper.intersectSegments = function( ids, xx, yy ) {
                    var lim = ids.length - 2,
                        intersections = [];
                    var s1p1, s1p2, s2p1, s2p2, s1p1x, s1p2x, s2p1x, s2p2x, s1p1y, s1p2y, s2p1y, s2p2y, hit, seg1, seg2, i, j;
                    MapShaper.sortSegmentIds( xx, ids );
                    i = 0;
                    while ( i < lim ) {
                        s1p1 = ids[ i ];
                        s1p2 = ids[ i + 1 ];
                        s1p1x = xx[ s1p1 ];
                        s1p2x = xx[ s1p2 ];
                        s1p1y = yy[ s1p1 ];
                        s1p2y = yy[ s1p2 ];
                        j = i;
                        while ( j < lim ) {
                            j += 2;
                            s2p1 = ids[ j ];
                            s2p1x = xx[ s2p1 ];
                            if ( s1p2x < s2p1x ) break;
                            s2p1y = yy[ s2p1 ];
                            s2p2 = ids[ j + 1 ];
                            s2p2x = xx[ s2p2 ];
                            s2p2y = yy[ s2p2 ];
                            if ( s1p1y >= s2p1y ) {
                                if ( s1p1y > s2p2y && s1p2y > s2p1y && s1p2y > s2p2y ) continue
                            } else {
                                if ( s1p1y < s2p2y && s1p2y < s2p1y && s1p2y < s2p2y ) continue
                            }
                            if ( s1p1 == s2p1 || s1p1 == s2p2 || s1p2 == s2p1 || s1p2 == s2p2 ) {
                                continue
                            }
                            hit = segmentIntersection( s1p1x, s1p1y, s1p2x, s1p2y, s2p1x, s2p1y, s2p2x, s2p2y );
                            if ( hit ) {
                                seg1 = [ s1p1, s1p2 ];
                                seg2 = [ s2p1, s2p2 ];
                                intersections.push( MapShaper.formatIntersection( hit, seg1, seg2, xx, yy ) );
                                if ( hit.length == 4 ) {
                                    intersections.push( MapShaper.formatIntersection( hit.slice( 2 ), seg1, seg2, xx, yy ) )
                                }
                            }
                        }
                        i += 2
                    }
                    return intersections;

                    function getEndpointIds( id1, id2, p ) {
                        var i = id1 < id2 ? id1 : id2,
                            j = i === id1 ? id2 : id1;
                        if ( xx[ i ] == p[ 0 ] && yy[ i ] == p[ 1 ] ) {
                            j = i
                        } else if ( xx[ j ] == p[ 0 ] && yy[ j ] == p[ 1 ] ) {
                            i = j
                        }
                        return [ i, j ]
                    }
                };
                MapShaper.formatIntersection = function( xy, s1, s2, xx, yy ) {
                    var x = xy[ 0 ],
                        y = xy[ 1 ],
                        a, b;
                    s1 = MapShaper.formatIntersectingSegment( x, y, s1[ 0 ], s1[ 1 ], xx, yy );
                    s2 = MapShaper.formatIntersectingSegment( x, y, s2[ 0 ], s2[ 1 ], xx, yy );
                    a = s1[ 0 ] < s2[ 0 ] ? s1 : s2;
                    b = a == s1 ? s2 : s1;
                    return {
                        x: x,
                        y: y,
                        a: a,
                        b: b
                    }
                };
                MapShaper.formatIntersectingSegment = function( x, y, id1, id2, xx, yy ) {
                    var i = id1 < id2 ? id1 : id2,
                        j = i === id1 ? id2 : id1;
                    if ( xx[ i ] == x && yy[ i ] == y ) {
                        j = i
                    } else if ( xx[ j ] == x && yy[ j ] == y ) {
                        i = j
                    }
                    return [ i, j ]
                };
                MapShaper.getSelfIntersectionSplitter = function( nodes ) {
                    return dividePath;

                    function dividePath( path ) {
                        var subPaths = null;
                        for ( var i = 0; i < path.length - 1; i++ ) {
                            subPaths = dividePathAtNode( path, path[ i ] );
                            if ( subPaths ) {
                                return subPaths
                            }
                        }
                        MapShaper.removeSpikesInPath( path );
                        return path.length > 0 ? [ path ] : []
                    }

                    function dividePathAtNode( path, enterId ) {
                        var nodeIds = nodes.getConnectedArcs( enterId ),
                            exitIds = [],
                            outId;
                        for ( var i = 0; i < nodeIds.length; i++ ) {
                            outId = ~nodeIds[ i ];
                            if ( contains( path, outId ) ) {
                                exitIds.push( outId )
                            }
                        }
                        if ( exitIds.length > 1 ) {
                            return MapShaper.splitPathByIds( path, exitIds ).reduce( accumulatePaths, null )
                        }
                        return null
                    }

                    function accumulatePaths( memo, path ) {
                        var subPaths = dividePath( path );
                        return memo ? memo.concat( subPaths ) : subPaths
                    }

                    function contains( arr, el ) {
                        for ( var i = 0, n = arr.length; i < n; i++ ) {
                            if ( arr[ i ] === el ) return true
                        }
                        return false
                    }
                };
                MapShaper.splitPathByIds = function( path, ids ) {
                    var subPaths = [];
                    var indexes = ids.map( function( id ) {
                        var i = path.indexOf( id );
                        if ( i == -1 ) error( "[splitPathByIds()] missing arc:", id );
                        return i
                    } );
                    utils.genericSort( indexes, true );
                    if ( indexes[ 0 ] > 0 ) {
                        subPaths.push( path.slice( 0, indexes[ 0 ] ) )
                    }
                    for ( var i = 0, n = indexes.length; i < n; i++ ) {
                        if ( i < n - 1 ) {
                            subPaths.push( path.slice( indexes[ i ], indexes[ i + 1 ] ) )
                        } else {
                            subPaths.push( path.slice( indexes[ i ] ) )
                        }
                    }
                    if ( subPaths.length > ids.length ) {
                        subPaths[ 0 ] = subPaths[ 0 ].concat( subPaths.pop() )
                    }
                    return subPaths
                };
                MapShaper.getHoleDivider = function( nodes, spherical ) {
                    var split = MapShaper.getSelfIntersectionSplitter( nodes );
                    return function( rings, cw, ccw ) {
                        var pathArea = spherical ? geom.getSphericalPathArea : geom.getPlanarPathArea;
                        MapShaper.forEachPath( rings, function( ringIds ) {
                            var splitRings = split( ringIds );
                            if ( splitRings.length === 0 ) {
                                trace( "[getRingDivider()] Defective path:", ringIds )
                            }
                            splitRings.forEach( function( ringIds, i ) {
                                var ringArea = pathArea( ringIds, nodes.arcs );
                                if ( ringArea > 0 ) {
                                    cw.push( ringIds )
                                } else if ( ringArea < 0 ) {
                                    ccw.push( ringIds )
                                }
                            } )
                        } )
                    }
                };
                MapShaper.cleanShapes = function( shapes, arcs, type ) {
                    for ( var i = 0, n = shapes.length; i < n; i++ ) {
                        shapes[ i ] = MapShaper.cleanShape( shapes[ i ], arcs, type )
                    }
                };
                MapShaper.cleanShape = function( shape, arcs, type ) {
                    return MapShaper.editPaths( shape, function( path ) {
                        var cleaned = MapShaper.cleanPath( path, arcs );
                        if ( type == "polygon" && cleaned ) {
                            MapShaper.removeSpikesInPath( cleaned );
                            if ( geom.getPlanarPathArea( cleaned, arcs ) === 0 ) {
                                cleaned = null
                            }
                        }
                        return cleaned
                    } )
                };
                MapShaper.cleanPath = function( path, arcs ) {
                    var nulls = 0;
                    for ( var i = 0, n = path.length; i < n; i++ ) {
                        if ( arcs.arcIsDegenerate( path[ i ] ) ) {
                            nulls++;
                            path[ i ] = null
                        }
                    }
                    return nulls > 0 ? path.filter( function( id ) {
                        return id !== null
                    } ) : path
                };
                MapShaper.removeSpikesInPath = function( ids ) {
                    var n = ids.length;
                    if ( n >= 2 ) {
                        if ( ids[ 0 ] == ~ids[ n - 1 ] ) {
                            ids.pop();
                            ids.shift()
                        } else {
                            for ( var i = 1; i < n; i++ ) {
                                if ( ids[ i - 1 ] == ~ids[ i ] ) {
                                    ids.splice( i - 1, 2 );
                                    break
                                }
                            }
                        }
                        if ( ids.length < n ) {
                            MapShaper.removeSpikesInPath( ids )
                        }
                    }
                };
                MapShaper.repairPolygonGeometry = function( layers, dataset, opts ) {
                    var nodes = MapShaper.addIntersectionCuts( dataset );
                    layers.forEach( function( lyr ) {
                        MapShaper.repairSelfIntersections( lyr, nodes )
                    } );
                    return layers
                };
                MapShaper.repairSelfIntersections = function( lyr, nodes ) {
                    var splitter = MapShaper.getSelfIntersectionSplitter( nodes );
                    lyr.shapes = lyr.shapes.map( function( shp, i ) {
                        return cleanPolygon( shp )
                    } );

                    function cleanPolygon( shp ) {
                        var cleanedPolygon = [];
                        MapShaper.forEachPath( shp, function( ids ) {
                            var splitIds = splitter( ids );
                            if ( splitIds.length === 0 ) {
                                error( "[cleanPolygon()] Defective path:", ids )
                            } else if ( splitIds.length == 1 ) {
                                cleanedPolygon.push( splitIds[ 0 ] )
                            } else {
                                var shapeArea = geom.getPlanarPathArea( ids, nodes.arcs ),
                                    sign = shapeArea > 0 ? 1 : -1,
                                    mainRing;
                                var maxArea = splitIds.reduce( function( max, ringIds, i ) {
                                    var pathArea = geom.getPlanarPathArea( ringIds, nodes.arcs ) * sign;
                                    if ( pathArea > max ) {
                                        mainRing = ringIds;
                                        max = pathArea
                                    }
                                    return max
                                }, 0 );
                                if ( mainRing ) {
                                    cleanedPolygon.push( mainRing )
                                }
                            }
                        } );
                        return cleanedPolygon.length > 0 ? cleanedPolygon : null
                    }
                };
                MapShaper.addIntersectionCuts = function( dataset, opts ) {
                    var arcs = dataset.arcs;
                    var snapDist = MapShaper.getHighPrecisionSnapInterval( arcs );
                    var snapCount = opts && opts.no_snap ? 0 : MapShaper.snapCoordsByInterval( arcs, snapDist );
                    var dupeCount = arcs.dedupCoords();
                    if ( snapCount > 0 || dupeCount > 0 ) {
                        api.buildTopology( dataset )
                    }
                    var map = MapShaper.divideArcs( arcs );
                    var nodes = new NodeCollection( arcs );
                    dataset.layers.forEach( function( lyr ) {
                        if ( MapShaper.layerHasPaths( lyr ) ) {
                            MapShaper.updateArcIds( lyr.shapes, map, nodes );
                            MapShaper.cleanShapes( lyr.shapes, arcs, lyr.geometry_type )
                        }
                    } );
                    return nodes
                };
                MapShaper.divideArcs = function( arcs ) {
                    var points = MapShaper.findClippingPoints( arcs );
                    var map = MapShaper.insertCutPoints( points, arcs );
                    arcs.dedupCoords();
                    return map
                };
                MapShaper.insertCutPoints = function( unfilteredPoints, arcs ) {
                    var data = arcs.getVertexData(),
                        xx0 = data.xx,
                        yy0 = data.yy,
                        nn0 = data.nn,
                        i0 = 0,
                        i1 = 0,
                        nn1 = [],
                        srcArcTotal = arcs.size(),
                        map = new Uint32Array( srcArcTotal ),
                        points = MapShaper.filterSortedCutPoints( MapShaper.sortCutPoints( unfilteredPoints, xx0, yy0 ), arcs ),
                        destPointTotal = arcs.getPointCount() + points.length * 2,
                        xx1 = new Float64Array( destPointTotal ),
                        yy1 = new Float64Array( destPointTotal ),
                        n0, n1, arcLen, p;
                    points.reverse();
                    p = points.pop();
                    for ( var srcArcId = 0, destArcId = 0; srcArcId < srcArcTotal; srcArcId++ ) {
                        arcLen = nn0[ srcArcId ];
                        map[ srcArcId ] = destArcId;
                        n0 = 0;
                        n1 = 0;
                        while ( n0 < arcLen ) {
                            xx1[ i1 ] = xx0[ i0 ];
                            yy1[ i1 ] = yy0[ i0 ];
                            i1++;
                            n1++;
                            while ( p && p.i == i0 ) {
                                xx1[ i1 ] = p.x;
                                yy1[ i1 ] = p.y;
                                i1++;
                                n1++;
                                nn1[ destArcId++ ] = n1;
                                n1 = 0;
                                xx1[ i1 ] = p.x;
                                yy1[ i1 ] = p.y;
                                i1++;
                                n1++;
                                p = points.pop()
                            }
                            n0++;
                            i0++
                        }
                        nn1[ destArcId++ ] = n1
                    }
                    if ( i1 != destPointTotal ) error( "[insertCutPoints()] Counting error" );
                    arcs.updateVertexData( nn1, xx1, yy1, null );
                    return map
                };
                MapShaper.convertIntersectionsToCutPoints = function( intersections, xx, yy ) {
                    var points = [],
                        ix, a, b;
                    for ( var i = 0, n = intersections.length; i < n; i++ ) {
                        ix = intersections[ i ];
                        a = MapShaper.getCutPoint( ix.x, ix.y, ix.a[ 0 ], ix.a[ 1 ], xx, yy );
                        b = MapShaper.getCutPoint( ix.x, ix.y, ix.b[ 0 ], ix.b[ 1 ], xx, yy );
                        if ( a ) points.push( a );
                        if ( b ) points.push( b )
                    }
                    return points
                };
                MapShaper.getCutPoint = function( x, y, i, j, xx, yy ) {
                    var ix = xx[ i ],
                        iy = yy[ i ],
                        jx = xx[ j ],
                        jy = yy[ j ];
                    if ( j < i || j > i + 1 ) {
                        error( "Out-of-sequence arc ids:", i, j )
                    }
                    if ( geom.outsideRange( x, ix, jx ) || geom.outsideRange( y, iy, jy ) ) {
                        trace( "[getCutPoint()] Coordinate range error" );
                        return null
                    }
                    return {
                        x: x,
                        y: y,
                        i: i
                    }
                };
                MapShaper.sortCutPoints = function( points, xx, yy ) {
                    points.sort( function( a, b ) {
                        return a.i - b.i || Math.abs( a.x - xx[ a.i ] ) - Math.abs( b.x - xx[ b.i ] ) || Math.abs( a.y - yy[ a.i ] ) - Math.abs( b.y - yy[ b.i ] )
                    } );
                    return points
                };
                MapShaper.filterSortedCutPoints = function( points, arcs ) {
                    var filtered = [],
                        pointId = 0;
                    arcs.forEach2( function( i, n, xx, yy ) {
                        var j = i + n - 1,
                            x0 = xx[ i ],
                            y0 = yy[ i ],
                            xn = xx[ j ],
                            yn = yy[ j ],
                            p, pp;
                        while ( pointId < points.length && points[ pointId ].i <= j ) {
                            p = points[ pointId ];
                            pp = filtered[ filtered.length - 1 ];
                            if ( p.x == x0 && p.y == y0 || p.x == xn && p.y == yn ) {} else if ( pp && pp.x == p.x && pp.y == p.y && pp.i == p.i ) {} else {
                                filtered.push( p )
                            }
                            pointId++
                        }
                    } );
                    return filtered
                };
                MapShaper.findClippingPoints = function( arcs ) {
                    var intersections = MapShaper.findSegmentIntersections( arcs ),
                        data = arcs.getVertexData();
                    return MapShaper.convertIntersectionsToCutPoints( intersections, data.xx, data.yy )
                };
                MapShaper.updateArcIds = function( shapes, map, nodes ) {
                    var arcCount = nodes.arcs.size(),
                        shape2;
                    for ( var i = 0; i < shapes.length; i++ ) {
                        shape2 = [];
                        MapShaper.forEachPath( shapes[ i ], remapPathIds );
                        shapes[ i ] = shape2
                    }

                    function remapPathIds( ids ) {
                        if ( !ids ) return;
                        var ids2 = [];
                        for ( var j = 0; j < ids.length; j++ ) {
                            remapArcId( ids[ j ], ids2 )
                        }
                        shape2.push( ids2 )
                    }

                    function remapArcId( id, ids ) {
                        var rev = id < 0,
                            absId = rev ? ~id : id,
                            min = map[ absId ],
                            max = ( absId >= map.length - 1 ? arcCount : map[ absId + 1 ] ) - 1,
                            id2;
                        do {
                            if ( rev ) {
                                id2 = ~max;
                                max--
                            } else {
                                id2 = min;
                                min++
                            }
                            if ( nodes ) {
                                id2 = nodes.findMatchingArc( id2 )
                            }
                            ids.push( id2 )
                        } while ( max - min >= 0 )
                    }
                };
                MapShaper.getRightmostArc = function( arcId, nodes, filter ) {
                    var ids = nodes.getConnectedArcs( arcId );
                    if ( filter ) {
                        ids = ids.filter( filter )
                    }
                    if ( ids.length === 0 ) {
                        return arcId
                    }
                    return MapShaper.getRighmostArc2( arcId, ids, nodes.arcs )
                };
                MapShaper.getRighmostArc2 = function( fromId, ids, arcs ) {
                    var coords = arcs.getVertexData(),
                        xx = coords.xx,
                        yy = coords.yy,
                        inode = arcs.indexOfVertex( fromId, -1 ),
                        nodeX = xx[ inode ],
                        nodeY = yy[ inode ],
                        ifrom = arcs.indexOfVertex( fromId, -2 ),
                        fromX = xx[ ifrom ],
                        fromY = yy[ ifrom ],
                        toId = fromId,
                        ito, candId, icand, code, j;
                    if ( ids.length > 0 ) {
                        toId = ids[ 0 ];
                        ito = arcs.indexOfVertex( toId, -2 )
                    }
                    for ( j = 1; j < ids.length; j++ ) {
                        candId = ids[ j ];
                        icand = arcs.indexOfVertex( candId, -2 );
                        code = MapShaper.chooseRighthandPath( fromX, fromY, nodeX, nodeY, xx[ ito ], yy[ ito ], xx[ icand ], yy[ icand ] );
                        if ( code == 2 ) {
                            toId = candId;
                            ito = icand
                        }
                    }
                    if ( toId == fromId ) {
                        error( "Pathfinder error" )
                    }
                    return toId
                };
                MapShaper.chooseRighthandPath = function( fromX, fromY, nodeX, nodeY, ax, ay, bx, by ) {
                    var angleA = geom.signedAngle( fromX, fromY, nodeX, nodeY, ax, ay );
                    var angleB = geom.signedAngle( fromX, fromY, nodeX, nodeY, bx, by );
                    var code;
                    if ( angleA <= 0 || angleB <= 0 ) {
                        trace( "[chooseRighthandPath()] 0 angle(s):", angleA, angleB );
                        if ( angleA <= 0 ) {
                            trace( "  A orient2D:", geom.orient2D( fromX, fromY, nodeX, nodeY, ax, ay ) )
                        }
                        if ( angleB <= 0 ) {
                            trace( "  B orient2D:", geom.orient2D( fromX, fromY, nodeX, nodeY, bx, by ) )
                        }
                        if ( angleA > 0 ) {
                            code = 1
                        } else if ( angleB > 0 ) {
                            code = 2
                        } else {
                            code = 0
                        }
                    } else if ( angleA < angleB ) {
                        code = 1
                    } else if ( angleB < angleA ) {
                        code = 2
                    } else if ( isNaN( angleA ) || isNaN( angleB ) ) {
                        error( "Invalid node geometry" )
                    } else {
                        code = MapShaper.chooseRighthandVector( ax - nodeX, ay - nodeY, bx - nodeX, by - nodeY );
                        trace( "[chooseRighthandVector()] code:", code, "angle:", angleA );
                        trace( fromX, fromY, nodeX, nodeY, ax, ay, bx, by )
                    }
                    return code
                };
                MapShaper.chooseRighthandVector = function( ax, ay, bx, by ) {
                    var orient = geom.orient2D( ax, ay, 0, 0, bx, by );
                    var code;
                    if ( orient > 0 ) {
                        code = 2
                    } else if ( orient < 0 ) {
                        code = 1
                    } else {
                        code = 0
                    }
                    return code
                };
                MapShaper.setBits = function( src, flags, mask ) {
                    return src & ~mask | flags & mask
                };
                MapShaper.andBits = function( src, flags, mask ) {
                    return src & ( ~mask | flags )
                };
                MapShaper.setRouteBits = function( bits, id, flags ) {
                    var abs = absArcId( id ),
                        mask;
                    if ( abs == id ) {
                        mask = ~3
                    } else {
                        mask = ~48;
                        bits = bits << 4
                    }
                    flags[ abs ] &= bits | mask
                };
                MapShaper.getRouteBits = function( id, flags ) {
                    var abs = absArcId( id ),
                        bits = flags[ abs ];
                    if ( abs != id ) bits = bits >> 4;
                    return bits & 7
                };
                MapShaper.openArcRoutes = function( arcIds, arcs, flags, fwd, rev, dissolve, orBits ) {
                    MapShaper.forEachArcId( arcIds, function( id ) {
                        var isInv = id < 0,
                            absId = isInv ? ~id : id,
                            currFlag = flags[ absId ],
                            openFwd = isInv ? rev : fwd,
                            openRev = isInv ? fwd : rev,
                            newFlag = currFlag;
                        if ( arcs.arcIsLollipop( id ) ) {
                            trace( "lollipop" );
                            newFlag = 0
                        } else {
                            if ( openFwd ) {
                                newFlag |= 3
                            }
                            if ( openRev ) {
                                newFlag |= 48
                            }
                            if ( orBits > 0 ) {
                                newFlag |= orBits
                            }
                            if ( dissolve && ( newFlag & 34 ) === 34 ) {
                                newFlag &= ~17
                            }
                        }
                        flags[ absId ] = newFlag
                    } )
                };
                MapShaper.closeArcRoutes = function( arcIds, arcs, flags, fwd, rev, hide ) {
                    MapShaper.forEachArcId( arcIds, function( id ) {
                        var isInv = id < 0,
                            absId = isInv ? ~id : id,
                            currFlag = flags[ absId ],
                            mask = 255,
                            closeFwd = isInv ? rev : fwd,
                            closeRev = isInv ? fwd : rev;
                        if ( closeFwd ) {
                            if ( hide ) mask &= ~1;
                            mask ^= 2
                        }
                        if ( closeRev ) {
                            if ( hide ) mask &= ~16;
                            mask ^= 32
                        }
                        flags[ absId ] = currFlag & mask
                    } )
                };
                MapShaper.getPathFinder = function( nodes, useRoute, routeIsUsable ) {
                    function filterArc( arcId ) {
                        return routeIsUsable( ~arcId )
                    }

                    function getNextArc( prevId ) {
                        return ~MapShaper.getRightmostArc( prevId, nodes, filterArc )
                    }
                    return function( startId ) {
                        var path = [],
                            nextId, msg, candId = startId;
                        do {
                            if ( useRoute( candId ) ) {
                                path.push( candId );
                                nextId = candId;
                                candId = getNextArc( nextId )
                            } else {
                                return null
                            }
                            if ( candId == ~nextId ) {
                                message( "Pathfinder warning: dead-end path" );
                                return null
                            }
                        } while ( candId != startId );
                        return path.length === 0 ? null : path
                    }
                };
                MapShaper.getRingIntersector = function( nodes, type, flags ) {
                    var arcs = nodes.arcs;
                    var findPath = MapShaper.getPathFinder( nodes, useRoute, routeIsActive );
                    flags = flags || new Uint8Array( arcs.size() );
                    return function( rings ) {
                        var dissolve = type == "dissolve",
                            openFwd = true,
                            openRev = type == "flatten",
                            output;
                        if ( rings.length > 0 ) {
                            output = [];
                            MapShaper.openArcRoutes( rings, arcs, flags, openFwd, openRev, dissolve );
                            MapShaper.forEachPath( rings, function( ids ) {
                                var path;
                                for ( var i = 0, n = ids.length; i < n; i++ ) {
                                    path = findPath( ids[ i ] );
                                    if ( path ) {
                                        output.push( path )
                                    }
                                }
                            } );
                            MapShaper.closeArcRoutes( rings, arcs, flags, openFwd, openRev, true )
                        } else {
                            output = rings
                        }
                        return output
                    };

                    function routeIsActive( arcId ) {
                        var bits = MapShaper.getRouteBits( arcId, flags );
                        return ( bits & 1 ) == 1
                    }

                    function useRoute( arcId ) {
                        var route = MapShaper.getRouteBits( arcId, flags ),
                            isOpen = false;
                        if ( route == 3 ) {
                            isOpen = true;
                            MapShaper.setRouteBits( 1, arcId, flags )
                        }
                        return isOpen
                    }
                };
                MapShaper.debugFlags = function( flags ) {
                    var arr = [];
                    utils.forEach( flags, function( flag ) {
                        arr.push( bitsToString( flag ) )
                    } );
                    message( arr );

                    function bitsToString( bits ) {
                        var str = "";
                        for ( var i = 0; i < 8; i++ ) {
                            str += ( bits & 1 << i ) > 0 ? "1" : "0";
                            if ( i < 7 ) str += " ";
                            if ( i == 3 ) str += " "
                        }
                        return str
                    }
                };
                MapShaper.getEncodings = function() {
                    var iconv = require( "iconv-lite" );
                    iconv.encodingExists( "ascii" );
                    return Object.keys( iconv.encodings )
                };
                MapShaper.validateEncoding = function( enc ) {
                    if ( !MapShaper.encodingIsSupported( enc ) ) {
                        stop( "Unknown encoding:", enc, "\nRun the -encodings command see a list of supported encodings" )
                    }
                    return enc
                };
                MapShaper.encodingIsSupported = function( raw ) {
                    var enc = MapShaper.standardizeEncodingName( raw );
                    return utils.contains( MapShaper.getEncodings(), enc )
                };
                MapShaper.decodeString = function( buf, encoding ) {
                    var iconv = require( "iconv-lite" ),
                        str = iconv.decode( buf, encoding );
                    if ( str.charCodeAt( 0 ) == 65279 ) {
                        str = str.substr( 1 )
                    }
                    return str
                };
                MapShaper.standardizeEncodingName = function( enc ) {
                    return enc.toLowerCase().replace( /[_-]/g, "" )
                };
                MapShaper.printEncodings = function() {
                    var encodings = MapShaper.getEncodings().filter( function( name ) {
                        return !/^(_|cs|internal|ibm|isoir|singlebyte|table|[0-9]|l[0-9]|windows)/.test( name )
                    } );
                    encodings.sort();
                    message( "Supported encodings:" );
                    message( MapShaper.formatStringsAsGrid( encodings ) )
                };
                MapShaper.detectEncoding = function( samples ) {
                    var encoding = null;
                    if ( MapShaper.looksLikeUtf8( samples ) ) {
                        encoding = "utf8"
                    } else if ( MapShaper.looksLikeWin1252( samples ) ) {
                        encoding = "win1252"
                    }
                    return encoding
                };
                MapShaper.decodeSamples = function( enc, samples ) {
                    return samples.map( function( buf ) {
                        return MapShaper.decodeString( buf, enc ).trim()
                    } ).join( "\n" )
                };
                MapShaper.formatSamples = function( str ) {
                    return MapShaper.formatStringsAsGrid( str.split( "\n" ) )
                };
                MapShaper.looksLikeWin1252 = function( samples ) {
                    var ascii = "abcdefghijklmnopqrstuvwxyz0123456789.'\"?+-\n,:;/|_$% ",
                        extended = "",
                        str = MapShaper.decodeSamples( "win1252", samples ),
                        asciiScore = MapShaper.getCharScore( str, ascii ),
                        totalScore = MapShaper.getCharScore( str, extended + ascii );
                    return totalScore > .97 && asciiScore > .7
                };
                MapShaper.looksLikeUtf8 = function( samples ) {
                    var str = MapShaper.decodeSamples( "utf8", samples );
                    return str.indexOf( "" ) == -1
                };
                MapShaper.getCharScore = function( str, chars ) {
                    var index = {},
                        count = 0,
                        score;
                    str = str.toLowerCase();
                    for ( var i = 0, n = chars.length; i < n; i++ ) {
                        index[ chars[ i ] ] = 1
                    }
                    for ( i = 0, n = str.length; i < n; i++ ) {
                        count += index[ str[ i ] ] || 0
                    }
                    return count / str.length
                };
                MapShaper.insertFieldValues = function( lyr, fieldName, values ) {
                    var size = MapShaper.getFeatureCount( lyr ) || values.length,
                        table = lyr.data = lyr.data || new DataTable( size ),
                        records = table.getRecords(),
                        rec;
                    for ( var i = 0; i < size; i++ ) {
                        rec = records[ i ] = records[ i ] || {};
                        rec[ fieldName ] = i in values ? values[ i ] : null
                    }
                };
                MapShaper.getValueType = function( val ) {
                    var type = null;
                    if ( utils.isString( val ) ) {
                        type = "string"
                    } else if ( utils.isNumber( val ) ) {
                        type = "number"
                    } else if ( utils.isBoolean( val ) ) {
                        type = "boolean"
                    } else if ( utils.isObject( val ) ) {
                        type = "object"
                    }
                    return type
                };
                MapShaper.fixInconsistentFields = function( records ) {
                    var fields = MapShaper.findIncompleteFields( records );
                    MapShaper.patchMissingFields( records, fields )
                };
                MapShaper.findIncompleteFields = function( records ) {
                    var counts = {},
                        i, j, keys;
                    for ( i = 0; i < records.length; i++ ) {
                        keys = Object.keys( records[ i ] || {} );
                        for ( j = 0; j < keys.length; j++ ) {
                            counts[ keys[ j ] ] = ( counts[ keys[ j ] ] | 0 ) + 1
                        }
                    }
                    return Object.keys( counts ).filter( function( k ) {
                        return counts[ k ] < records.length
                    } )
                };
                MapShaper.patchMissingFields = function( records, fields ) {
                    var rec, i, j, f;
                    for ( i = 0; i < records.length; i++ ) {
                        rec = records[ i ] || ( records[ i ] = {} );
                        for ( j = 0; j < fields.length; j++ ) {
                            f = fields[ j ];
                            if ( f in rec === false ) {
                                rec[ f ] = undefined
                            }
                        }
                    }
                };
                MapShaper.getColumnType = function( key, table ) {
                    var type = null,
                        records = table.getRecords(),
                        rec;
                    for ( var i = 0, n = table.size(); i < n; i++ ) {
                        rec = records[ i ] || {};
                        type = MapShaper.getValueType( rec[ key ] );
                        if ( type ) break
                    }
                    return type
                };
                MapShaper.deleteFields = function( table, test ) {
                    table.getFields().forEach( function( name ) {
                        if ( test( name ) ) {
                            table.deleteField( name )
                        }
                    } )
                };
                MapShaper.isInvalidFieldName = function( f ) {
                    return /^\s*$/.test( f )
                };
                MapShaper.getUniqFieldNames = function( fields, maxLen ) {
                    var used = {};
                    return fields.map( function( name ) {
                        var i = 0,
                            validName;
                        do {
                            validName = MapShaper.adjustFieldName( name, maxLen, i );
                            i++
                        } while ( validName in used );
                        used[ validName ] = true;
                        return validName
                    } )
                };
                MapShaper.adjustFieldName = function( name, maxLen, i ) {
                    var name2, suff;
                    maxLen = maxLen || 256;
                    if ( !i ) {
                        name2 = name.substr( 0, maxLen )
                    } else {
                        suff = String( i );
                        if ( suff.length == 1 ) {
                            suff = "_" + suff
                        }
                        name2 = name.substr( 0, maxLen - suff.length ) + suff
                    }
                    return name2
                };
                var Dbf = {};
                Dbf.languageIds = [ 1, "437", 2, "850", 3, "1252", 8, "865", 9, "437", 10, "850", 11, "437", 13, "437", 14, "850", 15, "437", 16, "850", 17, "437", 18, "850", 19, "932", 20, "850", 21, "437", 22, "850", 23, "865", 24, "437", 25, "437", 26, "850", 27, "437", 28, "863", 29, "850", 31, "852", 34, "852", 35, "852", 36, "860", 37, "850", 38, "866", 55, "850", 64, "852", 77, "936", 78, "949", 79, "950", 80, "874", 87, "1252", 88, "1252", 89, "1252", 100, "852", 101, "866", 102, "865", 103, "861", 106, "737", 107, "857", 108, "863", 120, "950", 121, "949", 122, "936", 123, "932", 124, "874", 134, "737", 135, "852", 136, "857", 200, "1250", 201, "1251", 202, "1254", 203, "1253", 204, "1257" ];
                Dbf.encodingNames = {
                    932: "Japanese",
                    936: "Simplified Chinese",
                    950: "Traditional Chinese",
                    1252: "Western European",
                    949: "Korean",
                    874: "Thai",
                    1250: "Eastern European",
                    1251: "Russian",
                    1254: "Turkish",
                    1253: "Greek",
                    1257: "Baltic"
                };
                Dbf.ENCODING_PROMPT = 'To avoid corrupted text, re-import using the "encoding=" option.\n' + 'To see a list of supported encodings, run the "encodings" command.';
                Dbf.lookupCodePage = function( lid ) {
                    var i = Dbf.languageIds.indexOf( lid );
                    return i == -1 ? null : Dbf.languageIds[ i + 1 ]
                };
                Dbf.readAsciiString = function( bin, size ) {
                    var require7bit = true;
                    var str = bin.readCString( size, require7bit );
                    if ( str === null ) {
                        stop( "DBF file contains non-ascii text.\n" + Dbf.ENCODING_PROMPT )
                    }
                    return utils.trim( str )
                };
                Dbf.readStringBytes = function( bin, size, buf ) {
                    var count = 0,
                        c;
                    for ( var i = 0; i < size; i++ ) {
                        c = bin.readUint8();
                        if ( c === 0 ) break;
                        if ( count > 0 || c != 32 ) {
                            buf[ count++ ] = c
                        }
                    }
                    while ( count > 0 && buf[ count - 1 ] == 32 ) {
                        count--
                    }
                    return count
                };
                Dbf.getAsciiStringReader = function() {
                    var buf = new Uint8Array( 256 );
                    return function readAsciiString( bin, size ) {
                        var str = "",
                            n = Dbf.readStringBytes( bin, size, buf );
                        for ( var i = 0; i < n; i++ ) {
                            str += String.fromCharCode( buf[ i ] )
                        }
                        return str
                    }
                };
                Dbf.getEncodedStringReader = function( encoding ) {
                    var buf = new Buffer( 256 ),
                        isUtf8 = MapShaper.standardizeEncodingName( encoding ) == "utf8";
                    return function readEncodedString( bin, size ) {
                        var i = Dbf.readStringBytes( bin, size, buf ),
                            str;
                        if ( i === 0 ) {
                            str = ""
                        } else if ( isUtf8 ) {
                            str = buf.toString( "utf8", 0, i )
                        } else {
                            str = MapShaper.decodeString( buf.slice( 0, i ), encoding )
                        }
                        return str
                    }
                };
                Dbf.getStringReader = function( encoding ) {
                    if ( !encoding || encoding === "ascii" ) {
                        return Dbf.getAsciiStringReader()
                    } else {
                        return Dbf.getEncodedStringReader( encoding )
                    }
                };
                Dbf.bufferContainsHighBit = function( buf, n ) {
                    for ( var i = 0; i < n; i++ ) {
                        if ( buf[ i ] >= 128 ) return true
                    }
                    return false
                };
                Dbf.getNumberReader = function() {
                    var read = Dbf.getAsciiStringReader();
                    return function readNumber( bin, size ) {
                        var str = read( bin, size );
                        var val;
                        if ( str.indexOf( "," ) >= 0 ) {
                            str = str.replace( ",", "." )
                        }
                        val = parseFloat( str );
                        return isNaN( val ) ? null : val
                    }
                };
                Dbf.readInt = function( bin, size ) {
                    return bin.readInt32()
                };
                Dbf.readBool = function( bin, size ) {
                    var c = bin.readCString( size ),
                        val = null;
                    if ( /[ty]/i.test( c ) ) val = true;
                    else if ( /[fn]/i.test( c ) ) val = false;
                    return val
                };
                Dbf.readDate = function( bin, size ) {
                    var str = bin.readCString( size ),
                        yr = str.substr( 0, 4 ),
                        mo = str.substr( 4, 2 ),
                        day = str.substr( 6, 2 );
                    return new Date( Date.UTC( +yr, +mo - 1, +day ) )
                };

                function DbfReader( src, encodingArg ) {
                    if ( utils.isString( src ) ) {
                        error( "[DbfReader] Expected a buffer, not a string" )
                    }
                    var bin = new BinArray( src );
                    var header = readHeader( bin );
                    var encoding = encodingArg || null;
                    this.size = function() {
                        return header.recordCount
                    };
                    this.readRow = function( i ) {
                        return getRecordReader( header.fields )( i )
                    };
                    this.getFields = getFieldNames;
                    this.getBuffer = function() {
                        return bin.buffer()
                    };
                    this.deleteField = function( f ) {
                        header.fields = header.fields.filter( function( field ) {
                            return field.name != f
                        } )
                    };
                    this.readRows = function() {
                        var reader = getRecordReader( header.fields );
                        var data = [];
                        for ( var r = 0, n = this.size(); r < n; r++ ) {
                            data.push( reader( r ) )
                        }
                        return data
                    };

                    function readHeader( bin ) {
                        bin.position( 0 ).littleEndian();
                        var header = {
                            version: bin.readInt8(),
                            updateYear: bin.readUint8(),
                            updateMonth: bin.readUint8(),
                            updateDay: bin.readUint8(),
                            recordCount: bin.readUint32(),
                            dataOffset: bin.readUint16(),
                            recordSize: bin.readUint16(),
                            incompleteTransaction: bin.skipBytes( 2 ).readUint8(),
                            encrypted: bin.readUint8(),
                            mdx: bin.skipBytes( 12 ).readUint8(),
                            ldid: bin.readUint8()
                        };
                        var colOffs = 1;
                        var field;
                        bin.skipBytes( 2 );
                        header.fields = [];
                        while ( bin.peek() != 13 && bin.peek() != 10 && bin.position() < header.dataOffset - 1 ) {
                            field = readFieldHeader( bin );
                            field.columnOffset = colOffs;
                            header.fields.push( field );
                            colOffs += field.size
                        }
                        if ( colOffs != header.recordSize ) {
                            error( "Record length mismatch; header:", header.recordSize, "detected:", colOffs )
                        }
                        if ( bin.peek() != 13 ) {
                            message( "[dbf] Found a non-standard header terminator (" + bin.peek() + "). DBF file may be corrupted." )
                        }
                        MapShaper.getUniqFieldNames( utils.pluck( header.fields, "name" ) ).forEach( function( name2, i ) {
                            header.fields[ i ].name = name2
                        } );
                        return header
                    }

                    function readFieldHeader( bin ) {
                        return {
                            name: bin.readCString( 11 ),
                            type: String.fromCharCode( bin.readUint8() ),
                            address: bin.readUint32(),
                            size: bin.readUint8(),
                            decimals: bin.readUint8(),
                            id: bin.skipBytes( 2 ).readUint8(),
                            position: bin.skipBytes( 2 ).readUint8(),
                            indexFlag: bin.skipBytes( 7 ).readUint8()
                        }
                    }

                    function getFieldNames() {
                        return utils.pluck( header.fields, "name" )
                    }

                    function getRowOffset( r ) {
                        return header.dataOffset + header.recordSize * r
                    }

                    function getEncoding() {
                        if ( !encoding ) {
                            encoding = findStringEncoding();
                            if ( !encoding ) {
                                encoding = "utf8";
                                stop( "Unable to auto-detect the text encoding of the DBF file.\n" + Dbf.ENCODING_PROMPT )
                            }
                        }
                        return encoding
                    }

                    function getRecordConstructor() {
                        var args = getFieldNames().map( function( name, i ) {
                            return JSON.stringify( name ) + ": arguments[" + i + "]"
                        } );
                        return new Function( "return {" + args.join( "," ) + "};" )
                    }

                    function findEofPos( bin ) {
                        var pos = bin.size() - 1;
                        if ( bin.peek( pos ) != 26 ) {
                            pos++
                        }
                        return pos
                    }

                    function getRecordReader( fields ) {
                        var readers = fields.map( getFieldReader ),
                            eofOffs = findEofPos( bin ),
                            create = getRecordConstructor(),
                            values = [];
                        return function readRow( r ) {
                            var offs = getRowOffset( r ),
                                fieldOffs, field;
                            for ( var c = 0, cols = fields.length; c < cols; c++ ) {
                                field = fields[ c ];
                                fieldOffs = offs + field.columnOffset;
                                if ( fieldOffs + field.size > eofOffs ) {
                                    stop( "[dbf] Invalid DBF file: encountered end-of-file while reading data" )
                                }
                                bin.position( fieldOffs );
                                values[ c ] = readers[ c ]( bin, field.size )
                            }
                            return create.apply( null, values )
                        }
                    }

                    function getFieldReader( f ) {
                        var type = f.type,
                            r = null;
                        if ( type == "I" ) {
                            r = Dbf.readInt
                        } else if ( type == "F" || type == "N" ) {
                            r = Dbf.getNumberReader()
                        } else if ( type == "L" ) {
                            r = Dbf.readBool
                        } else if ( type == "D" ) {
                            r = Dbf.readDate
                        } else if ( type == "C" ) {
                            r = Dbf.getStringReader( getEncoding() )
                        } else {
                            message( '[dbf] Field "' + field.name + '" has an unsupported type (' + field.type + ") -- converting to null values" );
                            r = function() {
                                return null
                            }
                        }
                        return r
                    }

                    function findStringEncoding() {
                        var ldid = header.ldid,
                            codepage = Dbf.lookupCodePage( ldid ),
                            samples = getNonAsciiSamples( 50 ),
                            only7bit = samples.length === 0,
                            encoding, msg;
                        if ( codepage && ldid != 87 ) {
                            encoding = codepage
                        } else if ( only7bit ) {
                            encoding = "ascii"
                        }
                        if ( !encoding ) {
                            encoding = MapShaper.detectEncoding( samples )
                        }
                        if ( encoding && samples.length > 0 ) {
                            msg = "Detected DBF text encoding: " + encoding;
                            if ( encoding in Dbf.encodingNames ) {
                                msg += " (" + Dbf.encodingNames[ encoding ] + ")"
                            }
                            message( msg );
                            msg = MapShaper.decodeSamples( encoding, samples );
                            msg = MapShaper.formatStringsAsGrid( msg.split( "\n" ) );
                            message( "Sample text containing non-ascii characters:" + ( msg.length > 60 ? "\n" : "" ) + msg )
                        }
                        return encoding
                    }

                    function getNonAsciiSamples( size ) {
                        var samples = [];
                        var stringFields = header.fields.filter( function( f ) {
                            return f.type == "C"
                        } );
                        var buf = new Buffer( 256 );
                        var index = {};
                        var f, chars, sample, hash;
                        for ( var r = 0, rows = header.recordCount; r < rows; r++ ) {
                            for ( var c = 0, cols = stringFields.length; c < cols; c++ ) {
                                if ( samples.length >= size ) break;
                                f = stringFields[ c ];
                                bin.position( getRowOffset( r ) + f.columnOffset );
                                chars = Dbf.readStringBytes( bin, f.size, buf );
                                if ( chars > 0 && Dbf.bufferContainsHighBit( buf, chars ) ) {
                                    sample = new Buffer( buf.slice( 0, chars ) );
                                    hash = sample.toString( "hex" );
                                    if ( hash in index === false ) {
                                        index[ hash ] = true;
                                        samples.push( sample )
                                    }
                                }
                            }
                        }
                        return samples
                    }
                }
                Dbf.MAX_STRING_LEN = 254;
                Dbf.exportRecords = function( arr, encoding ) {
                    encoding = encoding || "ascii";
                    var fields = Dbf.getFieldNames( arr );
                    var uniqFields = MapShaper.getUniqFieldNames( fields, 10 );
                    var rows = arr.length;
                    var fieldData = fields.map( function( name ) {
                        return Dbf.getFieldInfo( arr, name, encoding )
                    } );
                    var headerBytes = Dbf.getHeaderSize( fieldData.length ),
                        recordBytes = Dbf.getRecordSize( utils.pluck( fieldData, "size" ) ),
                        fileBytes = headerBytes + rows * recordBytes + 1;
                    var buffer = new ArrayBuffer( fileBytes );
                    var bin = new BinArray( buffer ).littleEndian();
                    var now = new Date;
                    bin.writeUint8( 3 );
                    bin.writeUint8( now.getFullYear() - 1900 );
                    bin.writeUint8( now.getMonth() + 1 );
                    bin.writeUint8( now.getDate() );
                    bin.writeUint32( rows );
                    bin.writeUint16( headerBytes );
                    bin.writeUint16( recordBytes );
                    bin.skipBytes( 17 );
                    bin.writeUint8( 0 );
                    bin.skipBytes( 2 );
                    fieldData.reduce( function( recordOffset, obj, i ) {
                        var fieldName = uniqFields[ i ];
                        bin.writeCString( fieldName, 11 );
                        bin.writeUint8( obj.type.charCodeAt( 0 ) );
                        bin.writeUint32( recordOffset );
                        bin.writeUint8( obj.size );
                        bin.writeUint8( obj.decimals );
                        bin.skipBytes( 14 );
                        return recordOffset + obj.size
                    }, 1 );
                    bin.writeUint8( 13 );
                    if ( bin.position() != headerBytes ) {
                        error( "Dbf#exportRecords() header size mismatch; expected:", headerBytes, "written:", bin.position() )
                    }
                    arr.forEach( function( rec, i ) {
                        var start = bin.position();
                        bin.writeUint8( 32 );
                        for ( var j = 0, n = fieldData.length; j < n; j++ ) {
                            fieldData[ j ].write( i, bin )
                        }
                        if ( bin.position() - start != recordBytes ) {
                            error( "#exportRecords() Error exporting record:", rec )
                        }
                    } );
                    bin.writeUint8( 26 );
                    if ( bin.position() != fileBytes ) {
                        error( "Dbf#exportRecords() file size mismatch; expected:", fileBytes, "written:", bin.position() )
                    }
                    return buffer
                };
                Dbf.getFieldNames = function( records ) {
                    if ( !records || !records.length ) {
                        return []
                    }
                    var names = Object.keys( records[ 0 ] );
                    names.sort();
                    return names
                };
                Dbf.getHeaderSize = function( numFields ) {
                    return 33 + numFields * 32
                };
                Dbf.getRecordSize = function( fieldSizes ) {
                    return utils.sum( fieldSizes ) + 1
                };
                Dbf.initNumericField = function( info, arr, name ) {
                    var MAX_FIELD_SIZE = 18,
                        data, size;
                    data = this.getNumericFieldInfo( arr, name );
                    info.decimals = data.decimals;
                    size = Math.max( data.max.toFixed( info.decimals ).length, data.min.toFixed( info.decimals ).length );
                    if ( size > MAX_FIELD_SIZE ) {
                        size = MAX_FIELD_SIZE;
                        info.decimals -= size - MAX_FIELD_SIZE;
                        if ( info.decimals < 0 ) {
                            error( "Dbf#getFieldInfo() Out-of-range error." )
                        }
                    }
                    info.size = size;
                    var formatter = Dbf.getDecimalFormatter( size, info.decimals );
                    info.write = function( i, bin ) {
                        var rec = arr[ i ],
                            str = formatter( rec[ name ] );
                        if ( str.length < size ) {
                            str = utils.lpad( str, size, " " )
                        }
                        bin.writeString( str, size )
                    }
                };
                Dbf.initBooleanField = function( info, arr, name ) {
                    info.size = 1;
                    info.write = function( i, bin ) {
                        var val = arr[ i ][ name ],
                            c;
                        if ( val === true ) c = "T";
                        else if ( val === false ) c = "F";
                        else c = "?";
                        bin.writeString( c )
                    }
                };
                Dbf.initDateField = function( info, arr, name ) {
                    info.size = 8;
                    info.write = function( i, bin ) {
                        var d = arr[ i ][ name ],
                            str;
                        if ( d instanceof Date === false ) {
                            str = "00000000"
                        } else {
                            str = utils.lpad( d.getUTCFullYear(), 4, "0" ) + utils.lpad( d.getUTCMonth() + 1, 2, "0" ) + utils.lpad( d.getUTCDate(), 2, "0" )
                        }
                        bin.writeString( str )
                    }
                };
                Dbf.initStringField = function( info, arr, name, encoding ) {
                    var formatter = Dbf.getStringWriter( encoding );
                    var size = 0;
                    var values = arr.map( function( rec ) {
                        var buf = formatter( rec[ name ] );
                        size = Math.max( size, buf.byteLength );
                        return buf
                    } );
                    info.size = size;
                    info.write = function( i, bin ) {
                        var buf = values[ i ],
                            bytes = Math.min( size, buf.byteLength ),
                            idx = bin.position();
                        bin.writeBuffer( buf, bytes, 0 );
                        bin.position( idx + size )
                    }
                };
                Dbf.getFieldInfo = function( arr, name, encoding ) {
                    var type = this.discoverFieldType( arr, name ),
                        info = {
                            name: name,
                            type: type,
                            decimals: 0
                        };
                    if ( type == "N" ) {
                        Dbf.initNumericField( info, arr, name )
                    } else if ( type == "C" ) {
                        Dbf.initStringField( info, arr, name, encoding )
                    } else if ( type == "L" ) {
                        Dbf.initBooleanField( info, arr, name )
                    } else if ( type == "D" ) {
                        Dbf.initDateField( info, arr, name )
                    } else {
                        info.size = 0;
                        info.type = "N";
                        info.write = function() {}
                    }
                    return info
                };
                Dbf.discoverFieldType = function( arr, name ) {
                    var val;
                    for ( var i = 0, n = arr.length; i < n; i++ ) {
                        val = arr[ i ][ name ];
                        if ( utils.isString( val ) ) return "C";
                        if ( utils.isNumber( val ) ) return "N";
                        if ( utils.isBoolean( val ) ) return "L";
                        if ( val instanceof Date ) return "D"
                    }
                    return null
                };
                Dbf.getDecimalFormatter = function( size, decimals ) {
                    var nullValue = " ";
                    return function( val ) {
                        var valid = utils.isFiniteNumber( val ),
                            strval = valid ? val.toFixed( decimals ) : String( nullValue );
                        return utils.lpad( strval, size, " " )
                    }
                };
                Dbf.getNumericFieldInfo = function( arr, name ) {
                    var min = 0,
                        max = 0,
                        k = 1,
                        power = 1,
                        decimals = 0,
                        eps = 1e-15,
                        val;
                    for ( var i = 0, n = arr.length; i < n; i++ ) {
                        val = arr[ i ][ name ];
                        if ( !utils.isFiniteNumber( val ) ) {
                            continue
                        }
                        if ( val < min || val > max ) {
                            if ( val < min ) min = val;
                            if ( val > max ) max = val;
                            while ( Math.abs( val ) >= power ) {
                                power *= 10;
                                eps *= 10
                            }
                        }
                        while ( Math.abs( Math.round( val * k ) - val * k ) > eps ) {
                            if ( decimals == 15 ) {
                                break
                            }
                            decimals++;
                            eps *= 10;
                            k *= 10
                        }
                    }
                    return {
                        decimals: decimals,
                        min: min,
                        max: max
                    }
                };
                Dbf.getStringWriter = function( encoding ) {
                    if ( encoding === "ascii" ) {
                        return Dbf.getStringWriterAscii()
                    } else {
                        return Dbf.getStringWriterEncoded( encoding )
                    }
                };
                Dbf.getStringWriterAscii = function() {
                    return function( val ) {
                        var str = String( val ),
                            n = Math.min( str.length, Dbf.MAX_STRING_LEN ),
                            dest = new ArrayBuffer( n ),
                            view = new Uint8ClampedArray( dest );
                        for ( var i = 0; i < n; i++ ) {
                            view[ i ] = str.charCodeAt( i )
                        }
                        return dest
                    }
                };
                Dbf.getStringWriterEncoded = function( encoding ) {
                    var iconv = require( "iconv-lite" );
                    return function( val ) {
                        var buf = iconv.encode( val, encoding );
                        if ( buf.length >= Dbf.MAX_STRING_LEN ) {
                            buf = Dbf.truncateEncodedString( buf, encoding, Dbf.MAX_STRING_LEN )
                        }
                        return BinArray.toArrayBuffer( buf )
                    }
                };
                Dbf.truncateEncodedString = function( buf, encoding, maxLen ) {
                    var truncated = buf.slice( 0, maxLen );
                    var len = maxLen;
                    var tmp, str;
                    while ( len > 0 && len >= maxLen - 3 ) {
                        tmp = len == maxLen ? truncated : buf.slice( 0, len );
                        str = MapShaper.decodeString( tmp, encoding );
                        if ( str.charAt( str.length - 1 ) != "" ) {
                            truncated = tmp;
                            break
                        }
                        len--
                    }
                    return truncated
                };
                var dataFieldRxp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;

                function DataTable( obj ) {
                    var records;
                    if ( utils.isArray( obj ) ) {
                        records = obj
                    } else {
                        records = [];
                        if ( utils.isInteger( obj ) ) {
                            for ( var i = 0; i < obj; i++ ) {
                                records.push( {} )
                            }
                        } else if ( obj ) {
                            error( "[DataTable] Invalid constructor argument:", obj )
                        }
                    }
                    this.exportAsDbf = function( encoding ) {
                        return Dbf.exportRecords( records, encoding )
                    };
                    this.getRecords = function() {
                        return records
                    };
                    this.getRecordAt = function( i ) {
                        return records[ i ]
                    }
                }
                var dataTableProto = {
                    fieldExists: function( name ) {
                        return utils.contains( this.getFields(), name )
                    },
                    toString: function() {
                        return JSON.stringify( this )
                    },
                    toJSON: function() {
                        return this.getRecords()
                    },
                    addField: function( name, init ) {
                        var useFunction = utils.isFunction( init );
                        if ( !utils.isNumber( init ) && !utils.isString( init ) && !useFunction ) {
                            error( "DataTable#addField() requires a string, number or function for initialization" )
                        }
                        if ( this.fieldExists( name ) ) error( "DataTable#addField() tried to add a field that already exists:", name );
                        if ( !dataFieldRxp.test( name ) ) error( "DataTable#addField() invalid field name:", name );
                        this.getRecords().forEach( function( obj, i ) {
                            obj[ name ] = useFunction ? init( obj, i ) : init
                        } )
                    },
                    addIdField: function() {
                        this.addField( "FID", function( obj, i ) {
                            return i
                        } )
                    },
                    deleteField: function( f ) {
                        this.getRecords().forEach( function( o ) {
                            delete o[ f ]
                        } )
                    },
                    getFields: function() {
                        var records = this.getRecords(),
                            first = records[ 0 ];
                        return first ? Object.keys( first ) : []
                    },
                    update: function( f ) {
                        var records = this.getRecords();
                        for ( var i = 0, n = records.length; i < n; i++ ) {
                            records[ i ] = f( records[ i ], i )
                        }
                    },
                    clone: function() {
                        var records2 = this.getRecords().map( function( rec ) {
                            return utils.extend( {}, rec )
                        } );
                        return new DataTable( records2 )
                    },
                    size: function() {
                        return this.getRecords().length
                    }
                };
                utils.extend( DataTable.prototype, dataTableProto );
                MapShaper.getCategoryClassifier = function( field, data ) {
                    if ( !field ) return function( i ) {
                        return 0
                    };
                    if ( !data || !data.fieldExists( field ) ) {
                        stop( "[dissolve] Data table is missing field:", field )
                    }
                    var index = {},
                        count = 0,
                        records = data.getRecords();
                    return function( i ) {
                        var val = String( records[ i ][ field ] );
                        if ( val in index === false ) {
                            index[ val ] = count++
                        }
                        return index[ val ]
                    }
                };
                MapShaper.aggregateDataRecords = function( properties, getGroupId, opts ) {
                    var arr = [];
                    var sumFields = opts.sum_fields || [],
                        copyFields = opts.copy_fields || [];
                    if ( opts.field ) {
                        copyFields.push( opts.field )
                    }
                    properties.forEach( function( rec, i ) {
                        if ( !rec ) return;
                        var idx = getGroupId( i ),
                            dissolveRec;
                        if ( idx in arr ) {
                            dissolveRec = arr[ idx ]
                        } else {
                            arr[ idx ] = dissolveRec = {};
                            copyFields.forEach( function( f ) {
                                dissolveRec[ f ] = rec[ f ]
                            } )
                        }
                        sumFields.forEach( function( f ) {
                            dissolveRec[ f ] = ( rec[ f ] || 0 ) + ( dissolveRec[ f ] || 0 )
                        } )
                    } );
                    return arr
                };
                MapShaper.simplifyArcsFast = function( arcs, dist ) {
                    var xx = [],
                        yy = [],
                        nn = [],
                        count;
                    for ( var i = 0, n = arcs.size(); i < n; i++ ) {
                        count = MapShaper.simplifyPathFast( [ i ], arcs, dist, xx, yy );
                        if ( count == 1 ) {
                            count = 0;
                            xx.pop();
                            yy.pop()
                        }
                        nn.push( count )
                    }
                    return new ArcCollection( nn, xx, yy )
                };
                MapShaper.simplifyPolygonFast = function( shp, arcs, dist ) {
                    if ( !shp || !dist ) return null;
                    var xx = [],
                        yy = [],
                        nn = [],
                        shp2 = [];
                    shp.forEach( function( path ) {
                        var count = MapShaper.simplifyPathFast( path, arcs, dist, xx, yy );
                        while ( count < 4 && count > 0 ) {
                            xx.pop();
                            yy.pop();
                            count--
                        }
                        if ( count > 0 ) {
                            shp2.push( [ nn.length ] );
                            nn.push( count )
                        }
                    } );
                    return {
                        shape: shp2.length > 0 ? shp2 : null,
                        arcs: new ArcCollection( nn, xx, yy )
                    }
                };
                MapShaper.simplifyPathFast = function( path, arcs, dist, xx, yy ) {
                    var iter = arcs.getShapeIter( path ),
                        count = 0,
                        prevX, prevY, x, y;
                    while ( iter.hasNext() ) {
                        x = iter.x;
                        y = iter.y;
                        if ( count === 0 || distance2D( x, y, prevX, prevY ) > dist ) {
                            xx.push( x );
                            yy.push( y );
                            prevX = x;
                            prevY = y;
                            count++
                        }
                    }
                    if ( x != prevX || y != prevY ) {
                        xx.push( x );
                        yy.push( y );
                        count++
                    }
                    return count
                };
                geom.getShapeCentroid = function( shp, arcs ) {
                    var maxPath = geom.getMaxPath( shp, arcs );
                    return maxPath ? geom.getPathCentroid( maxPath, arcs ) : null
                };
                geom.getPathCentroid = function( ids, arcs ) {
                    var iter = arcs.getShapeIter( ids ),
                        sum = 0,
                        sumX = 0,
                        sumY = 0,
                        ax, ay, tmp, area;
                    if ( !iter.hasNext() ) return null;
                    ax = iter.x;
                    ay = iter.y;
                    while ( iter.hasNext() ) {
                        tmp = ax * iter.y - ay * iter.x;
                        sum += tmp;
                        sumX += tmp * ( iter.x + ax );
                        sumY += tmp * ( iter.y + ay );
                        ax = iter.x;
                        ay = iter.y
                    }
                    area = sum / 2;
                    if ( area === 0 ) {
                        return geom.getAvgPathXY( ids, arcs )
                    } else return {
                        x: sumX / ( 6 * area ),
                        y: sumY / ( 6 * area )
                    }
                };
                geom.findInteriorPoint = function( shp, arcs ) {
                    var maxPath = shp && geom.getMaxPath( shp, arcs ),
                        pathBounds = maxPath && arcs.getSimpleShapeBounds( maxPath ),
                        thresh, simple;
                    if ( !pathBounds || !pathBounds.hasBounds() || pathBounds.area() === 0 ) {
                        return null
                    }
                    thresh = Math.sqrt( pathBounds.area() ) * .01;
                    simple = MapShaper.simplifyPolygonFast( shp, arcs, thresh );
                    if ( !simple.shape ) {
                        return null
                    }
                    return geom.findInteriorPoint2( simple.shape, simple.arcs )
                };
                geom.findInteriorPoint2 = function( shp, arcs ) {
                    var maxPath = geom.getMaxPath( shp, arcs );
                    var pathBounds = arcs.getSimpleShapeBounds( maxPath );
                    var centroid = geom.getPathCentroid( maxPath, arcs );
                    var weight = MapShaper.getPointWeightingFunction( centroid, pathBounds );
                    var area = geom.getPlanarPathArea( maxPath, arcs );
                    var hrange, lbound, rbound, focus, htics, hstep, p, p2;
                    if ( shp.length == 1 && area * 1.2 > pathBounds.area() ) {
                        htics = 5;
                        focus = .2
                    } else if ( shp.length == 1 && area * 1.7 > pathBounds.area() ) {
                        htics = 7;
                        focus = .4
                    } else {
                        htics = 11;
                        focus = .5
                    }
                    hrange = pathBounds.width() * focus;
                    lbound = centroid.x - hrange / 2;
                    rbound = lbound + hrange;
                    hstep = hrange / htics;
                    p = MapShaper.probeForBestInteriorPoint( shp, arcs, lbound, rbound, htics, weight );
                    if ( !p ) {
                        verbose( "[points inner] failed, falling back to centroid" );
                        p = centroid
                    } else {
                        p2 = MapShaper.probeForBestInteriorPoint( shp, arcs, p.x - hstep / 2, p.x + hstep / 2, 2, weight );
                        if ( p2.distance > p.distance ) {
                            p = p2
                        }
                    }
                    return p
                };
                MapShaper.getPointWeightingFunction = function( centroid, pathBounds ) {
                    var referenceDist = Math.max( pathBounds.width(), pathBounds.height() ) / 2;
                    return function( x, y ) {
                        var offset = distance2D( centroid.x, centroid.y, x, y );
                        return 1 - Math.min( .6 * offset / referenceDist, .25 )
                    }
                };
                MapShaper.findInteriorPointCandidates = function( shp, arcs, xx ) {
                    var ymin = arcs.getBounds().ymin - 1;
                    return xx.reduce( function( memo, x ) {
                        var cands = MapShaper.findHitCandidates( x, ymin, shp, arcs );
                        return memo.concat( cands )
                    }, [] )
                };
                MapShaper.probeForBestInteriorPoint = function( shp, arcs, lbound, rbound, htics, weight ) {
                    var tics = MapShaper.getInnerTics( lbound, rbound, htics );
                    var interval = ( rbound - lbound ) / htics;
                    var candidates = MapShaper.findInteriorPointCandidates( shp, arcs, tics );
                    var bestP, adjustedP, candP;
                    candidates.forEach( function( p ) {
                        p.interval *= weight( p.x, p.y )
                    } );
                    candidates.sort( function( a, b ) {
                        return b.interval - a.interval
                    } );
                    for ( var i = 0; i < candidates.length; i++ ) {
                        candP = candidates[ i ];
                        if ( bestP && bestP.distance > candP.interval ) {
                            break
                        }
                        adjustedP = MapShaper.getAdjustedPoint( candP.x, candP.y, shp, arcs, interval, weight );
                        if ( !bestP || adjustedP.distance > bestP.distance ) {
                            bestP = adjustedP
                        }
                    }
                    return bestP
                };
                MapShaper.getAdjustedPoint = function( x, y, shp, arcs, vstep, weight ) {
                    var p = {
                        x: x,
                        y: y,
                        distance: geom.getPointToShapeDistance( x, y, shp, arcs ) * weight( x, y )
                    };
                    MapShaper.scanForBetterPoint( p, shp, arcs, vstep, weight );
                    MapShaper.scanForBetterPoint( p, shp, arcs, -vstep, weight );
                    return p
                };
                MapShaper.scanForBetterPoint = function( p, shp, arcs, vstep, weight ) {
                    var x = p.x,
                        y = p.y,
                        dmax = p.distance,
                        d;
                    while ( true ) {
                        y += vstep;
                        d = geom.getPointToShapeDistance( x, y, shp, arcs ) * weight( x, y );
                        if ( d > dmax * .9 && geom.testPointInPolygon( x, y, shp, arcs ) ) {
                            if ( d > dmax ) {
                                p.distance = dmax = d;
                                p.y = y
                            }
                        } else {
                            break
                        }
                    }
                };
                MapShaper.findHitCandidates = function( x, y, shp, arcs ) {
                    var yy = MapShaper.findRayShapeIntersections( x, y, shp, arcs );
                    var cands = [],
                        y1, y2, interval;
                    utils.genericSort( yy );
                    for ( var i = 0; i < yy.length; i += 2 ) {
                        y1 = yy[ i ];
                        y2 = yy[ i + 1 ];
                        interval = ( y2 - y1 ) / 2;
                        if ( interval > 0 ) {
                            cands.push( {
                                y: ( y1 + y2 ) / 2,
                                x: x,
                                interval: interval
                            } )
                        }
                    }
                    return cands
                };
                MapShaper.findRayShapeIntersections = function( x, y, shp, arcs ) {
                    if ( !shp ) return [];
                    return shp.reduce( function( memo, path ) {
                        var yy = MapShaper.findRayRingIntersections( x, y, path, arcs );
                        return memo.concat( yy )
                    }, [] )
                };
                MapShaper.findRayRingIntersections = function( x, y, path, arcs ) {
                    var yints = [];
                    MapShaper.forEachPathSegment( path, arcs, function( a, b, xx, yy ) {
                        var result = geom.getRayIntersection( x, y, xx[ a ], yy[ a ], xx[ b ], yy[ b ] );
                        if ( result > -Infinity ) {
                            yints.push( result )
                        }
                    } );
                    if ( yints.length % 2 === 1 ) {
                        yints = []
                    }
                    return yints
                };
                MapShaper.getInnerTics = function( min, max, steps ) {
                    var range = max - min,
                        step = range / ( steps + 1 ),
                        arr = [];
                    for ( var i = 1; i <= steps; i++ ) {
                        arr.push( min + step * i )
                    }
                    return arr
                };

                function addGetters( obj, getters ) {
                    Object.keys( getters ).forEach( function( name ) {
                        Object.defineProperty( obj, name, {
                            get: getters[ name ]
                        } )
                    } )
                }
                MapShaper.initFeatureProxy = function( lyr, arcs ) {
                    var hasPoints = MapShaper.layerHasPoints( lyr ),
                        hasPaths = arcs && MapShaper.layerHasPaths( lyr ),
                        _records = lyr.data ? lyr.data.getRecords() : null,
                        _isPlanar = hasPaths && arcs.isPlanar(),
                        ctx = {},
                        _bounds, _centroid, _innerXY, _xy, _ids, _id;
                    addGetters( ctx, {
                        id: function() {
                            return _id
                        }
                    } );
                    if ( _records ) {
                        Object.defineProperty( ctx, "properties", {
                            set: function( obj ) {
                                if ( utils.isObject( obj ) ) {
                                    _records[ _id ] = obj
                                } else {
                                    stop( "Can't assign non-object to $.properties" )
                                }
                            },
                            get: function() {
                                var rec = _records[ _id ];
                                if ( !rec ) {
                                    rec = _records[ _id ] = {}
                                }
                                return rec
                            }
                        } )
                    }
                    if ( hasPaths ) {
                        addGetters( ctx, {
                            partCount: function() {
                                return _ids ? _ids.length : 0
                            },
                            isNull: function() {
                                return ctx.partCount === 0
                            },
                            bounds: function() {
                                return shapeBounds().toArray()
                            },
                            height: function() {
                                return shapeBounds().height()
                            },
                            width: function() {
                                return shapeBounds().width()
                            }
                        } );
                        if ( lyr.geometry_type == "polygon" ) {
                            addGetters( ctx, {
                                area: function() {
                                    return _isPlanar ? ctx.planarArea : geom.getSphericalShapeArea( _ids, arcs )
                                },
                                planarArea: function() {
                                    return geom.getPlanarShapeArea( _ids, arcs )
                                },
                                originalArea: function() {
                                    var i = arcs.getRetainedInterval(),
                                        area;
                                    arcs.setRetainedInterval( 0 );
                                    area = ctx.area;
                                    arcs.setRetainedInterval( i );
                                    return area
                                },
                                centroidX: function() {
                                    var p = centroid();
                                    return p ? p.x : null
                                },
                                centroidY: function() {
                                    var p = centroid();
                                    return p ? p.y : null
                                },
                                innerX: function() {
                                    var p = innerXY();
                                    return p ? p.x : null
                                },
                                innerY: function() {
                                    var p = innerXY();
                                    return p ? p.y : null
                                }
                            } )
                        }
                    } else if ( hasPoints ) {
                        Object.defineProperty( ctx, "coordinates", {
                            set: function( obj ) {
                                if ( !obj || utils.isArray( obj ) ) {
                                    lyr.shapes[ _id ] = obj || null
                                } else {
                                    stop( "Can't assign non-array to $.coordinates" )
                                }
                            },
                            get: function() {
                                return lyr.shapes[ _id ] || null
                            }
                        } );
                        addGetters( ctx, {
                            x: function() {
                                xy();
                                return _xy ? _xy[ 0 ] : null
                            },
                            y: function() {
                                xy();
                                return _xy ? _xy[ 1 ] : null
                            }
                        } )
                    }

                    function xy() {
                        var shape = lyr.shapes[ _id ];
                        if ( !_xy ) {
                            _xy = shape && shape[ 0 ] || null
                        }
                        return _xy
                    }

                    function centroid() {
                        _centroid = _centroid || geom.getShapeCentroid( _ids, arcs );
                        return _centroid
                    }

                    function innerXY() {
                        _innerXY = _innerXY || geom.findInteriorPoint( _ids, arcs );
                        return _innerXY
                    }

                    function shapeBounds() {
                        if ( !_bounds ) {
                            _bounds = arcs.getMultiShapeBounds( _ids )
                        }
                        return _bounds
                    }
                    return function( id ) {
                        _id = id;
                        if ( hasPaths ) {
                            _bounds = null;
                            _centroid = null;
                            _innerXY = null;
                            _ids = lyr.shapes[ id ]
                        }
                        if ( hasPoints ) {
                            _xy = null
                        }
                        return ctx
                    }
                };
                MapShaper.compileValueExpression = function( exp, lyr, arcs ) {
                    return MapShaper.compileFeatureExpression( exp, lyr, arcs, {
                        returns: true
                    } )
                };
                MapShaper.compileFeatureExpression = function( rawExp, lyr, arcs, opts ) {
                    var exp = rawExp || "",
                        vars = MapShaper.getAssignedVars( exp ),
                        func, records;
                    if ( vars.length > 0 && !lyr.data ) {
                        MapShaper.initDataTable( lyr )
                    }
                    records = lyr.data ? lyr.data.getRecords() : [];
                    func = MapShaper.getExpressionFunction( exp, lyr, arcs, opts );
                    return function( recId ) {
                        var record = records[ recId ];
                        if ( !record ) {
                            record = records[ recId ] = {}
                        }
                        for ( var i = 0; i < vars.length; i++ ) {
                            if ( vars[ i ] in record === false ) {
                                record[ vars[ i ] ] = null
                            }
                        }
                        return func( record, recId )
                    }
                };
                MapShaper.getAssignedVars = function( exp ) {
                    var rxp = /[A-Za-z_][A-Za-z0-9_]*(?= *=[^=])/g;
                    return exp.match( rxp ) || []
                };
                MapShaper.getExpressionFunction = function( exp, lyr, arcs, opts ) {
                    var getFeatureById = MapShaper.initFeatureProxy( lyr, arcs );
                    var ctx = MapShaper.getExpressionContext( lyr, opts && opts.context );
                    var functionBody = "with(env){with(record){ " + ( opts && opts.returns ? "return " : "" ) + exp + "}}";
                    var func;
                    try {
                        func = new Function( "record,env", functionBody )
                    } catch ( e ) {
                        stop( e.name, "in expression [" + exp + "]" )
                    }
                    return function( rec, i ) {
                        var val;
                        ctx.$ = getFeatureById( i );
                        try {
                            val = func.call( ctx.$, rec, ctx )
                        } catch ( e ) {
                            stop( e.name, "in expression [" + exp + "]:", e.message )
                        }
                        return val
                    }
                };
                MapShaper.getExpressionContext = function( lyr, mixins ) {
                    var env = MapShaper.getBaseContext();
                    if ( lyr.data ) {
                        lyr.data.getFields().forEach( function( f ) {
                            env[ f ] = null
                        } )
                    }
                    if ( mixins ) {
                        utils.extend( env, mixins )
                    }
                    return env
                };
                MapShaper.getBaseContext = function() {
                    var obj = {};
                    ( function() {
                        for ( var key in this ) {
                            obj[ key ] = null
                        }
                    } )();
                    obj.console = console;
                    return obj
                };

                function dissolvePointLayerGeometry( lyr, getGroupId, opts ) {
                    var useSph = !opts.planar && MapShaper.probablyDecimalDegreeBounds( MapShaper.getLayerBounds( lyr ) );
                    var getWeight = opts.weight ? MapShaper.compileValueExpression( opts.weight, lyr ) : null;
                    var groups = [];
                    if ( MapShaper.countMultiPartFeatures( lyr.shapes ) !== 0 ) {
                        stop( "[dissolve] Dissolving multi-part points is not supported" )
                    }
                    lyr.shapes.forEach( function( shp, i ) {
                        var groupId = getGroupId( i );
                        var weight = getWeight ? getWeight( i ) : 1;
                        var p = shp && shp[ 0 ];
                        var tmp;
                        if ( !p ) return;
                        if ( useSph ) {
                            tmp = [];
                            lngLatToXYZ( p[ 0 ], p[ 1 ], tmp );
                            p = tmp
                        }
                        groups[ groupId ] = reducePointCentroid( groups[ groupId ], p, weight )
                    } );
                    return groups.map( function( memo ) {
                        var p1, p2;
                        if ( !memo ) return null;
                        if ( useSph ) {
                            p1 = memo.centroid;
                            p2 = [];
                            xyzToLngLat( p1[ 0 ], p1[ 1 ], p1[ 2 ], p2 )
                        } else {
                            p2 = memo.centroid
                        }
                        return memo ? [ p2 ] : null
                    } )
                }

                function reducePointCentroid( memo, p, weight ) {
                    var x = p[ 0 ],
                        y = p[ 1 ],
                        sum, k;
                    if ( x == x && y == y && weight > 0 ) {
                        if ( !memo ) {
                            memo = {
                                sum: weight,
                                centroid: p.concat()
                            }
                        } else {
                            sum = memo.sum + weight;
                            k = memo.sum / sum;
                            memo.centroid[ 0 ] = k * memo.centroid[ 0 ] + weight * x / sum;
                            memo.centroid[ 1 ] = k * memo.centroid[ 1 ] + weight * y / sum;
                            if ( p.length == 3 ) {
                                memo.centroid[ 2 ] = k * memo.centroid[ 2 ] + weight * p[ 2 ] / sum
                            }
                            memo.sum = sum
                        }
                    }
                    return memo
                }

                function dissolvePolygonGeometry( shapes, getGroupId ) {
                    var segments = dissolveFirstPass( shapes, getGroupId );
                    return dissolveSecondPass( segments, shapes, getGroupId )
                }

                function dissolveFirstPass( shapes, getGroupId ) {
                    var groups = [],
                        largeGroups = [],
                        segments = [],
                        ids = shapes.map( function( shp, i ) {
                            return getGroupId( i )
                        } );
                    MapShaper.traversePaths( shapes, procArc );
                    largeGroups.forEach( splitGroup );
                    return segments;

                    function procArc( obj ) {
                        var arcId = obj.arcId,
                            idx = arcId < 0 ? ~arcId : arcId,
                            segId = segments.length,
                            group = groups[ idx ];
                        if ( !group ) {
                            group = [];
                            groups[ idx ] = group
                        }
                        group.push( segId );
                        obj.group = group;
                        segments.push( obj );
                        if ( group.length == 3 ) {
                            largeGroups.push( group )
                        }
                    }

                    function findMatchingPair( group, cb ) {
                        var arc1, arc2;
                        for ( var i = 0; i < group.length - 1; i++ ) {
                            arc1 = segments[ group[ i ] ];
                            for ( var j = i + 1; j < group.length; j++ ) {
                                arc2 = segments[ group[ j ] ];
                                if ( cb( arc1, arc2 ) ) {
                                    return [ arc1.segId, arc2.segId ]
                                }
                            }
                        }
                        return null
                    }

                    function checkFwExtension( arc1, arc2 ) {
                        return getNextSegment( arc1, segments, shapes ).arcId === ~getNextSegment( arc2, segments, shapes ).arcId
                    }

                    function checkBwExtension( arc1, arc2 ) {
                        return getPrevSegment( arc1, segments, shapes ).arcId === ~getPrevSegment( arc2, segments, shapes ).arcId
                    }

                    function checkDoubleExtension( arc1, arc2 ) {
                        return checkPairwiseMatch( arc1, arc2 ) && checkFwExtension( arc1, arc2 ) && checkBwExtension( arc1, arc2 )
                    }

                    function checkSingleExtension( arc1, arc2 ) {
                        return checkPairwiseMatch( arc1, arc2 ) && ( checkFwExtension( arc1, arc2 ) || checkBwExtension( arc1, arc2 ) )
                    }

                    function checkPairwiseMatch( arc1, arc2 ) {
                        return arc1.arcId === ~arc2.arcId && ids[ arc1.shapeId ] === ids[ arc2.shapeId ]
                    }

                    function updateGroupIds( ids ) {
                        ids.forEach( function( id ) {
                            segments[ id ].group = ids
                        } )
                    }

                    function splitGroup( group ) {
                        var group2 = findMatchingPair( group, checkDoubleExtension ) || findMatchingPair( group, checkSingleExtension ) || findMatchingPair( group, checkPairwiseMatch );
                        if ( group2 ) {
                            group = group.filter( function( i ) {
                                return !utils.contains( group2, i )
                            } );
                            updateGroupIds( group );
                            updateGroupIds( group2 );
                            if ( group.length > 2 ) splitGroup( group )
                        }
                    }
                }

                function dissolveSecondPass( segments, shapes, getGroupId ) {
                    var dissolveShapes = [];
                    segments.forEach( procSegment );
                    return dissolveShapes;

                    function procSegment( obj ) {
                        if ( obj.used ) return;
                        var match = findDissolveArc( obj );
                        if ( !match ) buildRing( obj )
                    }

                    function addRing( arcs, i ) {
                        if ( i in dissolveShapes === false ) {
                            dissolveShapes[ i ] = []
                        }
                        dissolveShapes[ i ].push( arcs )
                    }

                    function buildRing( firstArc ) {
                        var newArcs = [ firstArc.arcId ],
                            nextArc = getNextArc( firstArc );
                        firstArc.used = true;
                        while ( nextArc && nextArc != firstArc ) {
                            newArcs.push( nextArc.arcId );
                            nextArc.used = true;
                            nextArc = getNextArc( nextArc );
                            if ( nextArc && nextArc != firstArc && nextArc.used ) error( "buildRing() topology error" )
                        }
                        if ( !nextArc ) error( "buildRing() traversal error" );
                        firstArc.used = true;
                        addRing( newArcs, getGroupId( firstArc.shapeId ) )
                    }

                    function getNextArc( obj, depth ) {
                        var next = getNextSegment( obj, segments, shapes ),
                            match;
                        depth = depth || 0;
                        if ( next != obj ) {
                            match = findDissolveArc( next );
                            if ( match ) {
                                if ( depth > 100 ) {
                                    error( "[dissolve] deep recursion -- unhandled topology problem" )
                                }
                                if ( shapes[ match.shapeId ][ match.partId ].length == 1 ) {
                                    next = getNextArc( next, depth + 1 )
                                } else {
                                    next = getNextArc( match, depth + 1 )
                                }
                            }
                        }
                        return next
                    }

                    function findDissolveArc( obj ) {
                        var dissolveId = getGroupId( obj.shapeId ),
                            match, matchId;
                        matchId = utils.find( obj.group, function( i ) {
                            var a = obj,
                                b = segments[ i ];
                            if ( a == b || b.used || getGroupId( b.shapeId ) !== dissolveId || a.arcId != ~b.arcId ) return false;
                            return true
                        } );
                        match = matchId === null ? null : segments[ matchId ];
                        return match
                    }
                }

                function getNextSegment( seg, segments, shapes ) {
                    return getSegmentByOffs( seg, segments, shapes, 1 )
                }

                function getPrevSegment( seg, segments, shapes ) {
                    return getSegmentByOffs( seg, segments, shapes, -1 )
                }

                function getSegmentByOffs( seg, segments, shapes, offs ) {
                    var arcs = shapes[ seg.shapeId ][ seg.partId ],
                        partLen = arcs.length,
                        nextOffs = ( seg.i + offs ) % partLen,
                        nextSeg;
                    if ( nextOffs < 0 ) nextOffs += partLen;
                    nextSeg = segments[ seg.segId - seg.i + nextOffs ];
                    if ( !nextSeg || nextSeg.shapeId != seg.shapeId ) error( "index error" );
                    return nextSeg
                }
                api.dissolve = function( lyr, arcs, o ) {
                    var opts = o || {},
                        getGroupId = MapShaper.getCategoryClassifier( opts.field, lyr.data ),
                        dissolveShapes = null,
                        dissolveData = null,
                        lyr2;
                    if ( lyr.geometry_type == "polygon" ) {
                        dissolveShapes = dissolvePolygonGeometry( lyr.shapes, getGroupId )
                    } else if ( lyr.geometry_type == "point" ) {
                        dissolveShapes = dissolvePointLayerGeometry( lyr, getGroupId, opts )
                    } else if ( lyr.geometry_type ) {
                        stop( "[dissolve] Only point and polygon geometries can be dissolved" )
                    }
                    if ( lyr.data ) {
                        dissolveData = MapShaper.aggregateDataRecords( lyr.data.getRecords(), getGroupId, opts );
                        for ( var i = 0, n = dissolveData.length; i < n; i++ ) {
                            if ( dissolveShapes && !dissolveShapes[ i ] ) {
                                dissolveShapes[ i ] = null
                            }
                        }
                    }
                    lyr2 = {
                        name: opts.no_replace ? null : lyr.name,
                        shapes: dissolveShapes,
                        data: dissolveData ? new DataTable( dissolveData ) : null,
                        geometry_type: lyr.geometry_type
                    };
                    if ( !opts.silent ) {
                        MapShaper.printDissolveMessage( lyr, lyr2 )
                    }
                    return lyr2
                };
                MapShaper.printDissolveMessage = function( pre, post, cmd ) {
                    var n1 = MapShaper.getFeatureCount( pre ),
                        n2 = MapShaper.getFeatureCount( post ),
                        msg = utils.format( "[%s] Dissolved %,d feature%s into %,d feature%s", cmd || "dissolve", n1, utils.pluralSuffix( n1 ), n2, utils.pluralSuffix( n2 ) );
                    message( msg )
                };
                api.dissolve2 = function( src, dataset, opts ) {
                    var multiple = Array.isArray( src );
                    var nodes = MapShaper.addIntersectionCuts( dataset, opts );
                    var layers = multiple ? src : [ src ];
                    var layers2 = layers.map( function( lyr ) {
                        MapShaper.requirePolygonLayer( lyr, "[dissolve2] Expected a polygon type layer" );
                        return MapShaper.dissolvePolygonLayer( lyr, nodes, opts )
                    } );
                    return multiple ? layers2 : layers2[ 0 ]
                };
                MapShaper.dissolvePolygonLayer = function( lyr, nodes, opts ) {
                    opts = opts || {};
                    var getGroupId = MapShaper.getCategoryClassifier( opts.field, lyr.data );
                    var groups = lyr.shapes.reduce( function( groups, shape, i ) {
                        var i2 = getGroupId( i );
                        if ( i2 in groups === false ) {
                            groups[ i2 ] = []
                        }
                        MapShaper.extendShape( groups[ i2 ], shape );
                        return groups
                    }, [] );
                    var dissolve = MapShaper.getPolygonDissolver( nodes );
                    var lyr2, data2;
                    if ( lyr.data ) {
                        data2 = new DataTable( MapShaper.aggregateDataRecords( lyr.data.getRecords(), getGroupId, opts ) )
                    }
                    lyr2 = {
                        name: opts.no_replace ? null : lyr.name,
                        data: data2,
                        shapes: groups.map( dissolve ),
                        geometry_type: lyr.geometry_type
                    };
                    MapShaper.printDissolveMessage( lyr, lyr2, "dissolve2" );
                    return lyr2
                };
                MapShaper.concatShapes = function( shapes ) {
                    return shapes.reduce( function( memo, shape ) {
                        MapShaper.extendShape( memo, shape );
                        return memo
                    }, [] )
                };
                MapShaper.extendShape = function( dest, src ) {
                    if ( src ) {
                        for ( var i = 0, n = src.length; i < n; i++ ) {
                            dest.push( src[ i ] )
                        }
                    }
                };
                MapShaper.getPolygonDissolver = function( nodes, spherical ) {
                    spherical = spherical && !nodes.arcs.isPlanar();
                    var flags = new Uint8Array( nodes.arcs.size() );
                    var divide = MapShaper.getHoleDivider( nodes, spherical );
                    var flatten = MapShaper.getRingIntersector( nodes, "flatten", flags, spherical );
                    var dissolve = MapShaper.getRingIntersector( nodes, "dissolve", flags, spherical );
                    return function( shp ) {
                        if ( !shp ) return null;
                        var cw = [],
                            ccw = [];
                        divide( shp, cw, ccw );
                        cw = flatten( cw );
                        ccw.forEach( MapShaper.reversePath );
                        ccw = flatten( ccw );
                        ccw.forEach( MapShaper.reversePath );
                        var shp2 = MapShaper.appendHolestoRings( cw, ccw );
                        var dissolved = dissolve( shp2 );
                        return dissolved.length > 0 ? dissolved : null
                    }
                };
                MapShaper.appendHolestoRings = function( cw, ccw ) {
                    for ( var i = 0, n = ccw.length; i < n; i++ ) {
                        cw.push( ccw[ i ] )
                    }
                    return cw
                };
                api.cleanLayers = function( layers, dataset, opts ) {
                    var nodes = MapShaper.addIntersectionCuts( dataset );
                    var flatten = MapShaper.getPolygonFlattener( nodes );
                    layers.forEach( function( lyr ) {
                        MapShaper.requirePolygonLayer( lyr, "[clean] Expected a polygon type layer" );
                        lyr.shapes = lyr.shapes.map( flatten )
                    } )
                };
                MapShaper.getPolygonFlattener = function( nodes ) {
                    var flags = new Uint8Array( nodes.arcs.size() );
                    var divide = MapShaper.getHoleDivider( nodes );
                    var flatten = MapShaper.getRingIntersector( nodes, "flatten", flags );
                    return function( shp ) {
                        if ( !shp ) return null;
                        var cw = [],
                            ccw = [];
                        divide( shp, cw, ccw );
                        cw = flatten( cw );
                        ccw.forEach( MapShaper.reversePath );
                        ccw = flatten( ccw );
                        ccw.forEach( MapShaper.reversePath );
                        var shp2 = MapShaper.appendHolestoRings( cw, ccw );
                        return shp2 && shp2.length > 0 ? shp2 : null
                    }
                };
                MapShaper.clipPolygons = function( targetShapes, clipShapes, nodes, type ) {
                    var arcs = nodes.arcs;
                    var clipFlags = new Uint8Array( arcs.size() );
                    var routeFlags = new Uint8Array( arcs.size() );
                    var clipArcTouches = 0;
                    var clipArcUses = 0;
                    var usedClipArcs = [];
                    var dividePath = MapShaper.getPathFinder( nodes, useRoute, routeIsActive );
                    var dissolvePolygon = MapShaper.getPolygonDissolver( nodes );
                    targetShapes = targetShapes.map( dissolvePolygon );
                    clipShapes = [ dissolvePolygon( MapShaper.concatShapes( clipShapes ) ) ];
                    MapShaper.openArcRoutes( clipShapes, arcs, clipFlags, type == "clip", type == "erase", !!"dissolve", 17 );
                    var index = new PathIndex( clipShapes, arcs );
                    var clippedShapes = targetShapes.map( function( shape, i ) {
                        if ( shape ) {
                            return clipPolygon( shape, type, index )
                        }
                        return null
                    } );
                    var undividedClipShapes = findUndividedClipShapes( clipShapes );
                    MapShaper.closeArcRoutes( clipShapes, arcs, routeFlags, true, true );
                    index = new PathIndex( undividedClipShapes, arcs );
                    targetShapes.forEach( function( shape, shapeId ) {
                        var paths = shape ? findInteriorPaths( shape, type, index ) : null;
                        if ( paths ) {
                            clippedShapes[ shapeId ] = ( clippedShapes[ shapeId ] || [] ).concat( paths )
                        }
                    } );
                    return clippedShapes;

                    function clipPolygon( shape, type, index ) {
                        var dividedShape = [],
                            clipping = type == "clip",
                            erasing = type == "erase";
                        MapShaper.openArcRoutes( shape, arcs, routeFlags, true, false, false );
                        MapShaper.forEachPath( shape, function( ids ) {
                            var path;
                            for ( var i = 0, n = ids.length; i < n; i++ ) {
                                clipArcTouches = 0;
                                clipArcUses = 0;
                                path = dividePath( ids[ i ] );
                                if ( path ) {
                                    if ( clipArcTouches === 0 || clipArcUses === 0 ) {
                                        var contained = index.pathIsEnclosed( path );
                                        if ( clipping && contained || erasing && !contained ) {
                                            dividedShape.push( path )
                                        }
                                    } else {
                                        dividedShape.push( path )
                                    }
                                }
                            }
                        } );
                        MapShaper.closeArcRoutes( shape, arcs, routeFlags, true, true, true );
                        if ( usedClipArcs.length > 0 ) {
                            MapShaper.closeArcRoutes( usedClipArcs, arcs, routeFlags, true, true, true );
                            usedClipArcs = []
                        }
                        return dividedShape.length === 0 ? null : dividedShape
                    }

                    function routeIsActive( id ) {
                        var fw = id >= 0,
                            abs = fw ? id : ~id,
                            visibleBit = fw ? 1 : 16,
                            targetBits = routeFlags[ abs ],
                            clipBits = clipFlags[ abs ];
                        if ( clipBits > 0 ) clipArcTouches++;
                        return ( targetBits & visibleBit ) > 0 || ( clipBits & visibleBit ) > 0
                    }

                    function useRoute( id ) {
                        var fw = id >= 0,
                            abs = fw ? id : ~id,
                            targetBits = routeFlags[ abs ],
                            clipBits = clipFlags[ abs ],
                            targetRoute, clipRoute;
                        if ( fw ) {
                            targetRoute = targetBits;
                            clipRoute = clipBits
                        } else {
                            targetRoute = targetBits >> 4;
                            clipRoute = clipBits >> 4
                        }
                        targetRoute &= 3;
                        clipRoute &= 3;
                        var usable = false;
                        if ( targetRoute == 3 ) {
                            if ( clipRoute == 1 ) {} else if ( clipRoute == 2 && type == "erase" ) {} else {
                                usable = true
                            }
                        } else if ( targetRoute === 0 && clipRoute == 3 ) {
                            usedClipArcs.push( id );
                            usable = true
                        }
                        if ( usable ) {
                            if ( clipRoute == 3 ) {
                                clipArcUses++
                            }
                            if ( fw ) {
                                targetBits = MapShaper.setBits( targetBits, 1, 3 )
                            } else {
                                targetBits = MapShaper.setBits( targetBits, 16, 48 )
                            }
                        }
                        targetBits |= fw ? 4 : 64;
                        routeFlags[ abs ] = targetBits;
                        return usable
                    }

                    function findUndividedClipShapes( clipShapes ) {
                        return clipShapes.map( function( shape ) {
                            var usableParts = [];
                            MapShaper.forEachPath( shape, function( ids ) {
                                var pathIsClean = true,
                                    pathIsVisible = false;
                                for ( var i = 0; i < ids.length; i++ ) {
                                    if ( !arcIsUnused( ids[ i ], routeFlags ) ) {
                                        pathIsClean = false;
                                        break
                                    }
                                    if ( !pathIsVisible && arcIsVisible( ids[ i ], clipFlags ) ) {
                                        pathIsVisible = true
                                    }
                                }
                                if ( pathIsClean && pathIsVisible ) usableParts.push( ids )
                            } );
                            return usableParts.length > 0 ? usableParts : null
                        } )
                    }

                    function arcIsUnused( id, flags ) {
                        var abs = absArcId( id ),
                            flag = flags[ abs ];
                        return ( flag & 68 ) === 0
                    }

                    function arcIsVisible( id, flags ) {
                        var flag = flags[ absArcId( id ) ];
                        return ( flag & 17 ) > 0
                    }

                    function findInteriorPaths( shape, type, index ) {
                        var enclosedPaths = index.findPathsInsideShape( shape ),
                            dissolvedPaths = [];
                        if ( !enclosedPaths ) return null;
                        if ( type == "erase" ) enclosedPaths.forEach( MapShaper.reversePath );
                        if ( enclosedPaths.length <= 1 ) {
                            dissolvedPaths = enclosedPaths
                        } else {
                            MapShaper.openArcRoutes( enclosedPaths, arcs, routeFlags, true, false, true );
                            enclosedPaths.forEach( function( ids ) {
                                var path;
                                for ( var j = 0; j < ids.length; j++ ) {
                                    path = dividePath( ids[ j ] );
                                    if ( path ) {
                                        dissolvedPaths.push( path )
                                    }
                                }
                            } )
                        }
                        return dissolvedPaths.length > 0 ? dissolvedPaths : null
                    }
                };
                MapShaper.clipPolylines = function( targetShapes, clipShapes, nodes, type ) {
                    var index = new PathIndex( clipShapes, nodes.arcs );
                    return targetShapes.map( function( shp ) {
                        return clipPolyline( shp )
                    } );

                    function clipPolyline( shp ) {
                        var clipped = shp.reduce( clipPath, [] );
                        return clipped.length > 0 ? clipped : null
                    }

                    function clipPath( memo, path ) {
                        var clippedPath = null,
                            arcId, enclosed;
                        for ( var i = 0; i < path.length; i++ ) {
                            arcId = path[ i ];
                            enclosed = index.arcIsEnclosed( arcId );
                            if ( enclosed && type == "clip" || !enclosed && type == "erase" ) {
                                if ( !clippedPath ) {
                                    memo.push( clippedPath = [] )
                                }
                                clippedPath.push( arcId )
                            } else {
                                clippedPath = null
                            }
                        }
                        return memo
                    }
                };
                MapShaper.clipPoints = function( points, clipShapes, arcs, type ) {
                    var index = new PathIndex( clipShapes, arcs );
                    var points2 = points.reduce( function( memo, feat ) {
                        var n = feat ? feat.length : 0,
                            feat2 = [],
                            enclosed;
                        for ( var i = 0; i < n; i++ ) {
                            enclosed = index.findEnclosingShape( feat[ i ] ) > -1;
                            if ( type == "clip" && enclosed || type == "erase" && !enclosed ) {
                                feat2.push( feat[ i ].concat() )
                            }
                        }
                        memo.push( feat2.length > 0 ? feat2 : null );
                        return memo
                    }, [] );
                    return points2
                };
                MapShaper.getPathEndpointTest = function( layers, arcs ) {
                    var index = new Uint8Array( arcs.size() );
                    layers.forEach( function( lyr ) {
                        if ( MapShaper.layerHasPaths( lyr ) ) {
                            lyr.shapes.forEach( addShape )
                        }
                    } );

                    function addShape( shape ) {
                        MapShaper.forEachPath( shape, addPath )
                    }

                    function addPath( path ) {
                        addEndpoint( ~path[ 0 ] );
                        addEndpoint( path[ path.length - 1 ] )
                    }

                    function addEndpoint( arcId ) {
                        var absId = absArcId( arcId );
                        var fwd = absId == arcId;
                        index[ absId ] |= fwd ? 1 : 2
                    }
                    return function( arcId ) {
                        var absId = absArcId( arcId );
                        var fwd = absId == arcId;
                        var code = index[ absId ];
                        return fwd ? ( code & 1 ) == 1 : ( code & 2 ) == 2
                    }
                };
                MapShaper.dissolveArcs = function( dataset ) {
                    var arcs = dataset.arcs,
                        layers = dataset.layers.filter( MapShaper.layerHasPaths );
                    if ( !arcs || !layers.length ) {
                        dataset.arcs = null;
                        return
                    }
                    var arcsCanDissolve = MapShaper.getArcDissolveTest( layers, arcs ),
                        newArcs = [],
                        totalPoints = 0,
                        arcIndex = new Int32Array( arcs.size() ),
                        arcStatus = new Uint8Array( arcs.size() );
                    layers.forEach( function( lyr ) {
                        lyr.shapes = lyr.shapes.map( function( shape ) {
                            return MapShaper.editPaths( shape && shape.concat(), translatePath )
                        } )
                    } );
                    dataset.arcs = MapShaper.dissolveArcCollection( arcs, newArcs, totalPoints );

                    function translatePath( path ) {
                        var pointCount = 0;
                        var newPath = [];
                        var newArc, arcId, absId, arcLen, fw, newArcId;
                        for ( var i = 0, n = path.length; i < n; i++ ) {
                            arcId = path[ i ];
                            absId = absArcId( arcId );
                            fw = arcId === absId;
                            if ( arcs.arcIsDegenerate( arcId ) ) {} else if ( arcStatus[ absId ] !== 0 ) {
                                newArc = null
                            } else {
                                arcLen = arcs.getArcLength( arcId );
                                if ( newArc && arcsCanDissolve( path[ i - 1 ], arcId ) ) {
                                    if ( arcLen > 0 ) {
                                        arcLen--
                                    }
                                    newArc.push( arcId );
                                    arcStatus[ absId ] = 1
                                } else {
                                    newArc = [ arcId ];
                                    arcIndex[ absId ] = newArcs.length;
                                    newArcs.push( newArc );
                                    arcStatus[ absId ] = fw ? 2 : 3
                                }
                                pointCount += arcLen
                            }
                            if ( arcStatus[ absId ] > 1 ) {
                                newArcId = arcIndex[ absId ];
                                if ( fw && arcStatus[ absId ] == 3 || !fw && arcStatus[ absId ] == 2 ) {
                                    newArcId = ~newArcId
                                }
                                newPath.push( newArcId )
                            }
                        }
                        totalPoints += pointCount;
                        return newPath
                    }
                };
                MapShaper.dissolveArcCollection = function( arcs, newArcs, newLen ) {
                    var nn2 = new Uint32Array( newArcs.length ),
                        xx2 = new Float64Array( newLen ),
                        yy2 = new Float64Array( newLen ),
                        src = arcs.getVertexData(),
                        zz2 = src.zz ? new Float64Array( newLen ) : null,
                        interval = arcs.getRetainedInterval(),
                        offs = 0;
                    newArcs.forEach( function( newArc, newId ) {
                        newArc.forEach( function( oldId, i ) {
                            extendDissolvedArc( oldId, newId )
                        } )
                    } );
                    return new ArcCollection( nn2, xx2, yy2 ).setThresholds( zz2 ).setRetainedInterval( interval );

                    function extendDissolvedArc( oldId, newId ) {
                        var absId = absArcId( oldId ),
                            rev = oldId < 0,
                            n = src.nn[ absId ],
                            i = src.ii[ absId ],
                            n2 = nn2[ newId ];
                        if ( n > 0 ) {
                            if ( n2 > 0 ) {
                                n--;
                                if ( !rev ) i++
                            }
                            utils.copyElements( src.xx, i, xx2, offs, n, rev );
                            utils.copyElements( src.yy, i, yy2, offs, n, rev );
                            if ( zz2 ) utils.copyElements( src.zz, i, zz2, offs, n, rev );
                            nn2[ newId ] += n;
                            offs += n
                        }
                    }
                };
                MapShaper.getArcDissolveTest = function( layers, arcs ) {
                    var nodes = MapShaper.getFilteredNodeCollection( layers, arcs ),
                        lineLayers = layers.filter( function( lyr ) {
                            return lyr.geometry_type == "polyline"
                        } ),
                        testLineEndpoint = MapShaper.getPathEndpointTest( lineLayers, arcs ),
                        linkCount, lastId;
                    return function( id1, id2 ) {
                        if ( id1 == id2 || id1 == ~id2 ) {
                            verbose( "Unexpected arc sequence:", id1, id2 );
                            return false
                        }
                        linkCount = 0;
                        nodes.forEachConnectedArc( id1, countLink );
                        return linkCount == 1 && lastId == ~id2 && !testLineEndpoint( id1 ) && !testLineEndpoint( ~id2 )
                    };

                    function countLink( arcId, i ) {
                        linkCount++;
                        lastId = arcId
                    }
                };
                MapShaper.getFilteredNodeCollection = function( layers, arcs ) {
                    var counts = MapShaper.countArcReferences( layers, arcs ),
                        test = function( arcId ) {
                            return counts[ absArcId( arcId ) ] > 0
                        };
                    return new NodeCollection( arcs, test )
                };
                MapShaper.countArcReferences = function( layers, arcs ) {
                    var counts = new Uint32Array( arcs.size() );
                    layers.forEach( function( lyr ) {
                        MapShaper.countArcsInShapes( lyr.shapes, counts )
                    } );
                    return counts
                };
                api.filterFeatures = function( lyr, arcs, opts ) {
                    var records = lyr.data ? lyr.data.getRecords() : null,
                        shapes = lyr.shapes || null,
                        n = MapShaper.getFeatureCount( lyr ),
                        filteredShapes = shapes ? [] : null,
                        filteredRecords = records ? [] : null,
                        filteredLyr = MapShaper.getOutputLayer( lyr, opts ),
                        filter;
                    if ( opts.expression ) {
                        filter = MapShaper.compileValueExpression( opts.expression, lyr, arcs )
                    }
                    if ( opts.remove_empty ) {
                        filter = MapShaper.combineFilters( filter, MapShaper.getNullGeometryFilter( lyr, arcs ) )
                    }
                    if ( !filter ) {
                        stop( "[filter] Missing a filter expression" )
                    }
                    utils.repeat( n, function( shapeId ) {
                        var result = filter( shapeId );
                        if ( result === true ) {
                            if ( shapes ) filteredShapes.push( shapes[ shapeId ] || null );
                            if ( records ) filteredRecords.push( records[ shapeId ] || null )
                        } else if ( result !== false ) {
                            stop( "[filter] Expression must return true or false" )
                        }
                    } );
                    filteredLyr.shapes = filteredShapes;
                    filteredLyr.data = filteredRecords ? new DataTable( filteredRecords ) : null;
                    if ( opts.no_replace ) {
                        filteredLyr = MapShaper.copyLayer( filteredLyr )
                    }
                    if ( opts.verbose !== false ) {
                        message( utils.format( "[filter] Retained %,d of %,d features", MapShaper.getFeatureCount( filteredLyr ), n ) )
                    }
                    return filteredLyr
                };
                MapShaper.getNullGeometryFilter = function( lyr, arcs ) {
                    var shapes = lyr.shapes;
                    if ( lyr.geometry_type == "polygon" ) {
                        return MapShaper.getEmptyPolygonFilter( shapes, arcs )
                    }
                    return function( i ) {
                        return !!shapes[ i ]
                    }
                };
                MapShaper.getEmptyPolygonFilter = function( shapes, arcs ) {
                    return function( i ) {
                        var shp = shapes[ i ];
                        return !!shp && geom.getPlanarShapeArea( shapes[ i ], arcs ) > 0
                    }
                };
                MapShaper.combineFilters = function( a, b ) {
                    return a && b && function( id ) {
                        return a( id ) && b( id )
                    } || a || b
                };
                api.filterIslands = function( lyr, arcs, opts ) {
                    var removed = 0;
                    if ( lyr.geometry_type != "polygon" ) {
                        return
                    }
                    if ( opts.min_area || opts.min_vertices ) {
                        if ( opts.min_area ) {
                            removed += MapShaper.filterIslands( lyr, arcs, MapShaper.getMinAreaTest( opts.min_area, arcs ) )
                        }
                        if ( opts.min_vertices ) {
                            removed += MapShaper.filterIslands( lyr, arcs, MapShaper.getVertexCountTest( opts.min_vertices, arcs ) )
                        }
                        if ( opts.remove_empty ) {
                            api.filterFeatures( lyr, arcs, {
                                remove_empty: true,
                                verbose: false
                            } )
                        }
                        message( utils.format( "[filter-islands] Removed %'d island%s", removed, utils.pluralSuffix( removed ) ) )
                    } else {
                        message( "[filter-islands] Missing a criterion for filtering islands; use min-area or min-vertices" )
                    }
                };
                MapShaper.getVertexCountTest = function( minVertices, arcs ) {
                    return function( path ) {
                        return geom.countVerticesInPath( path, arcs ) <= minVertices
                    }
                };
                MapShaper.getMinAreaTest = function( minArea, arcs ) {
                    var pathArea = arcs.isPlanar() ? geom.getPlanarPathArea : geom.getSphericalPathArea;
                    return function( path ) {
                        var area = pathArea( path, arcs );
                        return Math.abs( area ) < minArea
                    }
                };
                MapShaper.filterIslands = function( lyr, arcs, ringTest ) {
                    var removed = 0;
                    var counts = new Uint8Array( arcs.size() );
                    MapShaper.countArcsInShapes( lyr.shapes, counts );
                    var pathFilter = function( path, i, paths ) {
                        if ( path.length == 1 ) {
                            if ( counts[ absArcId( path[ 0 ] ) ] === 1 ) {
                                if ( !ringTest || ringTest( path ) ) {
                                    if ( !MapShaper.ringHasHoles( path, paths, arcs ) ) {
                                        removed++;
                                        return null
                                    }
                                }
                            }
                        }
                    };
                    MapShaper.editShapes( lyr.shapes, pathFilter );
                    return removed
                };
                MapShaper.ringIntersectsBBox = function( ring, bbox, arcs ) {
                    for ( var i = 0, n = ring.length; i < n; i++ ) {
                        if ( arcs.arcIntersectsBBox( absArcId( ring[ i ] ), bbox ) ) {
                            return true
                        }
                    }
                    return false
                };
                MapShaper.ringHasHoles = function( ring, rings, arcs ) {
                    var bbox = arcs.getSimpleShapeBounds2( ring );
                    var sibling, p;
                    for ( var i = 0, n = rings.length; i < n; i++ ) {
                        sibling = rings[ i ];
                        if ( sibling && sibling != ring && MapShaper.ringIntersectsBBox( sibling, bbox, arcs ) ) {
                            p = arcs.getVertex( sibling[ 0 ], 0 );
                            if ( geom.testPointInRing( p.x, p.y, ring, arcs ) ) {
                                return true
                            }
                        }
                    }
                    return false
                };
                api.filterSlivers = function( lyr, arcs, opts ) {
                    if ( lyr.geometry_type != "polygon" ) {
                        return 0
                    }
                    return MapShaper.filterSlivers( lyr, arcs, opts )
                };
                MapShaper.filterSlivers = function( lyr, arcs, opts ) {
                    var ringTest = opts && opts.min_area ? MapShaper.getMinAreaTest( opts.min_area, arcs ) : MapShaper.getSliverTest( arcs );
                    var removed = 0;
                    var pathFilter = function( path, i, paths ) {
                        if ( ringTest( path ) ) {
                            removed++;
                            return null
                        }
                    };
                    MapShaper.editShapes( lyr.shapes, pathFilter );
                    message( utils.format( "[filter-slivers] Removed %'d sliver%s", removed, utils.pluralSuffix( removed ) ) );
                    return removed
                };
                MapShaper.filterClipSlivers = function( lyr, clipLyr, arcs ) {
                    var flags = new Uint8Array( arcs.size() );
                    var ringTest = MapShaper.getSliverTest( arcs );
                    var removed = 0;
                    var pathFilter = function( path ) {
                        var prevArcs = 0,
                            newArcs = 0;
                        for ( var i = 0, n = path && path.length || 0; i < n; i++ ) {
                            if ( flags[ absArcId( path[ i ] ) ] > 0 ) {
                                newArcs++
                            } else {
                                prevArcs++
                            }
                        }
                        if ( newArcs > 0 && prevArcs > 0 && ringTest( path ) ) {
                            removed++;
                            return null
                        }
                    };
                    MapShaper.countArcsInShapes( clipLyr.shapes, flags );
                    MapShaper.editShapes( lyr.shapes, pathFilter );
                    return removed
                };
                MapShaper.getSliverTest = function( arcs ) {
                    var maxSliverArea = MapShaper.calcMaxSliverArea( arcs );
                    return function( path ) {
                        return Math.abs( geom.getPlanarPathArea( path, arcs ) ) <= maxSliverArea
                    }
                };
                MapShaper.calcMaxSliverArea = function( arcs ) {
                    var k = 2,
                        dxMax = arcs.getBounds().width() / k,
                        dyMax = arcs.getBounds().height() / k,
                        count = 0,
                        mean = 0;
                    arcs.forEachSegment( function( i, j, xx, yy ) {
                        var dx = Math.abs( xx[ i ] - xx[ j ] ),
                            dy = Math.abs( yy[ i ] - yy[ j ] );
                        if ( dx < dxMax && dy < dyMax ) {
                            mean += ( Math.sqrt( dx * dx + dy * dy ) - mean ) / ++count
                        }
                    } );
                    return mean * mean
                };
                api.splitLayer = function( src, splitField, opts ) {
                    var lyr0 = opts && opts.no_replace ? MapShaper.copyLayer( src ) : src,
                        properties = lyr0.data ? lyr0.data.getRecords() : null,
                        shapes = lyr0.shapes,
                        index = {},
                        splitLayers = [],
                        prefix;
                    if ( splitField && ( !properties || !lyr0.data.fieldExists( splitField ) ) ) {
                        stop( "[split] Missing attribute field:", splitField )
                    }
                    prefix = lyr0.name || ( splitField ? "" : "split" );
                    utils.repeat( MapShaper.getFeatureCount( lyr0 ), function( i ) {
                        var key = MapShaper.getSplitKey( i, splitField, properties ),
                            lyr;
                        if ( key in index === false ) {
                            index[ key ] = splitLayers.length;
                            lyr = utils.defaults( {
                                name: MapShaper.getSplitLayerName( prefix, key ),
                                data: properties ? new DataTable : null,
                                shapes: shapes ? [] : null
                            }, lyr0 );
                            splitLayers.push( lyr )
                        } else {
                            lyr = splitLayers[ index[ key ] ]
                        }
                        if ( shapes ) {
                            lyr.shapes.push( shapes[ i ] )
                        }
                        if ( properties ) {
                            lyr.data.getRecords().push( properties[ i ] )
                        }
                    } );
                    return splitLayers
                };
                MapShaper.getSplitKey = function( i, field, properties ) {
                    var rec = field && properties ? properties[ i ] : null;
                    return String( rec ? rec[ field ] : i + 1 )
                };
                MapShaper.getSplitLayerName = function( base, key ) {
                    return ( base ? base + "-" : "" ) + key
                };
                api.clipLayers = function( target, src, dataset, opts ) {
                    return MapShaper.clipLayers( target, src, dataset, "clip", opts )
                };
                api.eraseLayers = function( target, src, dataset, opts ) {
                    return MapShaper.clipLayers( target, src, dataset, "erase", opts )
                };
                api.clipLayer = function( targetLyr, src, dataset, opts ) {
                    return api.clipLayers( [ targetLyr ], src, dataset, opts )[ 0 ]
                };
                api.eraseLayer = function( targetLyr, src, dataset, opts ) {
                    return api.eraseLayers( [ targetLyr ], src, dataset, opts )[ 0 ]
                };
                api.sliceLayers = function( target, src, dataset, opts ) {
                    return MapShaper.clipLayers( target, src, dataset, "slice", opts )
                };
                api.sliceLayer = function( targetLyr, src, dataset, opts ) {
                    return api.sliceLayers( [ targetLyr ], src, dataset, opts )
                };
                MapShaper.clipLayers = function( targetLayers, clipSrc, dataset, type, opts ) {
                    var clipLyr, clipDataset;
                    opts = opts || {
                        no_cleanup: true
                    };
                    clipLyr = MapShaper.findClippingLayer( clipSrc, dataset );
                    if ( clipLyr ) {
                        clipDataset = dataset
                    } else {
                        if ( opts.bbox ) {
                            clipDataset = MapShaper.convertClipBounds( opts.bbox )
                        } else {
                            clipDataset = MapShaper.loadExternalClipLayer( clipSrc, opts )
                        }
                        if ( !clipDataset || clipDataset.layers.length != 1 ) {
                            stop( "[" + type + "] Missing clipping data" )
                        }
                        clipLyr = clipDataset.layers[ 0 ]
                    }
                    MapShaper.requirePolygonLayer( clipLyr, "[" + type + "] Requires a polygon clipping layer" );
                    return MapShaper.clipLayersByLayer( targetLayers, dataset, clipLyr, clipDataset, type, opts )
                };
                MapShaper.getSliceLayerName = function( clipLyr, field, i ) {
                    var id = field ? clipLyr.data.getRecords()[ 0 ][ field ] : i + 1;
                    return "slice-" + id
                };
                MapShaper.sliceLayerByLayer = function( targetLyr, clipLyr, nodes, opts ) {
                    var clipLayers = api.splitLayer( clipLyr, opts.id_field, {
                        no_replace: true
                    } );
                    return clipLayers.map( function( clipLyr, i ) {
                        var outputLyr = MapShaper.clipLayerByLayer( targetLyr, clipLyr, nodes, "clip", opts );
                        outputLyr.name = MapShaper.getSliceLayerName( clipLyr, opts.id_field, i );
                        return outputLyr
                    } )
                };
                MapShaper.clipLayerByLayer = function( targetLyr, clipLyr, nodes, type, opts ) {
                    var arcs = nodes.arcs;
                    var shapeCount = targetLyr.shapes ? targetLyr.shapes.length : 0;
                    var nullCount = 0,
                        sliverCount = 0;
                    var clippedShapes, outputLyr;
                    if ( shapeCount === 0 ) {
                        return targetLyr
                    }
                    if ( targetLyr === clipLyr ) {
                        stop( "[" + type + "] Can't clip a layer with itself" )
                    }
                    if ( targetLyr.geometry_type == "point" ) {
                        clippedShapes = MapShaper.clipPoints( targetLyr.shapes, clipLyr.shapes, arcs, type )
                    } else if ( targetLyr.geometry_type == "polygon" ) {
                        clippedShapes = MapShaper.clipPolygons( targetLyr.shapes, clipLyr.shapes, nodes, type )
                    } else if ( targetLyr.geometry_type == "polyline" ) {
                        clippedShapes = MapShaper.clipPolylines( targetLyr.shapes, clipLyr.shapes, nodes, type )
                    } else {
                        stop( "[" + type + "] Invalid target layer:", targetLyr.name )
                    }
                    outputLyr = {
                        name: targetLyr.name,
                        geometry_type: targetLyr.geometry_type,
                        shapes: clippedShapes,
                        data: targetLyr.data
                    };
                    if ( opts.remove_slivers && outputLyr.geometry_type == "polygon" ) {
                        sliverCount = MapShaper.filterClipSlivers( outputLyr, clipLyr, arcs )
                    }
                    api.filterFeatures( outputLyr, arcs, {
                        remove_empty: true,
                        verbose: false
                    } );
                    if ( outputLyr.data ) {
                        outputLyr.data = outputLyr.data.clone()
                    }
                    nullCount = shapeCount - outputLyr.shapes.length;
                    if ( nullCount && sliverCount ) {
                        message( MapShaper.getClipMessage( type, nullCount, sliverCount ) )
                    }
                    return outputLyr
                };
                MapShaper.clipLayersByLayer = function( targetLayers, targetDataset, clipLyr, clipDataset, type, opts ) {
                    var usingPathClip = utils.some( targetLayers, MapShaper.layerHasPaths );
                    var usingExternalDataset = targetDataset != clipDataset;
                    var nodes, outputLayers, mergedDataset;
                    if ( usingExternalDataset ) {
                        mergedDataset = MapShaper.mergeDatasets( [ targetDataset, clipDataset ] );
                        api.buildTopology( mergedDataset );
                        targetDataset.arcs = mergedDataset.arcs
                    } else {
                        mergedDataset = targetDataset
                    }
                    if ( usingPathClip ) {
                        nodes = MapShaper.addIntersectionCuts( mergedDataset, opts )
                    } else {
                        nodes = new NodeCollection( targetDataset.arcs )
                    }
                    outputLayers = targetLayers.reduce( function( memo, targetLyr ) {
                        if ( type == "slice" ) {
                            memo = memo.concat( MapShaper.sliceLayerByLayer( targetLyr, clipLyr, nodes, opts ) )
                        } else {
                            memo.push( MapShaper.clipLayerByLayer( targetLyr, clipLyr, nodes, type, opts ) )
                        }
                        return memo
                    }, [] );
                    if ( opts.no_replace ) {
                        targetDataset.layers = targetDataset.layers.concat( outputLayers )
                    } else {
                        MapShaper.replaceLayers( targetDataset, targetLayers, outputLayers )
                    }
                    if ( usingPathClip && !opts.no_cleanup ) {
                        MapShaper.dissolveArcs( targetDataset )
                    }
                    return outputLayers
                };
                MapShaper.getClipMessage = function( type, nullCount, sliverCount ) {
                    var nullMsg = nullCount ? utils.format( "%,d null feature%s", nullCount, utils.pluralSuffix( nullCount ) ) : "";
                    var sliverMsg = sliverCount ? utils.format( "%,d sliver%s", sliverCount, utils.pluralSuffix( sliverCount ) ) : "";
                    if ( nullMsg || sliverMsg ) {
                        return utils.format( "[%s] Removed %s%s%s", type, nullMsg, nullMsg && sliverMsg ? " and " : "", sliverMsg )
                    }
                    return ""
                };
                MapShaper.findClippingLayer = function( clipSrc, dataset ) {
                    var layers, lyr;
                    if ( utils.isObject( clipSrc ) && utils.contains( dataset.layers, clipSrc ) ) {
                        lyr = clipSrc
                    } else if ( utils.isString( clipSrc ) ) {
                        layers = MapShaper.findMatchingLayers( dataset.layers, clipSrc );
                        if ( layers.length > 1 ) {
                            stop( "[clip/erase] Received more than one source layer" )
                        } else if ( layers.length == 1 ) {
                            lyr = layers[ 0 ]
                        }
                    }
                    return lyr || null
                };
                MapShaper.loadExternalClipLayer = function( path, opts ) {
                    var dataset = api.importFile( path, utils.defaults( {
                        no_topology: true
                    }, opts ) );
                    if ( !dataset ) {
                        stop( "Unable to find file [" + path + "]" )
                    }
                    if ( dataset.layers.length != 1 ) {
                        stop( "Clip/erase only supports clipping with single-layer datasets" )
                    }
                    return dataset
                };
                MapShaper.convertClipBounds = function( bb ) {
                    var x0 = bb[ 0 ],
                        y0 = bb[ 1 ],
                        x1 = bb[ 2 ],
                        y1 = bb[ 3 ],
                        arc = [ [ x0, y0 ], [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ];
                    if ( !( y1 > y0 && x1 > x0 ) ) {
                        stop( "[clip/erase] Invalid bbox (should be [xmin, ymin, xmax, ymax]):", bb )
                    }
                    return {
                        arcs: new ArcCollection( [ arc ] ),
                        layers: [ {
                            shapes: [ [ [ 0 ] ] ],
                            geometry_type: "polygon"
                        } ]
                    }
                };
                MapShaper.getArcClassifier = function( shapes, arcs ) {
                    var n = arcs.size(),
                        a = new Int32Array( n ),
                        b = new Int32Array( n );
                    utils.initializeArray( a, -1 );
                    utils.initializeArray( b, -1 );
                    MapShaper.traversePaths( shapes, function( o ) {
                        var i = absArcId( o.arcId );
                        var shpId = o.shapeId;
                        var aval = a[ i ];
                        if ( aval == -1 ) {
                            a[ i ] = shpId
                        } else if ( shpId < aval ) {
                            b[ i ] = aval;
                            a[ i ] = shpId
                        } else {
                            b[ i ] = shpId
                        }
                    } );

                    function classify( arcId, getKey ) {
                        var i = absArcId( arcId );
                        var key = null;
                        if ( a[ i ] > -1 ) {
                            key = getKey( a[ i ], b[ i ] );
                            if ( key ) {
                                a[ i ] = -1;
                                b[ i ] = -1
                            }
                        }
                        return key
                    }
                    return function( getKey ) {
                        return function( arcId ) {
                            return classify( arcId, getKey )
                        }
                    }
                };
                MapShaper.findNeighbors = function( shapes, arcs ) {
                    var getKey = function( a, b ) {
                        return b > -1 && a > -1 ? [ a, b ] : null
                    };
                    var classify = MapShaper.getArcClassifier( shapes, arcs )( getKey );
                    var arr = [];
                    var index = {};
                    var onArc = function( arcId ) {
                        var obj = classify( arcId );
                        var key;
                        if ( obj ) {
                            key = obj.join( "~" );
                            if ( key in index === false ) {
                                arr.push( obj );
                                index[ key ] = true
                            }
                        }
                    };
                    MapShaper.forEachArcId( shapes, onArc );
                    return arr
                };
                api.cluster = function( lyr, arcs, opts ) {
                    MapShaper.requirePolygonLayer( lyr, "[cluster] Command requires a polygon layer" );
                    var groups = MapShaper.calcPolygonClusters( lyr, arcs, opts );
                    var idField = opts.id_field || "cluster";
                    MapShaper.insertFieldValues( lyr, idField, groups );
                    return lyr
                };
                MapShaper.calcPolygonClusters = function( lyr, arcs, opts ) {
                    var calcScore = MapShaper.getPolygonClusterCalculator( opts );
                    var size = lyr.shapes.length;
                    var count = Math.round( size * ( opts.pct || 1 ) );
                    var groupField = opts.group_by || null;
                    var shapeItems = lyr.shapes.map( function( shp, i ) {
                        var groupId = groupField && lyr.data.getRecordAt( i )[ groupField ] || null;
                        return {
                            ids: [ i ],
                            area: geom.getShapeArea( shp, arcs ),
                            bounds: arcs.getMultiShapeBounds( shp ),
                            centroid: geom.getShapeCentroid( shp, arcs ),
                            group: groupId,
                            friends: []
                        }
                    } );
                    var mergeItems = [];
                    var mergeIndex = {};
                    var next;
                    if ( groupField && !lyr.data ) stop( "[cluster] Missing attribute data table" );
                    MapShaper.findNeighbors( lyr.shapes, arcs ).forEach( function( ab, i ) {
                        var a = shapeItems[ ab[ 0 ] ],
                            b = shapeItems[ ab[ 1 ] ],
                            item, id;
                        if ( a.group !== b.group ) return;
                        item = {
                            ids: ab
                        };
                        item.score = getScore( item );
                        if ( item.score < 0 ) return;
                        id = mergeItems.length;
                        a.friends.push( id );
                        b.friends.push( id );
                        mergeItems.push( item )
                    } );
                    while ( count-- > 0 && ( next = nextItem() ) ) {
                        merge( next )
                    }
                    return shapeItems.filter( Boolean ).reduce( function( memo, shape, clusterId ) {
                        var ids = shape.ids;
                        for ( var i = 0; i < ids.length; i++ ) {
                            memo[ ids[ i ] ] = clusterId
                        }
                        return memo
                    }, [] );

                    function merge( item ) {
                        var merged = mergeShapes( item.ids );
                        var mergedId = shapeItems.length;
                        shapeItems[ mergedId ] = merged;
                        updateList( merged.friends, item.ids, mergedId )
                    }

                    function nextItem() {
                        var minId = -1,
                            min = Infinity,
                            item, i, n;
                        for ( i = 0, n = mergeItems.length; i < n; i++ ) {
                            item = mergeItems[ i ];
                            if ( item !== null && item.score < min ) {
                                min = item.score;
                                minId = i
                            }
                        }
                        if ( minId == -1 ) return null;
                        item = mergeItems[ minId ];
                        mergeItems[ minId ] = null;
                        return item
                    }

                    function getScore( item ) {
                        return calcScore( shapeItems[ item.ids[ 0 ] ], shapeItems[ item.ids[ 1 ] ] )
                    }

                    function mergeCentroids( dest, src ) {
                        var k = dest.area / ( dest.area + src.area ),
                            a = dest.centroid,
                            b = src.centroid;
                        a.x = a.x * k + b.x * ( 1 - k );
                        a.y = a.y * k + b.y * ( 1 - k )
                    }

                    function mergeShapes( ids ) {
                        var dest = shapeItems[ ids[ 0 ] ];
                        var src = shapeItems[ ids[ 1 ] ];
                        dest.bounds.mergeBounds( src.bounds );
                        dest.area += src.area;
                        dest.ids = dest.ids.concat( src.ids );
                        mergeCentroids( dest, src );
                        shapeItems[ ids[ 0 ] ] = null;
                        shapeItems[ ids[ 1 ] ] = null;
                        dest.friends = filterFriends( dest.friends.concat( src.friends ) );
                        return dest
                    }

                    function filterFriends( friends ) {
                        var index = {};
                        var merged = [];
                        var id;
                        for ( var i = 0; i < friends.length; i++ ) {
                            id = friends[ i ];
                            if ( id in index === false && mergeItems[ id ] !== null ) {
                                merged.push( id );
                                index[ id ] = true
                            }
                        }
                        return merged
                    }

                    function updateList( friends, oldIds, newId ) {
                        var item, id;
                        for ( var i = 0, n = friends.length; i < n; i++ ) {
                            id = friends[ i ];
                            item = mergeItems[ id ];
                            if ( contains( item.ids, oldIds ) ) {
                                mergeItems[ id ] = updateItem( item, oldIds, newId )
                            }
                        }
                    }

                    function updateItem( item, oldIds, newId ) {
                        var a = item.ids[ 0 ];
                        var b = item.ids[ 1 ];
                        var key;
                        if ( oldIds[ 0 ] == a || oldIds[ 1 ] == a ) a = newId;
                        if ( oldIds[ 0 ] == b || oldIds[ 1 ] == b ) b = newId;
                        if ( a == b ) return null;
                        item.ids = [ a, b ];
                        key = clusterKey( item );
                        if ( key in mergeIndex ) return null;
                        mergeIndex[ key ] = true;
                        item.score = getScore( item );
                        if ( item.score < 0 ) return null;
                        return item
                    }

                    function contains( a, b ) {
                        return a[ 0 ] === b[ 0 ] || a[ 0 ] === b[ 1 ] || a[ 1 ] === b[ 0 ] || a[ 1 ] === b[ 1 ]
                    }

                    function clusterKey( friend ) {
                        var a = friend.ids[ 0 ],
                            b = friend.ids[ 1 ];
                        if ( b < a ) {
                            a = b;
                            b = friend.ids[ 0 ]
                        }
                        return a + "," + b
                    }
                };
                MapShaper.getPolygonClusterCalculator = function( opts ) {
                    var maxWidth = opts.max_width || Infinity;
                    var maxHeight = opts.max_height || Infinity;
                    var maxArea = opts.max_area || Infinity;
                    return function( a, b ) {
                        var area = a.area + b.area,
                            score = geom.distance2D( a.centroid.x, a.centroid.y, b.centroid.x, b.centroid.y ),
                            bounds = a.bounds.clone().mergeBounds( b.bounds );
                        if ( area > maxArea || bounds.width() > maxWidth || bounds.height() > maxHeight ) {
                            score = -1
                        }
                        return score
                    }
                };
                var GeoJSON = {};
                GeoJSON.ID_FIELD = "FID";
                GeoJSON.typeLookup = {
                    LineString: "polyline",
                    MultiLineString: "polyline",
                    Polygon: "polygon",
                    MultiPolygon: "polygon",
                    Point: "point",
                    MultiPoint: "point"
                };
                GeoJSON.translateGeoJSONType = function( type ) {
                    return GeoJSON.typeLookup[ type ] || null
                };

                function getXYHash( size ) {
                    var buf = new ArrayBuffer( 16 ),
                        floats = new Float64Array( buf ),
                        uints = new Uint32Array( buf ),
                        lim = size | 0;
                    if ( lim > 0 === false ) {
                        throw new Error( "Invalid size param: " + size )
                    }
                    return function( x, y ) {
                        var u = uints,
                            h;
                        floats[ 0 ] = x;
                        floats[ 1 ] = y;
                        h = u[ 0 ] ^ u[ 1 ];
                        h = h << 5 ^ h >> 7 ^ u[ 2 ] ^ u[ 3 ];
                        return ( h & 2147483647 ) % lim
                    }
                }

                function getXHash( size ) {
                    var buf = new ArrayBuffer( 8 ),
                        floats = new Float64Array( buf ),
                        uints = new Uint32Array( buf ),
                        lim = size | 0;
                    if ( lim > 0 === false ) {
                        throw new Error( "Invalid size param: " + size )
                    }
                    return function( x ) {
                        var h;
                        floats[ 0 ] = x;
                        h = uints[ 0 ] ^ uints[ 1 ];
                        h = h << 5 ^ h >> 7;
                        return ( h & 2147483647 ) % lim
                    }
                }

                function ArcIndex( pointCount ) {
                    var hashTableSize = Math.floor( pointCount * .25 + 1 ),
                        hash = getXYHash( hashTableSize ),
                        hashTable = new Int32Array( hashTableSize ),
                        chainIds = [],
                        arcs = [],
                        arcPoints = 0;
                    utils.initializeArray( hashTable, -1 );
                    this.addArc = function( xx, yy ) {
                        var end = xx.length - 1,
                            key = hash( xx[ end ], yy[ end ] ),
                            chainId = hashTable[ key ],
                            arcId = arcs.length;
                        hashTable[ key ] = arcId;
                        arcs.push( [ xx, yy ] );
                        arcPoints += xx.length;
                        chainIds.push( chainId );
                        return arcId
                    };
                    this.findMatchingArc = function( xx, yy, start, end, getNext, getPrev ) {
                        var arcId = findArcNeighbor( xx, yy, start, end, getNext );
                        if ( arcId === null ) {
                            arcId = findArcNeighbor( xx, yy, end, start, getPrev )
                        } else {
                            arcId = ~arcId
                        }
                        return arcId
                    };

                    function findArcNeighbor( xx, yy, start, end, getNext ) {
                        var next = getNext( start ),
                            key = hash( xx[ start ], yy[ start ] ),
                            arcId = hashTable[ key ],
                            arcX, arcY, len;
                        while ( arcId != -1 ) {
                            arcX = arcs[ arcId ][ 0 ];
                            arcY = arcs[ arcId ][ 1 ];
                            len = arcX.length;
                            if ( arcX[ 0 ] === xx[ end ] && arcX[ len - 1 ] === xx[ start ] && arcX[ len - 2 ] === xx[ next ] && arcY[ 0 ] === yy[ end ] && arcY[ len - 1 ] === yy[ start ] && arcY[ len - 2 ] === yy[ next ] ) {
                                return arcId
                            }
                            arcId = chainIds[ arcId ]
                        }
                        return null
                    }
                    this.getVertexData = function() {
                        var xx = new Float64Array( arcPoints ),
                            yy = new Float64Array( arcPoints ),
                            nn = new Uint32Array( arcs.length ),
                            copied = 0,
                            arc, len;
                        for ( var i = 0, n = arcs.length; i < n; i++ ) {
                            arc = arcs[ i ];
                            len = arc[ 0 ].length;
                            utils.copyElements( arc[ 0 ], 0, xx, copied, len );
                            utils.copyElements( arc[ 1 ], 0, yy, copied, len );
                            nn[ i ] = len;
                            copied += len
                        }
                        return {
                            xx: xx,
                            yy: yy,
                            nn: nn
                        }
                    }
                }

                function initHashChains( xx, yy ) {
                    var n = xx.length,
                        m = Math.floor( n * 1.3 ) || 1,
                        hash = getXYHash( m ),
                        hashTable = new Int32Array( m ),
                        chainIds = new Int32Array( n ),
                        key, j;
                    for ( var i = 0; i < n; i++ ) {
                        key = hash( xx[ i ], yy[ i ] );
                        j = hashTable[ key ] - 1;
                        hashTable[ key ] = i + 1;
                        chainIds[ i ] = j < 0 ? i : j
                    }
                    return chainIds
                }

                function initPointChains( xx, yy ) {
                    var chainIds = initHashChains( xx, yy ),
                        j, next, prevMatchId, prevUnmatchId;
                    for ( var i = xx.length - 1; i >= 0; i-- ) {
                        next = chainIds[ i ];
                        if ( next >= i ) continue;
                        prevMatchId = i;
                        prevUnmatchId = -1;
                        do {
                            j = next;
                            next = chainIds[ j ];
                            if ( yy[ j ] == yy[ i ] && xx[ j ] == xx[ i ] ) {
                                chainIds[ j ] = prevMatchId;
                                prevMatchId = j
                            } else {
                                if ( prevUnmatchId > -1 ) {
                                    chainIds[ prevUnmatchId ] = j
                                }
                                prevUnmatchId = j
                            }
                        } while ( next < j );
                        if ( prevUnmatchId > -1 ) {
                            chainIds[ prevUnmatchId ] = prevUnmatchId
                        }
                        chainIds[ i ] = prevMatchId
                    }
                    return chainIds
                }
                api.buildTopology = function( dataset ) {
                    if ( !dataset.arcs ) return;
                    var raw = dataset.arcs.getVertexData(),
                        cooked = MapShaper.buildPathTopology( raw.nn, raw.xx, raw.yy );
                    dataset.arcs.updateVertexData( cooked.nn, cooked.xx, cooked.yy );
                    dataset.layers.forEach( function( lyr ) {
                        if ( lyr.geometry_type == "polyline" || lyr.geometry_type == "polygon" ) {
                            lyr.shapes = MapShaper.replaceArcIds( lyr.shapes, cooked.paths )
                        }
                    } )
                };
                MapShaper.buildPathTopology = function( nn, xx, yy ) {
                    var pointCount = xx.length,
                        chainIds = initPointChains( xx, yy ),
                        pathIds = initPathIds( pointCount, nn ),
                        index = new ArcIndex( pointCount ),
                        slice = usingTypedArrays() ? xx.subarray : Array.prototype.slice,
                        paths, retn;
                    paths = convertPaths( nn );
                    retn = index.getVertexData();
                    retn.paths = paths;
                    return retn;

                    function usingTypedArrays() {
                        return !!( xx.subarray && yy.subarray )
                    }

                    function convertPaths( nn ) {
                        var paths = [],
                            pointId = 0,
                            pathLen;
                        for ( var i = 0, len = nn.length; i < len; i++ ) {
                            pathLen = nn[ i ];
                            paths.push( pathLen < 2 ? null : convertPath( pointId, pointId + pathLen - 1 ) );
                            pointId += pathLen
                        }
                        return paths
                    }

                    function nextPoint( id ) {
                        var partId = pathIds[ id ],
                            nextId = id + 1;
                        if ( nextId < pointCount && pathIds[ nextId ] === partId ) {
                            return id + 1
                        }
                        var len = nn[ partId ];
                        return sameXY( id, id - len + 1 ) ? id - len + 2 : -1
                    }

                    function prevPoint( id ) {
                        var partId = pathIds[ id ],
                            prevId = id - 1;
                        if ( prevId >= 0 && pathIds[ prevId ] === partId ) {
                            return id - 1
                        }
                        var len = nn[ partId ];
                        return sameXY( id, id + len - 1 ) ? id + len - 2 : -1
                    }

                    function sameXY( a, b ) {
                        return xx[ a ] == xx[ b ] && yy[ a ] == yy[ b ]
                    }

                    function convertPath( start, end ) {
                        var arcIds = [],
                            firstNodeId = -1,
                            arcStartId;
                        for ( var i = start; i < end; i++ ) {
                            if ( pointIsArcEndpoint( i ) ) {
                                if ( firstNodeId > -1 ) {
                                    arcIds.push( addEdge( arcStartId, i ) )
                                } else {
                                    firstNodeId = i
                                }
                                arcStartId = i
                            }
                        }
                        if ( firstNodeId == -1 ) {
                            arcIds.push( addRing( start, end ) )
                        } else if ( firstNodeId == start ) {
                            if ( !pointIsArcEndpoint( end ) ) {
                                error( "Topology error" )
                            }
                            arcIds.push( addEdge( arcStartId, i ) )
                        } else {
                            arcIds.push( addSplitEdge( arcStartId, end, start + 1, firstNodeId ) )
                        }
                        return arcIds
                    }

                    function pointIsArcEndpoint( id ) {
                        var id2 = chainIds[ id ],
                            prev = prevPoint( id ),
                            next = nextPoint( id ),
                            prev2, next2;
                        if ( prev == -1 || next == -1 ) {
                            return true
                        }
                        while ( id != id2 ) {
                            prev2 = prevPoint( id2 );
                            next2 = nextPoint( id2 );
                            if ( prev2 == -1 || next2 == -1 || brokenEdge( prev, next, prev2, next2 ) ) {
                                return true
                            }
                            id2 = chainIds[ id2 ]
                        }
                        return false
                    }

                    function brokenEdge( aprev, anext, bprev, bnext ) {
                        var apx = xx[ aprev ],
                            anx = xx[ anext ],
                            bpx = xx[ bprev ],
                            bnx = xx[ bnext ],
                            apy = yy[ aprev ],
                            any = yy[ anext ],
                            bpy = yy[ bprev ],
                            bny = yy[ bnext ];
                        if ( apx == bnx && anx == bpx && apy == bny && any == bpy || apx == bpx && anx == bnx && apy == bpy && any == bny ) {
                            return false
                        }
                        return true
                    }

                    function mergeArcParts( src, startId, endId, startId2, endId2 ) {
                        var len = endId - startId + endId2 - startId2 + 2,
                            ArrayClass = usingTypedArrays() ? Float64Array : Array,
                            dest = new ArrayClass( len ),
                            j = 0,
                            i;
                        for ( i = startId; i <= endId; i++ ) {
                            dest[ j++ ] = src[ i ]
                        }
                        for ( i = startId2; i <= endId2; i++ ) {
                            dest[ j++ ] = src[ i ]
                        }
                        return dest
                    }

                    function addSplitEdge( start1, end1, start2, end2 ) {
                        var arcId = index.findMatchingArc( xx, yy, start1, end2, nextPoint, prevPoint );
                        if ( arcId === null ) {
                            arcId = index.addArc( mergeArcParts( xx, start1, end1, start2, end2 ), mergeArcParts( yy, start1, end1, start2, end2 ) )
                        }
                        return arcId
                    }

                    function addEdge( start, end ) {
                        var arcId = index.findMatchingArc( xx, yy, start, end, nextPoint, prevPoint );
                        if ( arcId === null ) {
                            arcId = index.addArc( slice.call( xx, start, end + 1 ), slice.call( yy, start, end + 1 ) )
                        }
                        return arcId
                    }

                    function addRing( startId, endId ) {
                        var chainId = chainIds[ startId ],
                            pathId = pathIds[ startId ],
                            arcId;
                        while ( chainId != startId ) {
                            if ( pathIds[ chainId ] < pathId ) {
                                break
                            }
                            chainId = chainIds[ chainId ]
                        }
                        if ( chainId == startId ) {
                            return addEdge( startId, endId )
                        }
                        for ( var i = startId; i < endId; i++ ) {
                            arcId = index.findMatchingArc( xx, yy, i, i, nextPoint, prevPoint );
                            if ( arcId !== null ) return arcId
                        }
                        error( "Unmatched ring; id:", pathId, "len:", nn[ pathId ] )
                    }
                };

                function initPathIds( size, pathSizes ) {
                    var pathIds = new Int32Array( size ),
                        j = 0;
                    for ( var pathId = 0, pathCount = pathSizes.length; pathId < pathCount; pathId++ ) {
                        for ( var i = 0, n = pathSizes[ pathId ]; i < n; i++, j++ ) {
                            pathIds[ j ] = pathId
                        }
                    }
                    return pathIds
                }
                MapShaper.replaceArcIds = function( src, replacements ) {
                    return src.map( function( shape ) {
                        return replaceArcsInShape( shape, replacements )
                    } );

                    function replaceArcsInShape( shape, replacements ) {
                        if ( !shape ) return null;
                        return shape.map( function( path ) {
                            return replaceArcsInPath( path, replacements )
                        } )
                    }

                    function replaceArcsInPath( path, replacements ) {
                        return path.reduce( function( memo, id ) {
                            var abs = absArcId( id );
                            var topoPath = replacements[ abs ];
                            if ( topoPath ) {
                                if ( id < 0 ) {
                                    topoPath = topoPath.concat();
                                    MapShaper.reversePath( topoPath )
                                }
                                for ( var i = 0, n = topoPath.length; i < n; i++ ) {
                                    memo.push( topoPath[ i ] )
                                }
                            }
                            return memo
                        }, [] )
                    }
                };
                MapShaper.getHighPrecisionSnapInterval = function( arcs ) {
                    var bb = arcs.getBounds();
                    if ( !bb.hasBounds() ) return 0;
                    var maxCoord = Math.max( Math.abs( bb.xmin ), Math.abs( bb.ymin ), Math.abs( bb.xmax ), Math.abs( bb.ymax ) );
                    return maxCoord * 1e-14
                };
                MapShaper.snapCoords = function( arcs, threshold ) {
                    var avgDist = MapShaper.getAvgSegment( arcs ),
                        autoSnapDist = avgDist * .0025,
                        snapDist = autoSnapDist;
                    if ( threshold > 0 ) {
                        snapDist = threshold;
                        message( utils.format( "Applying snapping threshold of %s -- %.6f times avg. segment length", threshold, threshold / avgDist ) )
                    }
                    var snapCount = MapShaper.snapCoordsByInterval( arcs, snapDist );
                    if ( snapCount > 0 ) arcs.dedupCoords();
                    message( utils.format( "Snapped %s point%s", snapCount, utils.pluralSuffix( snapCount ) ) )
                };
                MapShaper.snapCoordsByInterval = function( arcs, snapDist ) {
                    var snapCount = 0,
                        data = arcs.getVertexData();
                    var ids = utils.sortCoordinateIds( data.xx );
                    for ( var i = 0, n = ids.length; i < n; i++ ) {
                        snapCount += snapPoint( i, snapDist, ids, data.xx, data.yy )
                    }
                    return snapCount;

                    function snapPoint( i, limit, ids, xx, yy ) {
                        var j = i,
                            n = ids.length,
                            x = xx[ ids[ i ] ],
                            y = yy[ ids[ i ] ],
                            snaps = 0,
                            id2, dx, dy;
                        while ( ++j < n ) {
                            id2 = ids[ j ];
                            dx = xx[ id2 ] - x;
                            if ( dx > limit ) break;
                            dy = yy[ id2 ] - y;
                            if ( dx === 0 && dy === 0 || dx * dx + dy * dy > limit * limit ) continue;
                            xx[ id2 ] = x;
                            yy[ id2 ] = y;
                            snaps++
                        }
                        return snaps
                    }
                };
                utils.sortCoordinateIds = function( a ) {
                    var n = a.length,
                        ids = new Uint32Array( n );
                    for ( var i = 0; i < n; i++ ) {
                        ids[ i ] = i
                    }
                    utils.quicksortIds( a, ids, 0, ids.length - 1 );
                    return ids
                };
                utils.quicksortIds = function( a, ids, lo, hi ) {
                    if ( hi - lo > 24 ) {
                        var pivot = a[ ids[ lo + hi >> 1 ] ],
                            i = lo,
                            j = hi,
                            tmp;
                        while ( i <= j ) {
                            while ( a[ ids[ i ] ] < pivot ) i++;
                            while ( a[ ids[ j ] ] > pivot ) j--;
                            if ( i <= j ) {
                                tmp = ids[ i ];
                                ids[ i ] = ids[ j ];
                                ids[ j ] = tmp;
                                i++;
                                j--
                            }
                        }
                        if ( j > lo ) utils.quicksortIds( a, ids, lo, j );
                        if ( i < hi ) utils.quicksortIds( a, ids, i, hi )
                    } else {
                        utils.insertionSortIds( a, ids, lo, hi )
                    }
                };
                utils.insertionSortIds = function( arr, ids, start, end ) {
                    var id, i, j;
                    for ( j = start + 1; j <= end; j++ ) {
                        id = ids[ j ];
                        for ( i = j - 1; i >= start && arr[ id ] < arr[ ids[ i ] ]; i-- ) {
                            ids[ i + 1 ] = ids[ i ]
                        }
                        ids[ i + 1 ] = id
                    }
                };

                function PathImportStream( drain ) {
                    var buflen = 1e4,
                        xx = new Float64Array( buflen ),
                        yy = new Float64Array( buflen ),
                        i = 0;
                    this.endPath = function() {
                        drain( xx, yy, i );
                        i = 0
                    };
                    this.addPoint = function( x, y ) {
                        if ( i >= buflen ) {
                            buflen = Math.ceil( buflen * 1.3 );
                            xx = utils.extendBuffer( xx, buflen );
                            yy = utils.extendBuffer( yy, buflen )
                        }
                        xx[ i ] = x;
                        yy[ i ] = y;
                        i++
                    }
                }

                function PathImporter( opts ) {
                    var bufSize = opts.reserved_points > 0 ? opts.reserved_points : 2e4,
                        xx = new Float64Array( bufSize ),
                        yy = new Float64Array( bufSize ),
                        shapes = [],
                        properties = [],
                        nn = [],
                        types = [],
                        collectionType = opts.type || null,
                        round = null,
                        pathId = -1,
                        shapeId = -1,
                        pointId = 0,
                        dupeCount = 0,
                        openRingCount = 0;
                    if ( opts.precision ) {
                        round = getRoundingFunction( opts.precision )
                    }
                    utils.extend( this, new PathImportStream( importPathCoords ) );
                    this.startShape = function( d ) {
                        shapes[ ++shapeId ] = null;
                        if ( d ) properties[ shapeId ] = d
                    };
                    this.importLine = function( points ) {
                        setShapeType( "polyline" );
                        this.importPath( points )
                    };
                    this.importPoints = function( points ) {
                        setShapeType( "point" );
                        if ( round ) {
                            points.forEach( function( p ) {
                                p[ 0 ] = round( p[ 0 ] );
                                p[ 1 ] = round( p[ 1 ] )
                            } )
                        }
                        points.forEach( appendToShape )
                    };
                    this.importRing = function( points, isHole ) {
                        var area = geom.getPlanarPathArea2( points );
                        setShapeType( "polygon" );
                        if ( isHole === true && area > 0 || isHole === false && area < 0 ) {
                            verbose( "Warning: reversing", isHole ? "a CW hole" : "a CCW ring" );
                            points.reverse()
                        }
                        this.importPath( points )
                    };
                    this.importPath = function importPath( points ) {
                        var p;
                        for ( var i = 0, n = points.length; i < n; i++ ) {
                            p = points[ i ];
                            this.addPoint( p[ 0 ], p[ 1 ] )
                        }
                        this.endPath()
                    };
                    this.done = function() {
                        var arcs;
                        var layers;
                        var lyr = {
                            name: ""
                        };
                        if ( dupeCount > 0 ) {
                            verbose( utils.format( "Removed %,d duplicate point%s", dupeCount, utils.pluralSuffix( dupeCount ) ) )
                        }
                        if ( openRingCount > 0 ) {
                            message( utils.format( "Closed %,d open polygon ring%s", openRingCount, utils.pluralSuffix( openRingCount ) ) )
                        }
                        if ( pointId > 0 ) {
                            if ( pointId < xx.length ) {
                                xx = xx.subarray( 0, pointId );
                                yy = yy.subarray( 0, pointId )
                            }
                            arcs = new ArcCollection( nn, xx, yy );
                            if ( opts.auto_snap || opts.snap_interval ) {
                                MapShaper.snapCoords( arcs, opts.snap_interval )
                            }
                        }
                        if ( collectionType == "mixed" ) {
                            layers = MapShaper.divideFeaturesByType( shapes, properties, types )
                        } else {
                            lyr = {
                                geometry_type: collectionType
                            };
                            if ( collectionType ) {
                                lyr.shapes = shapes
                            }
                            if ( properties.length > 0 ) {
                                lyr.data = new DataTable( properties )
                            }
                            layers = [ lyr ]
                        }
                        layers.forEach( function( lyr ) {
                            if ( MapShaper.layerHasPaths( lyr ) ) {
                                MapShaper.cleanShapes( lyr.shapes, arcs, lyr.geometry_type )
                            }
                            if ( lyr.data ) {
                                MapShaper.fixInconsistentFields( lyr.data.getRecords() )
                            }
                        } );
                        return {
                            arcs: arcs || null,
                            info: {},
                            layers: layers
                        }
                    };

                    function setShapeType( t ) {
                        var currType = shapeId < types.length ? types[ shapeId ] : null;
                        if ( !currType ) {
                            types[ shapeId ] = t;
                            if ( !collectionType ) {
                                collectionType = t
                            } else if ( t != collectionType ) {
                                collectionType = "mixed"
                            }
                        } else if ( currType != t ) {
                            stop( "Unable to import mixed-geometry GeoJSON features" )
                        }
                    }

                    function checkBuffers( needed ) {
                        if ( needed > xx.length ) {
                            var newLen = Math.max( needed, Math.ceil( xx.length * 1.5 ) );
                            xx = utils.extendBuffer( xx, newLen, pointId );
                            yy = utils.extendBuffer( yy, newLen, pointId )
                        }
                    }

                    function appendToShape( part ) {
                        var currShape = shapes[ shapeId ] || ( shapes[ shapeId ] = [] );
                        currShape.push( part )
                    }

                    function appendPath( n ) {
                        pathId++;
                        nn[ pathId ] = n;
                        appendToShape( [ pathId ] )
                    }

                    function importPathCoords( xsrc, ysrc, n ) {
                        var count = 0;
                        var x, y, prevX, prevY;
                        checkBuffers( pointId + n );
                        for ( var i = 0; i < n; i++ ) {
                            x = xsrc[ i ];
                            y = ysrc[ i ];
                            if ( round ) {
                                x = round( x );
                                y = round( y )
                            }
                            if ( i > 0 && x == prevX && y == prevY ) {
                                dupeCount++
                            } else {
                                xx[ pointId ] = x;
                                yy[ pointId ] = y;
                                pointId++;
                                count++
                            }
                            prevY = y;
                            prevX = x
                        }
                        if ( collectionType == "polygon" && count > 0 ) {
                            if ( xsrc[ 0 ] != xsrc[ n - 1 ] || ysrc[ 0 ] != ysrc[ n - 1 ] ) {
                                checkBuffers( pointId + 1 );
                                xx[ pointId ] = xsrc[ 0 ];
                                yy[ pointId ] = ysrc[ 0 ];
                                openRingCount++;
                                pointId++;
                                count++
                            }
                        }
                        appendPath( count )
                    }
                }
                MapShaper.importGeoJSON = function( src, opts ) {
                    var srcObj = utils.isString( src ) ? JSON.parse( src ) : src,
                        supportedGeometries = Object.keys( GeoJSON.pathImporters ),
                        idField = opts.id_field || GeoJSON.ID_FIELD,
                        importer = new PathImporter( opts ),
                        srcCollection, dataset;
                    if ( srcObj.type == "Feature" ) {
                        srcCollection = {
                            type: "FeatureCollection",
                            features: [ srcObj ]
                        }
                    } else if ( utils.contains( supportedGeometries, srcObj.type ) ) {
                        srcCollection = {
                            type: "GeometryCollection",
                            geometries: [ srcObj ]
                        }
                    } else {
                        srcCollection = srcObj
                    }( srcCollection.features || srcCollection.geometries || [] ).forEach( function( o ) {
                        var geom, rec;
                        if ( o.type == "Feature" ) {
                            geom = o.geometry;
                            rec = o.properties || {};
                            if ( "id" in o ) {
                                rec[ idField ] = o.id
                            }
                        } else if ( o.type ) {
                            geom = o
                        }
                        importer.startShape( rec );
                        if ( geom ) GeoJSON.importGeometry( geom, importer )
                    } );
                    dataset = importer.done();
                    MapShaper.importCRS( dataset, srcObj );
                    return dataset
                };
                GeoJSON.importGeometry = function( geom, importer ) {
                    var type = geom.type;
                    if ( type in GeoJSON.pathImporters ) {
                        GeoJSON.pathImporters[ type ]( geom.coordinates, importer )
                    } else if ( type == "GeometryCollection" ) {
                        geom.geometries.forEach( function( geom ) {
                            GeoJSON.importGeometry( geom, importer )
                        } )
                    } else {
                        verbose( "GeoJSON.importGeometry() Unsupported geometry type:", geom.type )
                    }
                };
                GeoJSON.pathImporters = {
                    LineString: function( coords, importer ) {
                        importer.importLine( coords )
                    },
                    MultiLineString: function( coords, importer ) {
                        for ( var i = 0; i < coords.length; i++ ) {
                            GeoJSON.pathImporters.LineString( coords[ i ], importer )
                        }
                    },
                    Polygon: function( coords, importer ) {
                        for ( var i = 0; i < coords.length; i++ ) {
                            importer.importRing( coords[ i ], i > 0 )
                        }
                    },
                    MultiPolygon: function( coords, importer ) {
                        for ( var i = 0; i < coords.length; i++ ) {
                            GeoJSON.pathImporters.Polygon( coords[ i ], importer )
                        }
                    },
                    Point: function( coord, importer ) {
                        importer.importPoints( [ coord ] )
                    },
                    MultiPoint: function( coords, importer ) {
                        importer.importPoints( coords )
                    }
                };
                MapShaper.importCRS = function( dataset, jsonObj ) {
                    if ( "crs" in jsonObj ) {
                        dataset.info.input_geojson_crs = jsonObj.crs
                    }
                };
                MapShaper.getFormattedStringify = function( numArrayKeys ) {
                    var keyIndex = utils.arrayToIndex( numArrayKeys );
                    var sentinel = "";
                    var stripRxp = new RegExp( '"' + sentinel + "|" + sentinel + '"', "g" );
                    var indentChars = "  ";

                    function replace( key, val ) {
                        if ( key in keyIndex && utils.isArray( val ) ) {
                            var str = JSON.stringify( val );
                            if ( str.indexOf( '"' == -1 ) ) {
                                return sentinel + str.replace( /,/g, ", " ) + sentinel
                            }
                        }
                        return val
                    }
                    return function( obj ) {
                        var json = JSON.stringify( obj, replace, indentChars );
                        return json.replace( stripRxp, "" )
                    }
                };
                MapShaper.exportPointData = function( points ) {
                    var data, path;
                    if ( !points || points.length === 0 ) {
                        data = {
                            partCount: 0,
                            pointCount: 0
                        }
                    } else {
                        path = {
                            points: points,
                            pointCount: points.length,
                            bounds: geom.getPathBounds( points )
                        };
                        data = {
                            bounds: path.bounds,
                            pathData: [ path ],
                            partCount: 1,
                            pointCount: path.pointCount
                        }
                    }
                    return data
                };
                MapShaper.exportPathData = function( shape, arcs, type ) {
                    if ( type == "point" ) return MapShaper.exportPointData( shape );
                    var pointCount = 0,
                        bounds = new Bounds,
                        paths = [];
                    if ( shape && ( type == "polyline" || type == "polygon" ) ) {
                        shape.forEach( function( arcIds, i ) {
                            var iter = arcs.getShapeIter( arcIds ),
                                path = MapShaper.exportPathCoords( iter ),
                                valid = true;
                            if ( type == "polygon" ) {
                                path.area = geom.getPlanarPathArea2( path.points );
                                valid = path.pointCount > 3 && path.area !== 0
                            } else if ( type == "polyline" ) {
                                valid = path.pointCount > 1
                            }
                            if ( valid ) {
                                pointCount += path.pointCount;
                                path.bounds = geom.getPathBounds( path.points );
                                bounds.mergeBounds( path.bounds );
                                paths.push( path )
                            } else {
                                verbose( "Skipping a collapsed", type, "path" )
                            }
                        } )
                    }
                    return {
                        pointCount: pointCount,
                        pathData: paths,
                        pathCount: paths.length,
                        bounds: bounds
                    }
                };
                MapShaper.exportPathCoords = function( iter ) {
                    var points = [],
                        i = 0,
                        x, y, prevX, prevY;
                    while ( iter.hasNext() ) {
                        x = iter.x;
                        y = iter.y;
                        if ( i === 0 || prevX != x || prevY != y ) {
                            points.push( [ x, y ] );
                            i++
                        }
                        prevX = x;
                        prevY = y
                    }
                    return {
                        points: points,
                        pointCount: points.length
                    }
                };
                MapShaper.exportGeoJSON = function( dataset, opts ) {
                    var extension = "json";
                    if ( opts.output_file ) {
                        extension = utils.getFileExtension( opts.output_file )
                    }
                    return dataset.layers.map( function( lyr ) {
                        return {
                            content: MapShaper.exportGeoJSONCollection( lyr, dataset, opts, true ),
                            filename: lyr.name ? lyr.name + "." + extension : ""
                        }
                    } )
                };
                MapShaper.exportGeoJSONCollection = function( lyr, dataset, opts, asString ) {
                    opts = opts || {};
                    var properties = MapShaper.exportProperties( lyr.data, opts ),
                        shapes = lyr.shapes,
                        ids = MapShaper.exportIds( lyr.data, opts ),
                        useFeatures = !!( properties || ids ),
                        geojson = {},
                        collection, collname, bounds, stringify;
                    if ( properties && shapes && properties.length !== shapes.length ) {
                        error( "[-o] Mismatch between number of properties and number of shapes" )
                    }
                    if ( asString ) {
                        stringify = opts.prettify ? MapShaper.getFormattedStringify( [ "bbox", "coordinates" ] ) : JSON.stringify
                    }
                    if ( useFeatures ) {
                        geojson.type = "FeatureCollection";
                        collname = "features"
                    } else {
                        geojson.type = "GeometryCollection";
                        collname = "geometries"
                    }
                    MapShaper.exportCRS( dataset, geojson );
                    if ( opts.bbox ) {
                        bounds = MapShaper.getLayerBounds( lyr, dataset.arcs );
                        if ( bounds.hasBounds() ) {
                            geojson.bbox = bounds.toArray()
                        }
                    }
                    collection = ( shapes || properties || [] ).reduce( function( memo, o, i ) {
                        var shape = shapes ? shapes[ i ] : null,
                            exporter = GeoJSON.exporters[ lyr.geometry_type ],
                            obj = shape ? exporter( shape, dataset.arcs ) : null;
                        if ( useFeatures ) {
                            obj = {
                                type: "Feature",
                                geometry: obj,
                                properties: properties ? properties[ i ] : null
                            };
                            if ( ids ) {
                                obj.id = ids[ i ]
                            }
                        } else if ( !obj ) {
                            return memo
                        }
                        if ( asString ) {
                            obj = stringify( obj )
                        }
                        memo.push( obj );
                        return memo
                    }, [] );
                    if ( asString ) {
                        geojson[ collname ] = [ "$" ];
                        geojson = JSON.stringify( geojson ).replace( '"$"', "\n" + collection.join( ",\n" ) + "\n" )
                    } else {
                        geojson[ collname ] = collection
                    }
                    return geojson
                };
                GeoJSON.exportPointGeom = function( points, arcs ) {
                    var geom = null;
                    if ( points.length == 1 ) {
                        geom = {
                            type: "Point",
                            coordinates: points[ 0 ]
                        }
                    } else if ( points.length > 1 ) {
                        geom = {
                            type: "MultiPoint",
                            coordinates: points
                        }
                    }
                    return geom
                };
                GeoJSON.exportLineGeom = function( ids, arcs ) {
                    var obj = MapShaper.exportPathData( ids, arcs, "polyline" );
                    if ( obj.pointCount === 0 ) return null;
                    var coords = obj.pathData.map( function( path ) {
                        return path.points
                    } );
                    return coords.length == 1 ? {
                        type: "LineString",
                        coordinates: coords[ 0 ]
                    } : {
                        type: "MultiLineString",
                        coordinates: coords
                    }
                };
                GeoJSON.exportPolygonGeom = function( ids, arcs ) {
                    var obj = MapShaper.exportPathData( ids, arcs, "polygon" );
                    if ( obj.pointCount === 0 ) return null;
                    var groups = MapShaper.groupPolygonRings( obj.pathData );
                    var coords = groups.map( function( paths ) {
                        return paths.map( function( path ) {
                            return path.points
                        } )
                    } );
                    return coords.length == 1 ? {
                        type: "Polygon",
                        coordinates: coords[ 0 ]
                    } : {
                        type: "MultiPolygon",
                        coordinates: coords
                    }
                };
                GeoJSON.exporters = {
                    polygon: GeoJSON.exportPolygonGeom,
                    polyline: GeoJSON.exportLineGeom,
                    point: GeoJSON.exportPointGeom
                };
                MapShaper.exportCRS = function( dataset, jsonObj ) {
                    var info = dataset.info || {};
                    if ( !info.crs && "input_geojson_crs" in info ) {
                        jsonObj.crs = info.input_geojson_crs
                    } else if ( info.crs && !info.crs.is_latlong ) {
                        jsonObj.crs = null
                    } else {}
                };
                MapShaper.getIdField = function( fields, opt ) {
                    var ids = [];
                    if ( utils.isString( opt ) ) {
                        ids.push( opt )
                    } else if ( utils.isArray( opt ) ) {
                        ids = opt
                    }
                    ids.push( GeoJSON.ID_FIELD );
                    return utils.find( ids, function( name ) {
                        return utils.contains( fields, name )
                    } )
                };
                MapShaper.exportProperties = function( table, opts ) {
                    var fields = table ? table.getFields() : [],
                        idField = MapShaper.getIdField( fields, opts.id_field ),
                        deleteId = idField == GeoJSON.ID_FIELD,
                        properties, records;
                    if ( opts.drop_table || opts.cut_table || fields.length === 0 || deleteId && fields.length == 1 ) {
                        return null
                    }
                    records = table.getRecords();
                    if ( deleteId ) {
                        properties = records.map( function( rec ) {
                            rec = utils.extend( {}, rec );
                            delete rec[ idField ];
                            return rec
                        } )
                    } else {
                        properties = records
                    }
                    return properties
                };
                MapShaper.exportIds = function( table, opts ) {
                    var fields = table ? table.getFields() : [],
                        idField = MapShaper.getIdField( fields, opts.id_field );
                    if ( !idField ) return null;
                    return table.getRecords().map( function( rec ) {
                        return idField in rec ? rec[ idField ] : null
                    } )
                };
                var TopoJSON = {};
                TopoJSON.forEachPath = function forEachPath( obj, cb ) {
                    var iterators = {
                        GeometryCollection: function( o ) {
                            o.geometries.forEach( eachGeom )
                        },
                        LineString: function( o ) {
                            var retn = cb( o.arcs );
                            if ( retn ) o.arcs = retn
                        },
                        MultiLineString: function( o ) {
                            eachMultiPath( o.arcs )
                        },
                        Polygon: function( o ) {
                            eachMultiPath( o.arcs )
                        },
                        MultiPolygon: function( o ) {
                            o.arcs.forEach( eachMultiPath )
                        }
                    };
                    eachGeom( obj );

                    function eachGeom( o ) {
                        if ( o.type in iterators ) {
                            iterators[ o.type ]( o )
                        }
                    }

                    function eachMultiPath( arr ) {
                        var retn;
                        for ( var i = 0; i < arr.length; i++ ) {
                            retn = cb( arr[ i ] );
                            if ( retn ) arr[ i ] = retn
                        }
                    }
                };
                TopoJSON.forEachArc = function forEachArc( obj, cb ) {
                    TopoJSON.forEachPath( obj, function( ids ) {
                        var retn;
                        for ( var i = 0; i < ids.length; i++ ) {
                            retn = cb( ids[ i ] );
                            if ( utils.isInteger( retn ) ) {
                                ids[ i ] = retn
                            }
                        }
                    } )
                };
                MapShaper.importTopoJSON = function( topology, opts ) {
                    var dataset, arcs, layers;
                    if ( utils.isString( topology ) ) {
                        topology = JSON.parse( topology )
                    }
                    if ( topology.arcs && topology.arcs.length > 0 ) {
                        if ( topology.transform ) {
                            TopoJSON.decodeArcs( topology.arcs, topology.transform )
                        }
                        if ( opts && opts.precision ) {
                            TopoJSON.roundCoords( topology.arcs, opts.precision )
                        }
                        arcs = new ArcCollection( topology.arcs )
                    }
                    layers = Object.keys( topology.objects ).reduce( function( memo, name ) {
                        var layers = TopoJSON.importObject( topology.objects[ name ], arcs, opts ),
                            lyr;
                        for ( var i = 0, n = layers.length; i < n; i++ ) {
                            lyr = layers[ i ];
                            lyr.name = name;
                            memo.push( lyr )
                        }
                        return memo
                    }, [] );
                    layers.forEach( function( lyr ) {
                        if ( MapShaper.layerHasPaths( lyr ) ) {
                            MapShaper.cleanShapes( lyr.shapes, arcs, lyr.geometry_type )
                        }
                        if ( lyr.geometry_type == "point" && topology.transform ) {
                            TopoJSON.decodePoints( lyr.shapes, topology.transform )
                        }
                        if ( lyr.data ) {
                            MapShaper.fixInconsistentFields( lyr.data.getRecords() )
                        }
                    } );
                    dataset = {
                        layers: layers,
                        arcs: arcs,
                        info: {}
                    };
                    MapShaper.importCRS( dataset, topology );
                    return dataset
                };
                TopoJSON.decodePoints = function( shapes, transform ) {
                    MapShaper.forEachPoint( shapes, function( p ) {
                        p[ 0 ] = p[ 0 ] * transform.scale[ 0 ] + transform.translate[ 0 ];
                        p[ 1 ] = p[ 1 ] * transform.scale[ 1 ] + transform.translate[ 1 ]
                    } )
                };
                TopoJSON.decodeArcs = function( arcs, transform ) {
                    var mx = transform.scale[ 0 ],
                        my = transform.scale[ 1 ],
                        bx = transform.translate[ 0 ],
                        by = transform.translate[ 1 ];
                    arcs.forEach( function( arc ) {
                        var prevX = 0,
                            prevY = 0,
                            xy, x, y;
                        for ( var i = 0, len = arc.length; i < len; i++ ) {
                            xy = arc[ i ];
                            x = xy[ 0 ] + prevX;
                            y = xy[ 1 ] + prevY;
                            xy[ 0 ] = x * mx + bx;
                            xy[ 1 ] = y * my + by;
                            prevX = x;
                            prevY = y
                        }
                    } )
                };
                TopoJSON.roundCoords = function( arcs, precision ) {
                    var round = getRoundingFunction( precision ),
                        p;
                    arcs.forEach( function( arc ) {
                        for ( var i = 0, len = arc.length; i < len; i++ ) {
                            p = arc[ i ];
                            p[ 0 ] = round( p[ 0 ] );
                            p[ 1 ] = round( p[ 1 ] )
                        }
                    } )
                };
                TopoJSON.importObject = function( obj, arcs, opts ) {
                    var importer = new TopoJSON.GeometryImporter( arcs, opts );
                    var geometries = obj.type == "GeometryCollection" ? obj.geometries : [ obj ];
                    geometries.forEach( importer.addGeometryObject, importer );
                    return importer.done()
                };
                TopoJSON.GeometryImporter = function( arcs, opts ) {
                    var idField = opts && opts.id_field || GeoJSON.ID_FIELD,
                        properties = [],
                        shapes = [],
                        types = [],
                        dataNulls = 0,
                        shapeNulls = 0,
                        collectionType = null,
                        shapeId;
                    this.addGeometryObject = function( geom ) {
                        var rec = geom.properties || null;
                        shapeId = shapes.length;
                        shapes[ shapeId ] = null;
                        if ( "id" in geom ) {
                            rec = rec || {};
                            rec[ idField ] = geom.id
                        }
                        properties[ shapeId ] = rec;
                        if ( !rec ) dataNulls++;
                        if ( geom.type ) {
                            this.addShape( geom )
                        }
                        if ( shapes[ shapeId ] === null ) {
                            shapeNulls++
                        }
                    };
                    this.addShape = function( geom ) {
                        var curr = shapes[ shapeId ];
                        var type = GeoJSON.translateGeoJSONType( geom.type );
                        var shape, importer;
                        if ( geom.type == "GeometryCollection" ) {
                            geom.geometries.forEach( this.addShape, this )
                        } else if ( type ) {
                            this.setGeometryType( type );
                            shape = TopoJSON.shapeImporters[ geom.type ]( geom, arcs );
                            if ( !shape || !shape.length ) {} else if ( !Array.isArray( shape[ 0 ] ) ) {
                                stop( "Invalid TopoJSON", geom.type, "geometry" )
                            } else {
                                shapes[ shapeId ] = curr ? curr.concat( shape ) : shape
                            }
                        } else if ( geom.type ) {
                            stop( "Invalid TopoJSON geometry type:", geom.type )
                        }
                    };
                    this.setGeometryType = function( type ) {
                        var currType = shapeId < types.length ? types[ shapeId ] : null;
                        if ( !currType ) {
                            types[ shapeId ] = type;
                            this.updateCollectionType( type )
                        } else if ( currType != type ) {
                            stop( "Unable to import mixed-type TopoJSON geometries" )
                        }
                    };
                    this.updateCollectionType = function( type ) {
                        if ( !collectionType ) {
                            collectionType = type
                        } else if ( type && collectionType != type ) {
                            collectionType = "mixed"
                        }
                    };
                    this.done = function() {
                        var layers;
                        if ( collectionType == "mixed" ) {
                            layers = MapShaper.divideFeaturesByType( shapes, properties, types )
                        } else {
                            layers = [ {
                                geometry_type: collectionType,
                                shapes: collectionType ? shapes : null,
                                data: dataNulls < shapes.length ? new DataTable( properties ) : null
                            } ]
                        }
                        return layers
                    }
                };
                TopoJSON.importPolygonArcs = function( rings, arcs ) {
                    var ring = rings[ 0 ],
                        area = geom.getPlanarPathArea( ring, arcs ),
                        imported = null;
                    if ( !area ) {
                        return null
                    }
                    if ( area < 0 ) MapShaper.reversePath( ring );
                    imported = [ ring ];
                    for ( var i = 1; i < rings.length; i++ ) {
                        ring = rings[ i ];
                        area = geom.getPlanarPathArea( ring, arcs );
                        if ( !area ) continue;
                        if ( area > 0 ) MapShaper.reversePath( ring );
                        imported.push( ring )
                    }
                    return imported
                };
                TopoJSON.shapeImporters = {
                    Point: function( geom ) {
                        return [ geom.coordinates ]
                    },
                    MultiPoint: function( geom ) {
                        return geom.coordinates
                    },
                    LineString: function( geom ) {
                        return [ geom.arcs ]
                    },
                    MultiLineString: function( geom ) {
                        return geom.arcs
                    },
                    Polygon: function( geom, arcColl ) {
                        return TopoJSON.importPolygonArcs( geom.arcs, arcColl )
                    },
                    MultiPolygon: function( geom, arcColl ) {
                        return geom.arcs.reduce( function( memo, arr ) {
                            var rings = TopoJSON.importPolygonArcs( arr, arcColl );
                            if ( rings ) {
                                memo = memo ? memo.concat( rings ) : rings
                            }
                            return memo
                        }, null )
                    }
                };
                TopoJSON.getPresimplifyFunction = function( width ) {
                    var quanta = 1e4,
                        k = quanta / width;
                    return function( z ) {
                        return z === Infinity ? 0 : Math.ceil( z * k )
                    }
                };
                api.explodeFeatures = function( lyr, arcs, opts ) {
                    var properties = lyr.data ? lyr.data.getRecords() : null,
                        explodedProperties = properties ? [] : null,
                        explodedShapes = [],
                        explodedLyr = utils.extend( {}, lyr );
                    lyr.shapes.forEach( function explodeShape( shp, shpId ) {
                        var exploded;
                        if ( !shp ) {
                            explodedShapes.push( null )
                        } else {
                            if ( lyr.geometry_type == "polygon" && shp.length > 1 ) {
                                exploded = MapShaper.explodePolygon( shp, arcs )
                            } else {
                                exploded = MapShaper.explodeShape( shp )
                            }
                            utils.merge( explodedShapes, exploded )
                        }
                        if ( explodedProperties !== null ) {
                            for ( var i = 0, n = exploded ? exploded.length : 1; i < n; i++ ) {
                                explodedProperties.push( MapShaper.cloneProperties( properties[ shpId ] ) )
                            }
                        }
                    } );
                    explodedLyr.shapes = explodedShapes;
                    if ( explodedProperties !== null ) {
                        explodedLyr.data = new DataTable( explodedProperties )
                    }
                    return explodedLyr
                };
                MapShaper.explodeShape = function( shp ) {
                    return shp.map( function( part ) {
                        return [ part.concat() ]
                    } )
                };
                MapShaper.explodePolygon = function( shape, arcs ) {
                    var paths = MapShaper.getPathMetadata( shape, arcs, "polygon" );
                    var groups = MapShaper.groupPolygonRings( paths );
                    return groups.map( function( group ) {
                        return group.map( function( ring ) {
                            return ring.ids
                        } )
                    } )
                };
                MapShaper.cloneProperties = function( obj ) {
                    var clone = {};
                    for ( var key in obj ) {
                        clone[ key ] = obj[ key ]
                    }
                    return clone
                };
                MapShaper.exportTopoJSON = function( dataset, opts ) {
                    var extension = ".json",
                        needCopy = !opts.final || MapShaper.datasetHasPaths( dataset ) && dataset.arcs.getRetainedInterval() > 0,
                        stringify = JSON.stringify;
                    if ( opts.prettify ) {
                        stringify = MapShaper.getFormattedStringify( "coordinates,arcs,bbox,translate,scale".split( "," ) )
                    }
                    if ( opts.singles ) {
                        return MapShaper.splitDataset( dataset ).map( function( dataset ) {
                            if ( needCopy ) dataset = MapShaper.copyDatasetForExport( dataset );
                            return {
                                content: stringify( TopoJSON.exportTopology( dataset, opts ) ),
                                filename: ( dataset.layers[ 0 ].name || "output" ) + extension
                            }
                        } )
                    } else {
                        if ( needCopy ) {
                            dataset = MapShaper.copyDatasetForExport( dataset )
                        }
                        return [ {
                            filename: opts.output_file || utils.getOutputFileBase( dataset ) + extension,
                            content: stringify( TopoJSON.exportTopology( dataset, opts ) )
                        } ]
                    }
                };
                TopoJSON.exportTopology = function( dataset, opts ) {
                    var topology = {
                            type: "Topology",
                            arcs: []
                        },
                        hasPaths = MapShaper.datasetHasPaths( dataset ),
                        bounds = MapShaper.getDatasetBounds( dataset );
                    if ( opts.bbox && bounds.hasBounds() ) {
                        topology.bbox = bounds.toArray()
                    }
                    if ( hasPaths && opts.presimplify && !dataset.arcs.getVertexData().zz ) {
                        api.simplify( dataset, opts )
                    }
                    if ( !opts.no_quantization && ( opts.quantization || hasPaths ) ) {
                        topology.transform = TopoJSON.transformDataset( dataset, bounds, opts )
                    }
                    if ( hasPaths ) {
                        MapShaper.dissolveArcs( dataset );
                        topology.arcs = TopoJSON.exportArcs( dataset.arcs, bounds, opts );
                        if ( topology.transform ) {
                            TopoJSON.deltaEncodeArcs( topology.arcs )
                        }
                    }
                    topology.objects = dataset.layers.reduce( function( objects, lyr, i ) {
                        var name = lyr.name || "layer" + ( i + 1 );
                        objects[ name ] = TopoJSON.exportLayer( lyr, dataset.arcs, opts );
                        return objects
                    }, {} );
                    MapShaper.exportCRS( dataset, topology );
                    return topology
                };
                TopoJSON.transformDataset = function( dataset, bounds, opts ) {
                    var bounds2 = TopoJSON.calcExportBounds( bounds, dataset.arcs, opts ),
                        fw = bounds.getTransform( bounds2 ),
                        inv = fw.invert();
                    MapShaper.transformPoints( dataset, function( x, y ) {
                        var p = fw.transform( x, y );
                        return [ Math.round( p[ 0 ] ), Math.round( p[ 1 ] ) ]
                    } );
                    return {
                        scale: [ inv.mx, inv.my ],
                        translate: [ inv.bx, inv.by ]
                    }
                };
                TopoJSON.exportArcs = function( arcs, bounds, opts ) {
                    var fromZ = null,
                        output = [];
                    if ( opts.presimplify ) {
                        fromZ = TopoJSON.getPresimplifyFunction( bounds.width() )
                    }
                    arcs.forEach2( function( i, n, xx, yy, zz ) {
                        var arc = [],
                            p;
                        for ( var j = i + n; i < j; i++ ) {
                            p = [ xx[ i ], yy[ i ] ];
                            if ( fromZ ) {
                                p.push( fromZ( zz[ i ] ) )
                            }
                            arc.push( p )
                        }
                        output.push( arc.length > 1 ? arc : null )
                    } );
                    return output
                };
                TopoJSON.deltaEncodeArcs = function( arcs ) {
                    arcs.forEach( function( arr ) {
                        var ax, ay, bx, by, p;
                        for ( var i = 0, n = arr.length; i < n; i++ ) {
                            p = arr[ i ];
                            bx = p[ 0 ];
                            by = p[ 1 ];
                            if ( i > 0 ) {
                                p[ 0 ] = bx - ax;
                                p[ 1 ] = by - ay
                            }
                            ax = bx;
                            ay = by
                        }
                    } )
                };
                TopoJSON.calcExportResolution = function( arcs, k ) {
                    var xy = MapShaper.getAvgSegment2( arcs );
                    return [ xy[ 0 ] * k, xy[ 1 ] * k ]
                };
                TopoJSON.calcExportBounds = function( bounds, arcs, opts ) {
                    var unitXY, xmax, ymax;
                    if ( opts.topojson_precision > 0 ) {
                        unitXY = TopoJSON.calcExportResolution( arcs, opts.topojson_precision )
                    } else if ( opts.quantization > 0 ) {
                        unitXY = [ bounds.width() / ( opts.quantization - 1 ), bounds.height() / ( opts.quantization - 1 ) ]
                    } else if ( opts.precision > 0 ) {
                        unitXY = [ opts.precision, opts.precision ]
                    } else {
                        unitXY = TopoJSON.calcExportResolution( arcs, .02 )
                    }
                    xmax = Math.ceil( bounds.width() / unitXY[ 0 ] ) || 0;
                    ymax = Math.ceil( bounds.height() / unitXY[ 1 ] ) || 0;
                    return new Bounds( 0, 0, xmax, ymax )
                };
                TopoJSON.exportProperties = function( geometries, table, opts ) {
                    var properties = MapShaper.exportProperties( table, opts ),
                        ids = MapShaper.exportIds( table, opts );
                    geometries.forEach( function( geom, i ) {
                        if ( properties ) {
                            geom.properties = properties[ i ]
                        }
                        if ( ids ) {
                            geom.id = ids[ i ]
                        }
                    } )
                };
                TopoJSON.exportLayer = function( lyr, arcs, opts ) {
                    var n = MapShaper.getFeatureCount( lyr ),
                        geometries = [];
                    for ( var i = 0; i < n; i++ ) {
                        geometries[ i ] = {
                            type: null
                        }
                    }
                    if ( MapShaper.layerHasGeometry( lyr ) ) {
                        TopoJSON.exportGeometries( geometries, lyr.shapes, arcs, lyr.geometry_type )
                    }
                    if ( lyr.data ) {
                        TopoJSON.exportProperties( geometries, lyr.data, opts )
                    }
                    return {
                        type: "GeometryCollection",
                        geometries: geometries
                    }
                };
                TopoJSON.exportGeometries = function( geometries, shapes, coords, type ) {
                    var exporter = TopoJSON.exporters[ type ];
                    if ( exporter && shapes ) {
                        shapes.forEach( function( shape, i ) {
                            if ( shape && shape.length > 0 ) {
                                geometries[ i ] = exporter( shape, coords )
                            }
                        } )
                    }
                };
                TopoJSON.exportPolygonGeom = function( shape, coords ) {
                    var geom = {};
                    shape = MapShaper.filterEmptyArcs( shape, coords );
                    if ( !shape || shape.length === 0 ) {
                        geom.type = null
                    } else if ( shape.length > 1 ) {
                        geom.arcs = MapShaper.explodePolygon( shape, coords );
                        if ( geom.arcs.length == 1 ) {
                            geom.arcs = geom.arcs[ 0 ];
                            geom.type = "Polygon"
                        } else {
                            geom.type = "MultiPolygon"
                        }
                    } else {
                        geom.arcs = shape;
                        geom.type = "Polygon"
                    }
                    return geom
                };
                TopoJSON.exportLineGeom = function( shape, coords ) {
                    var geom = {};
                    shape = MapShaper.filterEmptyArcs( shape, coords );
                    if ( !shape || shape.length === 0 ) {
                        geom.type = null
                    } else if ( shape.length == 1 ) {
                        geom.type = "LineString";
                        geom.arcs = shape[ 0 ]
                    } else {
                        geom.type = "MultiLineString";
                        geom.arcs = shape
                    }
                    return geom
                };
                TopoJSON.exporters = {
                    polygon: TopoJSON.exportPolygonGeom,
                    polyline: TopoJSON.exportLineGeom,
                    point: GeoJSON.exportPointGeom
                };
                var ShpType = {
                    NULL: 0,
                    POINT: 1,
                    POLYLINE: 3,
                    POLYGON: 5,
                    MULTIPOINT: 8,
                    POINTZ: 11,
                    POLYLINEZ: 13,
                    POLYGONZ: 15,
                    MULTIPOINTZ: 18,
                    POINTM: 21,
                    POLYLINEM: 23,
                    POLYGONM: 25,
                    MULIPOINTM: 28,
                    MULTIPATCH: 31
                };
                ShpType.isPolygonType = function( t ) {
                    return t == 5 || t == 15 || t == 25
                };
                ShpType.isPolylineType = function( t ) {
                    return t == 3 || t == 13 || t == 23
                };
                ShpType.isMultiPartType = function( t ) {
                    return ShpType.isPolygonType( t ) || ShpType.isPolylineType( t )
                };
                ShpType.isMultiPointType = function( t ) {
                    return t == 8 || t == 18 || t == 28
                };
                ShpType.isZType = function( t ) {
                    return utils.contains( [ 11, 13, 15, 18 ], t )
                };
                ShpType.isMType = function( t ) {
                    return ShpType.isZType( t ) || utils.contains( [ 21, 23, 25, 28 ], t )
                };
                ShpType.hasBounds = function( t ) {
                    return ShpType.isMultiPartType( t ) || ShpType.isMultiPointType( t )
                };
                MapShaper.translateShapefileType = function( shpType ) {
                    if ( utils.contains( [ ShpType.POLYGON, ShpType.POLYGONM, ShpType.POLYGONZ ], shpType ) ) {
                        return "polygon"
                    } else if ( utils.contains( [ ShpType.POLYLINE, ShpType.POLYLINEM, ShpType.POLYLINEZ ], shpType ) ) {
                        return "polyline"
                    } else if ( utils.contains( [ ShpType.POINT, ShpType.POINTM, ShpType.POINTZ, ShpType.MULTIPOINT, ShpType.MULTIPOINTM, ShpType.MULTIPOINTZ ], shpType ) ) {
                        return "point"
                    }
                    return null
                };
                MapShaper.isSupportedShapefileType = function( t ) {
                    return utils.contains( [ 0, 1, 3, 5, 8, 11, 13, 15, 18, 21, 23, 25, 28 ], t )
                };
                MapShaper.getShapefileType = function( type ) {
                    return {
                        polygon: ShpType.POLYGON,
                        polyline: ShpType.POLYLINE,
                        point: ShpType.MULTIPOINT
                    }[ type ] || ShpType.NULL
                };
                var NullRecord = function() {
                    return {
                        isNull: true,
                        pointCount: 0,
                        partCount: 0,
                        byteLength: 12
                    }
                };

                function ShpRecordClass( type ) {
                    var hasBounds = ShpType.hasBounds( type ),
                        hasParts = ShpType.isMultiPartType( type ),
                        hasZ = ShpType.isZType( type ),
                        hasM = ShpType.isMType( type ),
                        singlePoint = !hasBounds,
                        mzRangeBytes = singlePoint ? 0 : 16,
                        constructor;
                    if ( type === 0 ) {
                        return NullRecord
                    }
                    constructor = function ShapeRecord( bin, bytes ) {
                        var pos = bin.position();
                        this.id = bin.bigEndian().readUint32();
                        this.type = bin.littleEndian().skipBytes( 4 ).readUint32();
                        if ( this.type === 0 ) {
                            return new NullRecord
                        }
                        if ( bytes > 0 !== true || this.type != type && this.type !== 0 ) {
                            error( "Unable to read a shape -- .shp file may be corrupted" )
                        }
                        this.byteLength = bytes;
                        if ( singlePoint ) {
                            this.pointCount = 1;
                            this.partCount = 1
                        } else {
                            bin.skipBytes( 32 );
                            this.partCount = hasParts ? bin.readUint32() : 1;
                            this.pointCount = bin.readUint32()
                        }
                        this._data = function() {
                            return bin.position( pos )
                        }
                    };
                    var proto = {
                        _xypos: function() {
                            var offs = 12;
                            if ( !singlePoint ) offs += 4;
                            if ( hasBounds ) offs += 32;
                            if ( hasParts ) offs += 4 * this.partCount + 4;
                            return offs
                        },
                        readCoords: function() {
                            if ( this.pointCount === 0 ) return null;
                            var partSizes = this.readPartSizes(),
                                xy = this._data().skipBytes( this._xypos() );
                            return partSizes.map( function( pointCount ) {
                                return xy.readFloat64Array( pointCount * 2 )
                            } )
                        },
                        readXY: function() {
                            if ( this.pointCount === 0 ) return new Float64Array( 0 );
                            return this._data().skipBytes( this._xypos() ).readFloat64Array( this.pointCount * 2 )
                        },
                        readPoints: function() {
                            var xy = this.readXY(),
                                zz = hasZ ? this.readZ() : null,
                                mm = hasM && this.hasM() ? this.readM() : null,
                                points = [],
                                p;
                            for ( var i = 0, n = xy.length / 2; i < n; i++ ) {
                                p = [ xy[ i * 2 ], xy[ i * 2 + 1 ] ];
                                if ( zz ) p.push( zz[ i ] );
                                if ( mm ) p.push( mm[ i ] );
                                points.push( p )
                            }
                            return points
                        },
                        readPartSizes: function() {
                            var sizes = [];
                            var partLen, startId, bin;
                            if ( this.pointCount === 0 ) {} else if ( this.partCount == 1 ) {
                                sizes.push( this.pointCount )
                            } else {
                                startId = 0;
                                bin = this._data().skipBytes( 56 );
                                for ( var i = 0, n = this.partCount; i < n; i++ ) {
                                    partLen = ( i < n - 1 ? bin.readUint32() : this.pointCount ) - startId;
                                    if ( partLen > 0 ) {
                                        sizes.push( partLen );
                                        startId += partLen
                                    }
                                }
                            }
                            return sizes
                        }
                    };
                    var singlePointProto = {
                        read: function() {
                            var n = 2;
                            if ( hasZ ) n++;
                            if ( this.hasM() ) n++;
                            return this._data().skipBytes( 12 ).readFloat64Array( n )
                        },
                        stream: function( sink ) {
                            var src = this._data().skipBytes( 12 );
                            sink.addPoint( src.readFloat64(), src.readFloat64() );
                            sink.endPath()
                        }
                    };
                    var multiCoordProto = {
                        readBounds: function() {
                            return this._data().skipBytes( 12 ).readFloat64Array( 4 )
                        },
                        stream: function( sink ) {
                            var sizes = this.readPartSizes(),
                                xy = this.readXY(),
                                i = 0,
                                j = 0,
                                n;
                            while ( i < sizes.length ) {
                                n = sizes[ i ];
                                while ( n-- > 0 ) {
                                    sink.addPoint( xy[ j++ ], xy[ j++ ] )
                                }
                                sink.endPath();
                                i++
                            }
                            if ( xy.length != j ) error( "Counting error" )
                        },
                        read: function() {
                            var parts = [],
                                sizes = this.readPartSizes(),
                                points = this.readPoints();
                            for ( var i = 0, n = sizes.length - 1; i < n; i++ ) {
                                parts.push( points.splice( 0, sizes[ i ] ) )
                            }
                            parts.push( points );
                            return parts
                        }
                    };
                    var mProto = {
                        _mpos: function() {
                            var pos = this._xypos() + this.pointCount * 16;
                            if ( hasZ ) {
                                pos += this.pointCount * 8 + mzRangeBytes
                            }
                            return pos
                        },
                        readMBounds: function() {
                            return this.hasM() ? this._data().skipBytes( this._mpos() ).readFloat64Array( 2 ) : null
                        },
                        readM: function() {
                            return this.hasM() ? this._data().skipBytes( this._mpos() + mzRangeBytes ).readFloat64Array( this.pointCount ) : null
                        },
                        hasM: function() {
                            var bytesWithoutM = this._mpos(),
                                bytesWithM = bytesWithoutM + this.pointCount * 8 + mzRangeBytes;
                            if ( this.byteLength == bytesWithoutM ) {
                                return false
                            } else if ( this.byteLength == bytesWithM ) {
                                return true
                            } else {
                                error( "#hasM() Counting error" )
                            }
                        }
                    };
                    var zProto = {
                        _zpos: function() {
                            return this._xypos() + this.pointCount * 16
                        },
                        readZBounds: function() {
                            return this._data().skipBytes( this._zpos() ).readFloat64Array( 2 )
                        },
                        readZ: function() {
                            return this._data().skipBytes( this._zpos() + mzRangeBytes ).readFloat64Array( this.pointCount )
                        }
                    };
                    if ( singlePoint ) {
                        utils.extend( proto, singlePointProto )
                    } else {
                        utils.extend( proto, multiCoordProto )
                    }
                    if ( hasZ ) utils.extend( proto, zProto );
                    if ( hasM ) utils.extend( proto, mProto );
                    constructor.prototype = proto;
                    proto.constructor = constructor;
                    return constructor
                }
                utils.replaceFileExtension = function( path, ext ) {
                    var info = utils.parseLocalPath( path );
                    return info.pathbase + "." + ext
                };
                utils.getPathSep = function( path ) {
                    return path.indexOf( "/" ) == -1 && path.indexOf( "\\" ) != -1 ? "\\" : "/"
                };
                utils.parseLocalPath = function( path ) {
                    var obj = {},
                        sep = utils.getPathSep( path ),
                        parts = path.split( sep ),
                        i;
                    if ( parts.length == 1 ) {
                        obj.filename = parts[ 0 ];
                        obj.directory = ""
                    } else {
                        obj.filename = parts.pop();
                        obj.directory = parts.join( sep )
                    }
                    i = obj.filename.lastIndexOf( "." );
                    if ( i > -1 ) {
                        obj.extension = obj.filename.substr( i + 1 );
                        obj.basename = obj.filename.substr( 0, i );
                        obj.pathbase = path.substr( 0, path.lastIndexOf( "." ) )
                    } else {
                        obj.extension = "";
                        obj.basename = obj.filename;
                        obj.pathbase = path
                    }
                    return obj
                };
                utils.getFileBase = function( path ) {
                    return utils.parseLocalPath( path ).basename
                };
                utils.getFileExtension = function( path ) {
                    return utils.parseLocalPath( path ).extension
                };
                utils.getPathBase = function( path ) {
                    return utils.parseLocalPath( path ).pathbase
                };
                utils.getCommonFileBase = function( names ) {
                    return names.reduce( function( memo, name, i ) {
                        if ( i === 0 ) {
                            memo = utils.getFileBase( name )
                        } else {
                            memo = utils.mergeNames( memo, name )
                        }
                        return memo
                    }, "" )
                };
                utils.getOutputFileBase = function( dataset ) {
                    var inputFiles = dataset.info && dataset.info.input_files;
                    return inputFiles && utils.getCommonFileBase( inputFiles ) || "output"
                };
                MapShaper.guessInputFileType = function( file ) {
                    var ext = utils.getFileExtension( file || "" ).toLowerCase(),
                        type = null;
                    if ( ext == "dbf" || ext == "shp" || ext == "prj" ) {
                        type = ext
                    } else if ( /json$/.test( ext ) ) {
                        type = "json"
                    }
                    return type
                };
                MapShaper.guessInputContentType = function( content ) {
                    var type = null;
                    if ( utils.isString( content ) ) {
                        type = MapShaper.stringLooksLikeJSON( content ) ? "json" : "text"
                    } else if ( utils.isObject( content ) && content.type || utils.isArray( content ) ) {
                        type = "json"
                    }
                    return type
                };
                MapShaper.guessInputType = function( file, content ) {
                    return MapShaper.guessInputFileType( file ) || MapShaper.guessInputContentType( content )
                };
                MapShaper.stringLooksLikeJSON = function( str ) {
                    return /^\s*[{[]/.test( String( str ) )
                };
                MapShaper.couldBeDsvFile = function( name ) {
                    var ext = utils.getFileExtension( name ).toLowerCase();
                    return /csv|tsv|txt$/.test( ext )
                };
                MapShaper.inferOutputFormat = function( file, inputFormat ) {
                    var ext = utils.getFileExtension( file ).toLowerCase(),
                        format = null;
                    if ( ext == "shp" ) {
                        format = "shapefile"
                    } else if ( ext == "dbf" ) {
                        format = "dbf"
                    } else if ( ext == "svg" ) {
                        format = "svg"
                    } else if ( /json$/.test( ext ) ) {
                        format = "geojson";
                        if ( ext == "topojson" || inputFormat == "topojson" && ext != "geojson" ) {
                            format = "topojson"
                        } else if ( ext == "json" && inputFormat == "json" ) {
                            format = "json"
                        }
                    } else if ( MapShaper.couldBeDsvFile( file ) ) {
                        format = "dsv"
                    } else if ( inputFormat ) {
                        format = inputFormat
                    }
                    return format
                };
                MapShaper.isZipFile = function( file ) {
                    return /\.zip$/i.test( file )
                };
                MapShaper.isSupportedOutputFormat = function( fmt ) {
                    var types = [ "geojson", "topojson", "json", "dsv", "dbf", "shapefile", "svg" ];
                    return types.indexOf( fmt ) > -1
                };
                MapShaper.getFormatName = function( fmt ) {
                    return {
                        geojson: "GeoJSON",
                        topojson: "TopoJSON",
                        json: "JSON records",
                        dsv: "CSV",
                        dbf: "DBF",
                        shapefile: "Shapefile",
                        svg: "SVG"
                    }[ fmt ] || ""
                };
                MapShaper.isBinaryFile = function( path ) {
                    var ext = utils.getFileExtension( path ).toLowerCase();
                    return ext == "shp" || ext == "dbf" || ext == "zip"
                };
                MapShaper.filenameIsUnsupportedOutputType = function( file ) {
                    var rxp = /\.(shx|prj|xls|xlsx|gdb|sbn|sbx|xml|kml)$/i;
                    return rxp.test( file )
                };
                var cli = {};
                cli.isFile = function( path ) {
                    var ss = cli.statSync( path );
                    return ss && ss.isFile() || false
                };
                cli.fileSize = function( path ) {
                    var ss = cli.statSync( path );
                    return ss && ss.size || 0
                };
                cli.isDirectory = function( path ) {
                    var ss = cli.statSync( path );
                    return ss && ss.isDirectory() || false
                };
                cli.readFile = function( fname, encoding ) {
                    var lib = require( fname == "/dev/stdin" ? "rw" : "fs" );
                    var content = lib.readFileSync( fname );
                    if ( encoding ) {
                        content = MapShaper.decodeString( content, encoding )
                    }
                    return content
                };
                cli.writeFile = function( path, content ) {
                    if ( content instanceof ArrayBuffer ) {
                        content = cli.convertArrayBuffer( content )
                    }
                    require( "rw" ).writeFileSync( path, content )
                };
                cli.convertArrayBuffer = function( buf ) {
                    var src = new Uint8Array( buf ),
                        dest = new Buffer( src.length );
                    for ( var i = 0, n = src.length; i < n; i++ ) {
                        dest[ i ] = src[ i ]
                    }
                    return dest
                };
                cli.expandFileName = function( name ) {
                    if ( name.indexOf( "*" ) == -1 ) return [ name ];
                    var path = utils.parseLocalPath( name ),
                        dir = path.directory || ".",
                        listing = require( "fs" ).readdirSync( dir ),
                        rxp = utils.wildcardToRegExp( path.filename );
                    return listing.reduce( function( memo, item ) {
                        var path = require( "path" ).join( dir, item );
                        if ( rxp.test( item ) && cli.isFile( path ) ) {
                            memo.push( path )
                        }
                        return memo
                    }, [] )
                };
                cli.validateInputFiles = function( files ) {
                    files = files.reduce( function( memo, name ) {
                        return memo.concat( cli.expandFileName( name ) )
                    }, [] );
                    files.forEach( cli.checkFileExists );
                    return files
                };
                cli.validateOutputDir = function( name ) {
                    if ( !cli.isDirectory( name ) ) {
                        error( "Output directory not found:", name )
                    }
                };
                cli.checkFileExists = function( path ) {
                    if ( !cli.isFile( path ) && path != "/dev/stdin" ) {
                        stop( "File not found (" + path + ")" )
                    }
                };
                cli.statSync = function( fpath ) {
                    var obj = null;
                    try {
                        obj = require( "fs" ).statSync( fpath )
                    } catch ( e ) {}
                    return obj
                };

                function ShpReader( src ) {
                    if ( this instanceof ShpReader === false ) {
                        return new ShpReader( src )
                    }
                    var file = utils.isString( src ) ? new FileBytes( src ) : new BufferBytes( src );
                    var header = parseHeader( file.readBytes( 100, 0 ) );
                    var fileSize = file.size();
                    var RecordClass = new ShpRecordClass( header.type );
                    var recordOffs, i, skippedBytes;
                    reset();
                    this.header = function() {
                        return header
                    };
                    this.forEachShape = function( callback ) {
                        var shape = this.nextShape();
                        while ( shape ) {
                            callback( shape );
                            shape = this.nextShape()
                        }
                    };
                    this.nextShape = function() {
                        var shape = readShapeAtOffset( recordOffs, i ),
                            offs2, skipped;
                        if ( !shape && recordOffs + 12 <= fileSize ) {
                            shape = huntForNextShape( recordOffs + 4, i )
                        }
                        if ( shape ) {
                            recordOffs += shape.byteLength;
                            if ( shape.id < i ) {
                                message( "[shp] Record " + shape.id + " appears more than once -- possible file corruption." );
                                return this.nextShape()
                            }
                            i++
                        } else {
                            if ( skippedBytes > 0 ) {
                                message( "[shp] Skipped " + skippedBytes + " bytes in .shp file -- possible data loss." )
                            }
                            file.close();
                            reset()
                        }
                        return shape
                    };

                    function reset() {
                        recordOffs = 100;
                        skippedBytes = 0;
                        i = 1
                    }

                    function parseHeader( bin ) {
                        var header = {
                            signature: bin.bigEndian().readUint32(),
                            byteLength: bin.skipBytes( 20 ).readUint32() * 2,
                            version: bin.littleEndian().readUint32(),
                            type: bin.readUint32(),
                            bounds: bin.readFloat64Array( 4 ),
                            zbounds: bin.readFloat64Array( 2 ),
                            mbounds: bin.readFloat64Array( 2 )
                        };
                        if ( header.signature != 9994 ) {
                            error( "Not a valid .shp file" )
                        }
                        if ( !MapShaper.isSupportedShapefileType( header.type ) ) {
                            error( "Unsupported .shp type:", header.type )
                        }
                        if ( header.byteLength != file.size() ) {
                            error( "File size of .shp doesn't match size in header" )
                        }
                        return header
                    }

                    function readShapeAtOffset( recordOffs, i ) {
                        var shape = null,
                            recordSize, recordType, recordId, goodId, goodSize, goodType, bin;
                        if ( recordOffs + 12 <= fileSize ) {
                            bin = file.readBytes( 12, recordOffs );
                            recordId = bin.bigEndian().readUint32();
                            recordSize = bin.readUint32() * 2 + 8;
                            recordType = bin.littleEndian().readUint32();
                            goodId = recordId == i;
                            goodSize = recordOffs + recordSize <= fileSize && recordSize >= 12;
                            goodType = recordType === 0 || recordType == header.type;
                            if ( goodSize && goodType ) {
                                bin = file.readBytes( recordSize, recordOffs );
                                shape = new RecordClass( bin, recordSize )
                            }
                        }
                        return shape
                    }

                    function huntForNextShape( start, id ) {
                        var offset = start,
                            shape = null,
                            bin, recordId, recordType;
                        while ( offset + 12 <= fileSize ) {
                            bin = file.readBytes( 12, offset );
                            recordId = bin.bigEndian().readUint32();
                            recordType = bin.littleEndian().skipBytes( 4 ).readUint32();
                            if ( recordId == id && ( recordType == header.type || recordType === 0 ) ) {
                                shape = readShapeAtOffset( offset, id );
                                break
                            }
                            offset += 4
                        }
                        skippedBytes += shape ? offset - start : fileSize - start;
                        return shape
                    }
                }
                ShpReader.prototype.type = function() {
                    return this.header().type
                };
                ShpReader.prototype.getCounts = function() {
                    var counts = {
                        nullCount: 0,
                        partCount: 0,
                        shapeCount: 0,
                        pointCount: 0
                    };
                    this.forEachShape( function( shp ) {
                        if ( shp.isNull ) counts.nullCount++;
                        counts.pointCount += shp.pointCount;
                        counts.partCount += shp.partCount;
                        counts.shapeCount++
                    } );
                    return counts
                };

                function BufferBytes( buf ) {
                    var bin = new BinArray( buf ),
                        bufSize = bin.size();
                    this.readBytes = function( len, offset ) {
                        if ( bufSize < offset + len ) error( "Out-of-range error" );
                        bin.position( offset );
                        return bin
                    };
                    this.size = function() {
                        return bufSize
                    };
                    this.close = function() {}
                }

                function FileBytes( path ) {
                    var DEFAULT_BUF_SIZE = 16777215,
                        fs = require( "fs" ),
                        fileSize = cli.fileSize( path ),
                        cacheOffs = 0,
                        cache, fd;
                    this.readBytes = function( len, start ) {
                        if ( fileSize < start + len ) error( "Out-of-range error" );
                        if ( !cache || start < cacheOffs || start + len > cacheOffs + cache.size() ) {
                            updateCache( len, start )
                        }
                        cache.position( start - cacheOffs );
                        return cache
                    };
                    this.size = function() {
                        return fileSize
                    };
                    this.close = function() {
                        if ( fd ) {
                            fs.closeSync( fd );
                            fd = null;
                            cache = null;
                            cacheOffs = 0
                        }
                    };

                    function updateCache( len, start ) {
                        var headroom = fileSize - start,
                            bufSize = Math.min( headroom, Math.max( DEFAULT_BUF_SIZE, len ) ),
                            buf = new Buffer( bufSize ),
                            bytesRead;
                        if ( !fd ) fd = fs.openSync( path, "r" );
                        bytesRead = fs.readSync( fd, buf, 0, bufSize, start );
                        if ( bytesRead < bufSize ) error( "Error reading file" );
                        cacheOffs = start;
                        cache = new BinArray( buf )
                    }
                }
                MapShaper.importShp = function( src, opts ) {
                    var reader = new ShpReader( src ),
                        shpType = reader.type(),
                        type = MapShaper.translateShapefileType( shpType ),
                        importOpts = utils.defaults( {
                            type: type,
                            reserved_points: Math.round( reader.header().byteLength / 16 )
                        }, opts ),
                        importer = new PathImporter( importOpts );
                    if ( !MapShaper.isSupportedShapefileType( shpType ) ) {
                        stop( "Unsupported Shapefile type:", shpType )
                    }
                    if ( ShpType.isZType( shpType ) ) {
                        message( "Warning: Shapefile Z data will be lost." )
                    } else if ( ShpType.isMType( shpType ) ) {
                        message( "Warning: Shapefile M data will be lost." )
                    }
                    reader.forEachShape( function( shp ) {
                        importer.startShape();
                        if ( shp.isNull ) {} else if ( type == "point" ) {
                            importer.importPoints( shp.readPoints() )
                        } else {
                            shp.stream( importer )
                        }
                    } );
                    return importer.done()
                };
                MapShaper.exportShapefile = function( dataset, opts ) {
                    return dataset.layers.reduce( function( files, lyr ) {
                        var prj = MapShaper.exportPrjFile( lyr, dataset );
                        files = files.concat( MapShaper.exportShpAndShxFiles( lyr, dataset, opts ) );
                        files = files.concat( MapShaper.exportDbfFile( lyr, dataset, opts ) );
                        if ( prj ) files.push( prj );
                        return files
                    }, [] )
                };
                MapShaper.exportPrjFile = function( lyr, dataset ) {
                    var outputPrj = dataset.info && !dataset.info.crs && dataset.info.input_prj;
                    return outputPrj ? {
                        content: outputPrj,
                        filename: lyr.name + ".prj"
                    } : null
                };
                MapShaper.exportShpAndShxFiles = function( layer, dataset, opts ) {
                    var geomType = layer.geometry_type;
                    var shpType = MapShaper.getShapefileType( geomType );
                    var fileBytes = 100;
                    var bounds = new Bounds;
                    var shapes = layer.shapes || utils.initializeArray( new Array( MapShaper.getFeatureCount( layer ) ), null );
                    var shapeBuffers = shapes.map( function( shape, i ) {
                        var pathData = MapShaper.exportPathData( shape, dataset.arcs, geomType );
                        var rec = MapShaper.exportShpRecord( pathData, i + 1, shpType );
                        fileBytes += rec.buffer.byteLength;
                        if ( rec.bounds ) bounds.mergeBounds( rec.bounds );
                        return rec.buffer
                    } );
                    var shpBin = new BinArray( fileBytes, false ).writeInt32( 9994 ).skipBytes( 5 * 4 ).writeInt32( fileBytes / 2 ).littleEndian().writeInt32( 1e3 ).writeInt32( shpType );
                    if ( bounds.hasBounds() ) {
                        shpBin.writeFloat64( bounds.xmin || 0 ).writeFloat64( bounds.ymin || 0 ).writeFloat64( bounds.xmax || 0 ).writeFloat64( bounds.ymax || 0 )
                    } else {
                        shpBin.skipBytes( 4 * 8 )
                    }
                    shpBin.skipBytes( 4 * 8 );
                    var shxBytes = 100 + shapeBuffers.length * 8;
                    var shxBin = new BinArray( shxBytes, false ).writeBuffer( shpBin.buffer(), 100 ).position( 24 ).bigEndian().writeInt32( shxBytes / 2 ).position( 100 );
                    shapeBuffers.forEach( function( buf, i ) {
                        var shpOff = shpBin.position() / 2,
                            shpSize = ( buf.byteLength - 8 ) / 2;
                        shxBin.writeInt32( shpOff );
                        shxBin.writeInt32( shpSize );
                        shpBin.writeBuffer( buf )
                    } );
                    return [ {
                        content: shpBin.buffer(),
                        filename: layer.name + ".shp"
                    }, {
                        content: shxBin.buffer(),
                        filename: layer.name + ".shx"
                    } ]
                };
                MapShaper.exportShpRecord = function( data, id, shpType ) {
                    var bounds = null,
                        bin = null;
                    if ( data.pointCount > 0 ) {
                        var multiPart = ShpType.isMultiPartType( shpType ),
                            partIndexIdx = 52,
                            pointsIdx = multiPart ? partIndexIdx + 4 * data.pathCount : 48,
                            recordBytes = pointsIdx + 16 * data.pointCount,
                            pointCount = 0;
                        bounds = data.bounds;
                        bin = new BinArray( recordBytes, false ).writeInt32( id ).writeInt32( ( recordBytes - 8 ) / 2 ).littleEndian().writeInt32( shpType ).writeFloat64( bounds.xmin ).writeFloat64( bounds.ymin ).writeFloat64( bounds.xmax ).writeFloat64( bounds.ymax );
                        if ( multiPart ) {
                            bin.writeInt32( data.pathCount )
                        } else {
                            if ( data.pathData.length > 1 ) {
                                error( "[exportShpRecord()] Tried to export multiple paths as type:", shpType )
                            }
                        }
                        bin.writeInt32( data.pointCount );
                        data.pathData.forEach( function( path, i ) {
                            if ( multiPart ) {
                                bin.position( partIndexIdx + i * 4 ).writeInt32( pointCount )
                            }
                            bin.position( pointsIdx + pointCount * 16 );
                            var points = path.points;
                            for ( var j = 0, len = points.length; j < len; j++ ) {
                                bin.writeFloat64( points[ j ][ 0 ] );
                                bin.writeFloat64( points[ j ][ 1 ] )
                            }
                            pointCount += j
                        } );
                        if ( data.pointCount != pointCount ) error( "Shp record point count mismatch; pointCount:", pointCount, "data.pointCount:", data.pointCount )
                    } else {
                        bin = new BinArray( 12, false ).writeInt32( id ).writeInt32( 2 ).littleEndian().writeInt32( 0 )
                    }
                    return {
                        bounds: bounds,
                        buffer: bin.buffer()
                    }
                };
                MapShaper.importDbfTable = function( buf, o ) {
                    var opts = o || {};
                    return new ShapefileTable( buf, opts.encoding )
                };

                function ShapefileTable( buf, encoding ) {
                    var reader = new DbfReader( buf, encoding ),
                        altered = false,
                        table;

                    function getTable() {
                        if ( !table ) {
                            table = new DataTable( reader.readRows() );
                            reader = null;
                            buf = null
                        }
                        return table
                    }
                    this.exportAsDbf = function( encoding ) {
                        return reader && !altered ? reader.getBuffer() : getTable().exportAsDbf( encoding )
                    };
                    this.getRecordAt = function( i ) {
                        return reader ? reader.readRow( i ) : table.getRecordAt( i )
                    };
                    this.deleteField = function( f ) {
                        if ( table ) {
                            table.deleteField( f )
                        } else {
                            altered = true;
                            reader.deleteField( f )
                        }
                    };
                    this.getRecords = function() {
                        return getTable().getRecords()
                    };
                    this.getFields = function() {
                        return reader ? reader.getFields() : table.getFields()
                    };
                    this.size = function() {
                        return reader ? reader.size() : table.size()
                    }
                }
                utils.extend( ShapefileTable.prototype, dataTableProto );
                MapShaper.exportDbf = function( dataset, opts ) {
                    return dataset.layers.reduce( function( files, lyr ) {
                        if ( lyr.data ) {
                            files = files.concat( MapShaper.exportDbfFile( lyr, dataset, opts ) )
                        }
                        return files
                    }, [] )
                };
                MapShaper.exportDbfFile = function( lyr, dataset, opts ) {
                    var data = lyr.data,
                        buf;
                    if ( !data || opts.cut_table || opts.drop_table ) {
                        data = new DataTable( lyr.shapes ? lyr.shapes.length : 0 )
                    }
                    if ( data.getFields().length === 0 ) {
                        data.addIdField()
                    }
                    buf = data.exportAsDbf( opts.encoding || "utf8" );
                    if ( utils.isInteger( opts.ldid ) ) {
                        new Uint8Array( buf )[ 29 ] = opts.ldid
                    }
                    return [ {
                        content: buf,
                        filename: lyr.name + ".dbf"
                    } ]
                };
                api.svgStyle = function( lyr, dataset, opts ) {
                    var keys = Object.keys( opts ),
                        svgFields = MapShaper.getStyleFields( keys, MapShaper.svgStyles, MapShaper.invalidSvgTypes[ lyr.geometry_type ] );
                    svgFields.forEach( function( f ) {
                        var val = opts[ f ];
                        var literal = null;
                        var records, func;
                        var type = MapShaper.svgStyleTypes[ f ];
                        if ( !lyr.data ) {
                            MapShaper.initDataTable( lyr )
                        }
                        if ( type == "number" && MapShaper.isSvgNumber( val ) ) {
                            literal = Number( val )
                        } else if ( type == "color" && MapShaper.isSvgColor( val, lyr.data.getFields() ) ) {
                            literal = val
                        } else if ( type == "classname" && MapShaper.isSvgClassName( val, lyr.data.getFields() ) ) {
                            literal = val
                        }
                        if ( literal === null ) {
                            func = MapShaper.compileValueExpression( val, lyr, dataset.arcs )
                        }
                        records = lyr.data.getRecords();
                        records.forEach( function( rec, i ) {
                            rec[ f ] = func ? func( i ) : literal
                        } )
                    } )
                };
                MapShaper.isSvgClassName = function( str, fields ) {
                    str = str.trim();
                    return ( !fields || fields.indexOf( str ) == -1 ) && /^( ?[_a-z][-_a-z0-9]*\b)+$/i.test( str )
                };
                MapShaper.isSvgNumber = function( o ) {
                    return utils.isFiniteNumber( o ) || utils.isString( o ) && /^-?[.0-9]+$/.test( o )
                };
                MapShaper.isSvgColor = function( str, fields ) {
                    str = str.trim();
                    return ( !fields || fields.indexOf( str ) == -1 ) && /^[a-z]+$/i.test( str ) || /^#[0-9a-f]+$/i.test( str ) || /^rgba?\([0-9,. ]+\)$/.test( str )
                };
                MapShaper.getStyleFields = function( fields, index, blacklist ) {
                    return fields.reduce( function( memo, f ) {
                        if ( f in index ) {
                            if ( !blacklist || blacklist.indexOf( f ) == -1 ) {
                                memo.push( f )
                            }
                        }
                        return memo
                    }, [] )
                };
                MapShaper.getSvgStyleFields = function( lyr ) {
                    var fields = lyr.data ? lyr.data.getFields() : [];
                    return MapShaper.getStyleFields( fields, MapShaper.svgStyles, MapShaper.invalidSvgTypes[ lyr.geometry_type ] )
                };
                MapShaper.layerHasSvgDisplayStyle = function( lyr ) {
                    var fields = MapShaper.getSvgStyleFields( lyr );
                    return utils.difference( fields, [ "opacity", "class" ] ).length > 0
                };
                MapShaper.invalidSvgTypes = {
                    polygon: [ "r" ],
                    polyline: [ "r", "fill" ]
                };
                MapShaper.svgStyles = {
                    class: "class",
                    opacity: "opacity",
                    r: "radius",
                    fill: "fillColor",
                    stroke: "strokeColor",
                    stroke_width: "strokeWidth"
                };
                MapShaper.svgStyleTypes = {
                    class: "classname",
                    opacity: "number",
                    r: "number",
                    fill: "color",
                    stroke: "color",
                    stroke_width: "number"
                };
                var SVG = {};
                SVG.importGeoJSONFeatures = function( features ) {
                    return features.map( function( obj, i ) {
                        var geom = obj.type == "Feature" ? obj.geometry : obj;
                        var geomType = geom && geom.type;
                        var svgObj;
                        if ( !geomType ) {
                            return {
                                tag: "g"
                            }
                        }
                        svgObj = SVG.geojsonImporters[ geomType ]( geom.coordinates );
                        if ( obj.properties ) {
                            SVG.applyStyleAttributes( svgObj, geomType, obj.properties )
                        }
                        if ( "id" in obj ) {
                            if ( !svgObj.properties ) {
                                svgObj.properties = {}
                            }
                            svgObj.properties.id = obj.id
                        }
                        return svgObj
                    } )
                };
                SVG.stringify = function( obj ) {
                    var svg = "<" + obj.tag;
                    if ( obj.properties ) {
                        svg += SVG.stringifyProperties( obj.properties )
                    }
                    if ( obj.children ) {
                        svg += ">\n";
                        svg += obj.children.map( SVG.stringify ).join( "\n" );
                        svg += "\n</" + obj.tag + ">"
                    } else {
                        svg += "/>"
                    }
                    return svg
                };
                SVG.stringEscape = function() {
                    var rxp = /[&<>"']/g,
                        map = {
                            "&": "&amp;",
                            "<": "&lt;",
                            ">": "&gt;",
                            '"': "&quot;",
                            "'": "&apos;"
                        };
                    return function( s ) {
                        return String( s ).replace( rxp, function( s ) {
                            return map[ s ]
                        } )
                    }
                }();
                SVG.stringifyProperties = function( o ) {
                    return Object.keys( o ).reduce( function( memo, key, i ) {
                        var val = o[ key ],
                            strval = utils.isString( val ) ? val : JSON.stringify( val );
                        return memo + " " + key + '="' + SVG.stringEscape( strval ) + '"'
                    }, "" )
                };
                SVG.applyStyleAttributes = function( svgObj, geomType, rec ) {
                    var properties = svgObj.properties;
                    var invalidStyles = MapShaper.invalidSvgTypes[ GeoJSON.translateGeoJSONType( geomType ) ];
                    var fields = MapShaper.getStyleFields( Object.keys( rec ), MapShaper.svgStyles, invalidStyles );
                    var k;
                    for ( var i = 0, n = fields.length; i < n; i++ ) {
                        k = fields[ i ];
                        SVG.setAttribute( svgObj, k.replace( "_", "-" ), rec[ k ] )
                    }
                };
                SVG.setAttribute = function( obj, k, v ) {
                    var children, child;
                    if ( ( k == "r" || k == "class" ) && obj.children ) {
                        children = obj.children;
                        for ( var i = 0; i < children.length; i++ ) {
                            child = children[ i ];
                            if ( !child.properties ) child.properties = {};
                            child.properties[ k ] = v
                        }
                    } else {
                        if ( !obj.properties ) obj.properties = {};
                        obj.properties[ k ] = v
                    }
                };
                SVG.importMultiGeometry = function( coords, importer ) {
                    var o = {
                        tag: "g",
                        children: []
                    };
                    for ( var i = 0; i < coords.length; i++ ) {
                        o.children.push( importer( coords[ i ] ) )
                    }
                    return o
                };
                SVG.mapVertex = function( p ) {
                    return p[ 0 ] + " " + -p[ 1 ]
                };
                SVG.importLineString = function( coords ) {
                    var d = "M " + coords.map( SVG.mapVertex ).join( " " );
                    return {
                        tag: "path",
                        properties: {
                            d: d
                        }
                    }
                };
                SVG.importPoint = function( p ) {
                    return {
                        tag: "circle",
                        properties: {
                            cx: p[ 0 ],
                            cy: -p[ 1 ]
                        }
                    }
                };
                SVG.importPolygon = function( coords ) {
                    var d, o;
                    for ( var i = 0; i < coords.length; i++ ) {
                        d = o ? o.properties.d + " " : "";
                        o = SVG.importLineString( coords[ i ] );
                        o.properties.d = d + o.properties.d + " Z"
                    }
                    return o
                };
                SVG.geojsonImporters = {
                    Point: SVG.importPoint,
                    Polygon: SVG.importPolygon,
                    LineString: SVG.importLineString,
                    MultiPoint: function( coords ) {
                        return SVG.importMultiGeometry( coords, SVG.importPoint )
                    },
                    MultiLineString: function( coords ) {
                        return SVG.importMultiGeometry( coords, SVG.importLineString )
                    },
                    MultiPolygon: function( coords ) {
                        return SVG.importMultiGeometry( coords, SVG.importPolygon )
                    }
                };
                MapShaper.exportSVG = function( dataset, opts ) {
                    var template = '<?xml version="1.0"?>\n<svg xmlns="http://www.w3.org/2000/svg" ' + 'version="1.2" baseProfile="tiny" width="%d" height="%d" viewBox="%s %s %s %s" stroke-linecap="round" stroke-linejoin="round">\n%s\n</svg>';
                    var b, svg;
                    if ( opts.final ) {
                        if ( dataset.arcs ) dataset.arcs.flatten()
                    } else {
                        dataset = MapShaper.copyDataset( dataset )
                    }
                    b = MapShaper.transformCoordsForSVG( dataset, opts );
                    svg = dataset.layers.map( function( lyr ) {
                        return MapShaper.exportLayerAsSVG( lyr, dataset, opts )
                    } ).join( "\n" );
                    svg = utils.format( template, b.width(), b.height(), 0, 0, b.width(), b.height(), svg );
                    return [ {
                        content: svg,
                        filename: opts.output_file || utils.getOutputFileBase( dataset ) + ".svg"
                    } ]
                };
                MapShaper.transformCoordsForSVG = function( dataset, opts ) {
                    var width = opts.width > 0 ? opts.width : 800;
                    var margin = opts.margin >= 0 ? opts.margin : 1;
                    var bounds = MapShaper.getDatasetBounds( dataset );
                    var precision = opts.precision || 1e-4;
                    var height, bounds2, fwd;
                    if ( opts.svg_scale > 0 ) {
                        width = bounds.width() / opts.svg_scale;
                        margin = 0
                    }
                    MapShaper.padViewportBoundsForSVG( bounds, width, margin );
                    height = Math.ceil( width * bounds.height() / bounds.width() );
                    bounds2 = new Bounds( 0, -height, width, 0 );
                    fwd = bounds.getTransform( bounds2 );
                    MapShaper.transformPoints( dataset, function( x, y ) {
                        return fwd.transform( x, y )
                    } );
                    MapShaper.setCoordinatePrecision( dataset, precision );
                    return bounds2
                };
                MapShaper.padViewportBoundsForSVG = function( bounds, width, marginPx ) {
                    var bw = bounds.width() || bounds.height() || 1;
                    var marg;
                    if ( marginPx >= 0 === false ) {
                        marginPx = 1
                    }
                    marg = bw / ( width - marginPx * 2 ) * marginPx;
                    bounds.padBounds( marg, marg, marg, marg )
                };
                MapShaper.exportLayerAsSVG = function( lyr, dataset, opts ) {
                    var geojson = MapShaper.exportGeoJSONCollection( lyr, dataset, opts );
                    var features = geojson.features || geojson.geometries || ( geojson.type ? [ geojson ] : [] );
                    var symbols = SVG.importGeoJSONFeatures( features );
                    var layerObj = {
                        tag: "g",
                        children: symbols,
                        properties: {
                            id: lyr.name
                        }
                    };
                    if ( lyr.geometry_type == "polyline" ) {
                        layerObj.properties.fill = "none";
                        layerObj.properties.stroke = "black";
                        layerObj.properties[ "stroke-width" ] = 1
                    }
                    return SVG.stringify( layerObj )
                };
                MapShaper.roundPoints = function( lyr, round ) {
                    MapShaper.forEachPoint( lyr.shapes, function( p ) {
                        p[ 0 ] = round( p[ 0 ] );
                        p[ 1 ] = round( p[ 1 ] )
                    } )
                };
                MapShaper.setCoordinatePrecision = function( dataset, precision ) {
                    var round = geom.getRoundingFunction( precision );
                    var dissolvePolygon, nodes;
                    MapShaper.transformPoints( dataset, function( x, y ) {
                        return [ round( x ), round( y ) ]
                    } );
                    if ( dataset.arcs ) {
                        nodes = MapShaper.addIntersectionCuts( dataset );
                        dissolvePolygon = MapShaper.getPolygonDissolver( nodes )
                    }
                    dataset.layers.forEach( function( lyr ) {
                        if ( lyr.geometry_type == "polygon" && dissolvePolygon ) {
                            lyr.shapes = lyr.shapes.map( dissolvePolygon )
                        }
                    } );
                    return dataset
                };
                MapShaper.exportDelim = function( dataset, opts ) {
                    var delim = MapShaper.getExportDelimiter( dataset.info, opts ),
                        ext = MapShaper.getDelimFileExtension( delim, opts );
                    return dataset.layers.reduce( function( arr, lyr ) {
                        if ( lyr.data ) {
                            arr.push( {
                                content: MapShaper.exportDelimTable( lyr, delim ),
                                filename: ( lyr.name || "output" ) + "." + ext
                            } )
                        }
                        return arr
                    }, [] )
                };
                MapShaper.exportDelimTable = function( lyr, delim ) {
                    var dsv = require( "d3-dsv" ).dsvFormat( delim );
                    var fields = lyr.data.getFields();
                    var formatRow = MapShaper.getDelimRowFormatter( fields, lyr.data );
                    var records = lyr.data.getRecords();
                    var str = dsv.formatRows( [ fields ] );
                    for ( var i = 0, n = records.length; i < n; i++ ) {
                        str += "\n" + dsv.formatRows( [ formatRow( records[ i ] ) ] )
                    }
                    return str
                };
                MapShaper.getDelimRowFormatter = function( fields, data ) {
                    var formatters = fields.map( function( f ) {
                        var type = MapShaper.getColumnType( f, data );
                        return function( rec ) {
                            if ( type == "object" ) {
                                return JSON.stringify( rec[ f ] )
                            }
                            return rec[ f ]
                        }
                    } );
                    return function( rec ) {
                        var values = [];
                        for ( var i = 0; i < formatters.length; i++ ) {
                            values.push( formatters[ i ]( rec ) )
                        }
                        return values
                    }
                };
                MapShaper.getExportDelimiter = function( info, opts ) {
                    var delim = ",";
                    var outputExt = opts.output_file ? utils.getFileExtension( opts.output_file ) : "";
                    if ( opts.delimiter ) {
                        delim = opts.delimiter
                    } else if ( outputExt == "tsv" ) {
                        delim = "\t"
                    } else if ( outputExt == "csv" ) {
                        delim = ","
                    } else if ( info.input_delimiter ) {
                        delim = info.input_delimiter
                    }
                    return delim
                };
                MapShaper.getDelimFileExtension = function( delim, opts ) {
                    var ext = "txt";
                    if ( opts.output_file ) {
                        ext = utils.getFileExtension( opts.output_file )
                    } else if ( delim == "\t" ) {
                        ext = "tsv"
                    } else if ( delim == "," ) {
                        ext = "csv"
                    }
                    return ext
                };
                MapShaper.importJSONTable = function( arr ) {
                    MapShaper.fixInconsistentFields( arr );
                    return {
                        layers: [ {
                            data: new DataTable( arr )
                        } ],
                        info: {}
                    }
                };
                MapShaper.exportJSON = function( dataset, opts ) {
                    return dataset.layers.reduce( function( arr, lyr ) {
                        if ( lyr.data ) {
                            arr.push( {
                                content: MapShaper.exportJSONTable( lyr ),
                                filename: ( lyr.name || "output" ) + ".json"
                            } )
                        }
                        return arr
                    }, [] )
                };
                MapShaper.exportJSONTable = function( lyr ) {
                    return JSON.stringify( lyr.data.getRecords() )
                };
                MapShaper.exportFileContent = function( dataset, opts ) {
                    var outFmt = opts.format = MapShaper.getOutputFormat( dataset, opts ),
                        exporter = MapShaper.exporters[ outFmt ],
                        files = [];
                    if ( !outFmt ) {
                        error( "[o] Missing output format" )
                    } else if ( !exporter ) {
                        error( "[o] Unknown output format:", outFmt )
                    }
                    dataset = utils.defaults( {
                        layers: dataset.layers.map( function( lyr ) {
                            return utils.extend( {}, lyr )
                        } )
                    }, dataset );
                    if ( opts.output_file && outFmt != "topojson" ) {
                        dataset.layers.forEach( function( lyr ) {
                            lyr.name = utils.getFileBase( opts.output_file )
                        } )
                    }
                    if ( opts.precision && outFmt != "svg" ) {
                        dataset = MapShaper.copyDatasetForExport( dataset );
                        MapShaper.setCoordinatePrecision( dataset, opts.precision )
                    }
                    MapShaper.validateLayerData( dataset.layers );
                    MapShaper.assignUniqueLayerNames( dataset.layers );
                    if ( opts.cut_table ) {
                        files = MapShaper.exportDataTables( dataset.layers, opts ).concat( files )
                    }
                    files = exporter( dataset, opts ).concat( files );
                    if ( opts.bbox_index ) {
                        files.push( MapShaper.createIndexFile( dataset ) )
                    }
                    MapShaper.validateFileNames( files );
                    return files
                };
                MapShaper.exporters = {
                    geojson: MapShaper.exportGeoJSON,
                    topojson: MapShaper.exportTopoJSON,
                    shapefile: MapShaper.exportShapefile,
                    dsv: MapShaper.exportDelim,
                    dbf: MapShaper.exportDbf,
                    json: MapShaper.exportJSON,
                    svg: MapShaper.exportSVG
                };
                MapShaper.getOutputFormat = function( dataset, opts ) {
                    var outFile = opts.output_file || null,
                        inFmt = dataset.info && dataset.info.input_formats && dataset.info.input_formats[ 0 ],
                        outFmt = null;
                    if ( opts.format ) {
                        outFmt = opts.format
                    } else if ( outFile ) {
                        outFmt = MapShaper.inferOutputFormat( outFile, inFmt )
                    } else if ( inFmt ) {
                        outFmt = inFmt
                    }
                    return outFmt
                };
                MapShaper.createIndexFile = function( dataset ) {
                    var index = dataset.layers.map( function( lyr ) {
                        var bounds = MapShaper.getLayerBounds( lyr, dataset.arcs );
                        return {
                            bbox: bounds.toArray(),
                            name: lyr.name
                        }
                    } );
                    return {
                        content: JSON.stringify( index ),
                        filename: "bbox-index.json"
                    }
                };
                MapShaper.validateLayerData = function( layers ) {
                    layers.forEach( function( lyr ) {
                        if ( !lyr.geometry_type ) {
                            if ( lyr.shapes && utils.some( lyr.shapes, function( o ) {
                                    return !!o
                                } ) ) {
                                error( "[export] A layer contains shape records and a null geometry type" )
                            }
                        } else {
                            if ( !utils.contains( [ "polygon", "polyline", "point" ], lyr.geometry_type ) ) {
                                error( "[export] A layer has an invalid geometry type:", lyr.geometry_type )
                            }
                            if ( !lyr.shapes ) {
                                error( "[export] A layer is missing shape data" )
                            }
                        }
                    } )
                };
                MapShaper.validateFileNames = function( files ) {
                    var index = {};
                    files.forEach( function( file, i ) {
                        var filename = file.filename;
                        if ( !filename ) error( "[o] Missing a filename for file" + i );
                        if ( filename in index ) error( "[o] Duplicate filename", filename );
                        index[ filename ] = true
                    } )
                };
                MapShaper.assignUniqueLayerNames = function( layers ) {
                    var names = layers.map( function( lyr ) {
                        return lyr.name || "layer"
                    } );
                    var uniqueNames = MapShaper.uniqifyNames( names );
                    layers.forEach( function( lyr, i ) {
                        lyr.name = uniqueNames[ i ]
                    } )
                };
                MapShaper.assignUniqueLayerNames2 = function( datasets ) {
                    var layers = datasets.reduce( function( memo, dataset ) {
                        return memo.concat( dataset.layers )
                    }, [] );
                    MapShaper.assignUniqueLayerNames( layers )
                };
                MapShaper.assignUniqueFileNames = function( output ) {
                    var names = output.map( function( o ) {
                        return o.filename
                    } );
                    var uniqnames = MapShaper.uniqifyNames( names, MapShaper.formatVersionedFileName );
                    output.forEach( function( o, i ) {
                        o.filename = uniqnames[ i ]
                    } )
                };
                MapShaper.exportDataTables = function( layers, opts ) {
                    var tables = [];
                    layers.forEach( function( lyr ) {
                        if ( lyr.data ) {
                            tables.push( {
                                content: JSON.stringify( lyr.data ),
                                filename: ( lyr.name ? lyr.name + "-" : "" ) + "table.json"
                            } )
                        }
                    } );
                    return tables
                };
                MapShaper.formatVersionedName = function( name, i ) {
                    var suffix = String( i );
                    if ( /[0-9]$/.test( name ) ) {
                        suffix = "-" + suffix
                    }
                    return name + suffix
                };
                MapShaper.formatVersionedFileName = function( filename, i ) {
                    var parts = filename.split( "." );
                    var ext, base;
                    if ( parts.length < 2 ) {
                        return MapShaper.formatVersionedName( filename, i )
                    }
                    ext = parts.pop();
                    base = parts.join( "." );
                    return MapShaper.formatVersionedName( base, i ) + "." + ext
                };
                MapShaper.uniqifyNames = function( names, formatter ) {
                    var counts = utils.countValues( names ),
                        format = formatter || MapShaper.formatVersionedName,
                        blacklist = {};
                    Object.keys( counts ).forEach( function( name ) {
                        if ( counts[ name ] > 1 ) blacklist[ name ] = true
                    } );
                    return names.map( function( name ) {
                        var i = 1,
                            candidate = name,
                            versionedName;
                        while ( candidate in blacklist ) {
                            versionedName = format( name, i );
                            if ( !versionedName || versionedName == candidate ) {
                                throw new Error( "Naming error" )
                            }
                            candidate = versionedName;
                            i++
                        }
                        blacklist[ candidate ] = true;
                        return candidate
                    } )
                };
                api.evaluateEachFeature = function( lyr, arcs, exp, opts ) {
                    var n = MapShaper.getFeatureCount( lyr ),
                        compiled, filter;
                    if ( n > 0 && !lyr.data ) {
                        lyr.data = new DataTable( n )
                    }
                    if ( opts && opts.where ) {
                        filter = MapShaper.compileValueExpression( opts.where, lyr, arcs )
                    }
                    compiled = MapShaper.compileFeatureExpression( exp, lyr, arcs );
                    for ( var i = 0; i < n; i++ ) {
                        if ( !filter || filter( i ) ) {
                            compiled( i )
                        }
                    }
                };
                api.calc = function( lyr, arcs, opts ) {
                    var msg = "[calc] " + opts.expression,
                        result;
                    if ( opts.where ) {
                        lyr = {
                            shapes: lyr.shapes,
                            data: lyr.data
                        };
                        api.filterFeatures( lyr, arcs, {
                            expression: opts.where
                        } );
                        msg += " where " + opts.where
                    }
                    result = MapShaper.evalCalcExpression( lyr, arcs, opts.expression );
                    message( msg + ":  " + result );
                    return result
                };
                MapShaper.evalCalcExpression = function( lyr, arcs, exp ) {
                    var rowNo = 0,
                        colNo = 0,
                        cols = [];
                    var ctx1 = {
                            count: capture,
                            sum: captureNum,
                            average: captureNum,
                            median: captureNum,
                            min: captureNum,
                            max: captureNum
                        },
                        ctx2 = {
                            count: function() {
                                colNo++;
                                return rowNo
                            },
                            sum: function() {
                                return utils.sum( cols[ colNo++ ] )
                            },
                            median: function() {
                                return utils.findMedian( cols[ colNo++ ] )
                            },
                            min: function() {
                                return utils.getArrayBounds( cols[ colNo++ ] ).min
                            },
                            max: function() {
                                return utils.getArrayBounds( cols[ colNo++ ] ).max
                            },
                            average: function() {
                                return utils.mean( cols[ colNo++ ] )
                            }
                        },
                        len = MapShaper.getFeatureCount( lyr ),
                        calc1, calc2;
                    if ( lyr.geometry_type ) {
                        ctx1.width = ctx1.height = noop;
                        ctx2.width = function() {
                            return MapShaper.getLayerBounds( lyr, arcs ).width()
                        };
                        ctx2.height = function() {
                            return MapShaper.getLayerBounds( lyr, arcs ).height()
                        }
                    }
                    calc1 = MapShaper.compileFeatureExpression( exp, lyr, arcs, {
                        context: ctx1
                    } );
                    calc2 = MapShaper.compileFeatureExpression( exp, {
                        data: lyr.data
                    }, null, {
                        returns: true,
                        context: ctx2
                    } );
                    for ( var i = 0; i < len; i++ ) {
                        calc1( i );
                        rowNo++;
                        colNo = 0
                    }
                    return calc2( undefined );

                    function noop() {}

                    function captureNum( val ) {
                        if ( isNaN( val ) && val ) {
                            stop( "Expected a number, received:", val )
                        }
                        capture( val )
                    }

                    function capture( val ) {
                        var col;
                        if ( rowNo === 0 ) {
                            cols[ colNo ] = []
                        }
                        col = cols[ colNo ];
                        if ( col.length != rowNo ) {
                            stop( "Evaluation failed" )
                        }
                        col.push( val );
                        colNo++
                    }
                };
                MapShaper.importContent = function( obj, opts ) {
                    var dataset, content, fileFmt, data;
                    opts = opts || {};
                    if ( obj.json ) {
                        data = obj.json;
                        content = data.content;
                        if ( utils.isString( content ) ) {
                            try {
                                content = JSON.parse( content )
                            } catch ( e ) {
                                stop( "Unable to parse JSON" )
                            }
                        }
                        if ( content.type == "Topology" ) {
                            fileFmt = "topojson";
                            dataset = MapShaper.importTopoJSON( content, opts )
                        } else if ( content.type ) {
                            fileFmt = "geojson";
                            dataset = MapShaper.importGeoJSON( content, opts )
                        } else if ( utils.isArray( content ) ) {
                            fileFmt = "json";
                            dataset = MapShaper.importJSONTable( content, opts )
                        }
                    } else if ( obj.text ) {
                        fileFmt = "dsv";
                        data = obj.text;
                        dataset = MapShaper.importDelim( data.content, opts )
                    } else if ( obj.shp ) {
                        fileFmt = "shapefile";
                        data = obj.shp;
                        dataset = MapShaper.importShapefile( obj, opts )
                    } else if ( obj.dbf ) {
                        fileFmt = "dbf";
                        data = obj.dbf;
                        dataset = MapShaper.importDbf( obj, opts )
                    }
                    if ( !dataset ) {
                        stop( "Missing an expected input type" )
                    }
                    if ( dataset.arcs && !opts.no_topology && fileFmt != "topojson" ) {
                        api.buildTopology( dataset )
                    }
                    if ( fileFmt != "topojson" ) {
                        dataset.layers.forEach( function( lyr ) {
                            MapShaper.setLayerName( lyr, MapShaper.filenameToLayerName( data.filename || "" ) )
                        } )
                    }
                    if ( data.filename ) {
                        dataset.info.input_files = [ data.filename ]
                    }
                    dataset.info.input_formats = [ fileFmt ];
                    return dataset
                };
                MapShaper.importFileContent = function( content, filename, opts ) {
                    var type = MapShaper.guessInputType( filename, content ),
                        input = {};
                    input[ type ] = {
                        filename: filename,
                        content: content
                    };
                    return MapShaper.importContent( input, opts )
                };
                MapShaper.importShapefile = function( obj, opts ) {
                    var shpSrc = obj.shp.content || obj.shp.filename,
                        dataset = MapShaper.importShp( shpSrc, opts ),
                        lyr = dataset.layers[ 0 ],
                        dbf;
                    if ( obj.dbf ) {
                        dbf = MapShaper.importDbf( obj, opts );
                        utils.extend( dataset.info, dbf.info );
                        lyr.data = dbf.layers[ 0 ].data;
                        if ( lyr.shapes && lyr.data.size() != lyr.shapes.length ) {
                            message( "[shp] Mismatched .dbf and .shp record count -- possible data loss." )
                        }
                    }
                    if ( obj.prj ) {
                        dataset.info.input_prj = obj.prj.content
                    }
                    return dataset
                };
                MapShaper.importDbf = function( input, opts ) {
                    var table;
                    opts = utils.extend( {}, opts );
                    if ( input.cpg && !opts.encoding ) {
                        opts.encoding = input.cpg.content
                    }
                    table = MapShaper.importDbfTable( input.dbf.content, opts );
                    return {
                        info: {},
                        layers: [ {
                            data: table
                        } ]
                    }
                };
                MapShaper.filenameToLayerName = function( path ) {
                    var name = "layer1";
                    var obj = utils.parseLocalPath( path );
                    if ( obj.basename && obj.extension ) {
                        name = obj.basename
                    }
                    return name
                };
                MapShaper.setLayerName = function( lyr, path ) {
                    if ( !lyr.name ) {
                        lyr.name = utils.getFileBase( path )
                    }
                };
                api.importFiles = function( opts ) {
                    var files = opts.files ? cli.validateInputFiles( opts.files ) : [],
                        dataset;
                    if ( opts.stdin ) {
                        dataset = api.importFile( "/dev/stdin", opts )
                    } else if ( files.length > 0 === false ) {
                        stop( "Missing input file(s)" )
                    } else if ( files.length == 1 ) {
                        dataset = api.importFile( files[ 0 ], opts )
                    } else if ( opts.merge_files ) {
                        dataset = MapShaper.importMergedFiles( files, opts )
                    } else if ( opts.combine_files ) {
                        dataset = MapShaper.importFiles( files, opts )
                    } else {
                        stop( "Invalid inputs" )
                    }
                    return dataset
                };
                api.importFile = function( path, opts ) {
                    cli.checkFileExists( path );
                    var isBinary = MapShaper.isBinaryFile( path ),
                        isShp = MapShaper.guessInputFileType( path ) == "shp",
                        input = {},
                        type, content;
                    if ( isShp ) {
                        content = null
                    } else if ( isBinary ) {
                        content = cli.readFile( path )
                    } else {
                        content = cli.readFile( path, opts && opts.encoding || "utf-8" )
                    }
                    type = MapShaper.guessInputFileType( path ) || MapShaper.guessInputContentType( content );
                    if ( !type ) {
                        stop( "Unable to import", path )
                    } else if ( type == "json" ) {
                        try {
                            content = JSON.parse( content )
                        } catch ( e ) {
                            stop( "Unable to parse JSON" )
                        }
                    }
                    input[ type ] = {
                        filename: path,
                        content: content
                    };
                    content = null;
                    if ( type == "shp" || type == "dbf" ) {
                        MapShaper.readShapefileAuxFiles( path, input )
                    }
                    if ( type == "shp" && !input.dbf ) {
                        message( utils.format( "[%s] .dbf file is missing - shapes imported without attribute data.", path ) )
                    }
                    return MapShaper.importContent( input, opts )
                };
                api.importDataTable = function( path, opts ) {
                    var dataset = api.importFile( path, opts );
                    if ( dataset.layers.length > 1 ) {
                        dataset.layers.forEach( function( lyr ) {
                            lyr.shapes = null;
                            lyr.geometry_type = null
                        } );
                        dataset.layers = api.mergeLayers( dataset.layers )
                    }
                    return dataset.layers[ 0 ].data
                };
                MapShaper.readShapefileAuxFiles = function( path, obj ) {
                    var dbfPath = utils.replaceFileExtension( path, "dbf" );
                    var cpgPath = utils.replaceFileExtension( path, "cpg" );
                    var prjPath = utils.replaceFileExtension( path, "prj" );
                    if ( cli.isFile( prjPath ) ) {
                        obj.prj = {
                            filename: prjPath,
                            content: cli.readFile( prjPath, "utf-8" )
                        }
                    }
                    if ( !obj.dbf && cli.isFile( dbfPath ) ) {
                        obj.dbf = {
                            filename: dbfPath,
                            content: cli.readFile( dbfPath )
                        }
                    }
                    if ( obj.dbf && cli.isFile( cpgPath ) ) {
                        obj.cpg = {
                            filename: cpgPath,
                            content: cli.readFile( cpgPath, "utf-8" ).trim()
                        }
                    }
                };
                api.exportFiles = function( dataset, opts ) {
                    MapShaper.writeFiles( MapShaper.exportFileContent( dataset, opts ), opts )
                };
                MapShaper.writeFiles = function( exports, opts, cb ) {
                    if ( exports.length > 0 === false ) {
                        message( "No files to save" )
                    } else if ( opts.dry_run ) {} else if ( opts.stdout ) {
                        cli.writeFile( "/dev/stdout", exports[ 0 ].content )
                    } else {
                        var paths = MapShaper.getOutputPaths( utils.pluck( exports, "filename" ), opts );
                        exports.forEach( function( obj, i ) {
                            var path = paths[ i ];
                            cli.writeFile( path, obj.content );
                            message( "Wrote " + path )
                        } )
                    }
                    if ( cb ) cb( null )
                };
                MapShaper.getOutputPaths = function( files, opts ) {
                    var odir = opts.output_dir;
                    if ( odir ) {
                        files = files.map( function( file ) {
                            return require( "path" ).join( odir, file )
                        } )
                    }
                    if ( !opts.force ) {
                        files = resolveFileCollisions( files )
                    }
                    return files
                };

                function resolveFileCollisions( candidates ) {
                    var i = 0,
                        suffix = "",
                        paths = candidates.concat();
                    while ( testFileCollision( paths ) ) {
                        i++;
                        suffix = "-ms";
                        if ( i > 1 ) suffix += String( i );
                        paths = addFileSuffix( candidates, suffix )
                    }
                    return paths
                }

                function addFileSuffix( paths, suff ) {
                    return paths.map( function( path ) {
                        return utils.getPathBase( path ) + suff + "." + utils.getFileExtension( path )
                    } )
                }

                function testFileCollision( paths ) {
                    return utils.some( paths, function( path ) {
                        return cli.isFile( path ) || cli.isDirectory( path )
                    } )
                }
                api.filterFields = function( lyr, names ) {
                    var table = lyr.data;
                    MapShaper.requireDataFields( table, names, "filter-fields" );
                    utils.difference( table.getFields(), names ).forEach( table.deleteField, table )
                };
                api.renameFields = function( lyr, names ) {
                    var map = MapShaper.mapFieldNames( names );
                    MapShaper.requireDataFields( lyr.data, Object.keys( map ), "rename-fields" );
                    utils.defaults( map, MapShaper.mapFieldNames( lyr.data.getFields() ) );
                    lyr.data.update( MapShaper.getRecordMapper( map ) )
                };
                MapShaper.mapFieldNames = function( names ) {
                    return names.reduce( function( memo, str ) {
                        var parts = str.split( "=" );
                        var dest = parts[ 0 ],
                            src = parts[ 1 ] || dest;
                        if ( !src || !dest ) stop( "[rename-fields] Invalid field description:", str );
                        memo[ src ] = dest;
                        return memo
                    }, {} )
                };
                MapShaper.getRecordMapper = function( map ) {
                    var fields = Object.keys( map );
                    return function( src ) {
                        var dest = {},
                            key;
                        for ( var i = 0, n = fields.length; i < n; i++ ) {
                            key = fields[ i ];
                            dest[ map[ key ] ] = src[ key ]
                        }
                        return dest
                    }
                };

                function Matrix2D() {
                    this.a = 1;
                    this.c = 0;
                    this.tx = 0;
                    this.b = 0;
                    this.d = 1;
                    this.ty = 0
                }
                Matrix2D.prototype.transformXY = function( x, y, p ) {
                    p = p || {};
                    p.x = x * this.a + y * this.c + this.tx;
                    p.y = x * this.b + y * this.d + this.ty;
                    return p
                };
                Matrix2D.prototype.translate = function( dx, dy ) {
                    this.tx += dx;
                    this.ty += dy
                };
                Matrix2D.prototype.rotate = function( q, x, y ) {
                    var cos = Math.cos( q );
                    var sin = Math.sin( q );
                    x = x || 0;
                    y = y || 0;
                    this.a = cos;
                    this.c = -sin;
                    this.b = sin;
                    this.d = cos;
                    this.tx += x - x * cos + y * sin;
                    this.ty += y - x * sin - y * cos
                };
                Matrix2D.prototype.scale = function( sx, sy ) {
                    this.a *= sx;
                    this.c *= sx;
                    this.b *= sy;
                    this.d *= sy
                };

                function MixedProjection( proj ) {
                    var frames = [];
                    var mixed = utils.extend( {}, proj );
                    var mproj = require( "mproj" );
                    mixed.addFrame = function( proj2, ctr1, ctr2, frameWidth, frameHeight, scale, rotation ) {
                        var m = new Matrix2D,
                            a2 = proj.a * 2,
                            xy1 = toRawXY( ctr1, proj ),
                            xy2 = toRawXY( ctr2, proj ),
                            bbox = [ xy1.x - frameWidth / a2, xy1.y - frameHeight / a2, xy1.x + frameWidth / a2, xy1.y + frameHeight / a2 ];
                        m.rotate( rotation * Math.PI / 180, xy1.x, xy1.y );
                        m.scale( scale, scale );
                        m.transformXY( xy1.x, xy1.y, xy1 );
                        m.translate( xy2.x - xy1.x, xy2.y - xy1.y );
                        frames.push( {
                            bbox: bbox,
                            matrix: m,
                            projection: proj2
                        } );
                        return this
                    };

                    function toRawXY( lp, P ) {
                        var xy = mproj.pj_fwd_deg( lp, P );
                        return {
                            x: ( xy.x / P.fr_meter - P.x0 ) / P.a,
                            y: ( xy.y / P.fr_meter - P.y0 ) / P.a
                        }
                    }
                    mixed.fwd = function( lp, xy ) {
                        var lam = lp.lam,
                            phi = lp.phi,
                            frame, bbox;
                        proj.fwd( lp, xy );
                        for ( var i = 0, n = frames.length; i < n; i++ ) {
                            frame = frames[ i ];
                            bbox = frame.bbox;
                            if ( xy.x >= bbox[ 0 ] && xy.x <= bbox[ 2 ] && xy.y >= bbox[ 1 ] && xy.y <= bbox[ 3 ] ) {
                                frame.projection.fwd( {
                                    lam: lam,
                                    phi: phi
                                }, xy );
                                frame.matrix.transformXY( xy.x, xy.y, xy );
                                break
                            }
                        }
                    };
                    return mixed
                }
                MapShaper.projectionIndex = {
                    robinson: "+proj=robin +datum=WGS84",
                    webmercator: "+proj=merc +a=6378137 +b=6378137",
                    wgs84: "+proj=longlat +datum=WGS84",
                    albersusa: AlbersNYT
                };
                MapShaper.getProjInfo = function( dataset ) {
                    var P, info;
                    try {
                        P = MapShaper.getDatasetProjection( dataset );
                        if ( P ) {
                            info = require( "mproj" ).internal.get_proj_defn( P )
                        }
                        if ( !info ) {
                            info = "unknown"
                        }
                    } catch ( e ) {
                        info = e.message
                    }
                    return info
                };
                MapShaper.getProjDefn = function( str ) {
                    var mproj = require( "mproj" );
                    var defn;
                    if ( str in MapShaper.projectionIndex ) {
                        defn = MapShaper.projectionIndex[ str ]
                    } else if ( str in mproj.internal.pj_list ) {
                        defn = "+proj=" + str
                    } else if ( /^\+/.test( str ) ) {
                        defn = str
                    } else {
                        stop( "Unknown projection definition:", str )
                    }
                    return defn
                };
                MapShaper.getProjection = function( str ) {
                    var defn = MapShaper.getProjDefn( str );
                    var P;
                    if ( typeof defn == "function" ) {
                        P = defn()
                    } else {
                        try {
                            P = require( "mproj" ).pj_init( defn )
                        } catch ( e ) {
                            stop( "Unable to use projection", defn, "(" + e.message + ")" )
                        }
                    }
                    return P || null
                };
                MapShaper.getDatasetProjection = function( dataset ) {
                    var info = dataset.info || {},
                        P = info.crs;
                    if ( !P && info.input_prj ) {
                        P = MapShaper.parsePrj( info.input_prj )
                    }
                    if ( !P && MapShaper.probablyDecimalDegreeBounds( MapShaper.getDatasetBounds( dataset ) ) ) {
                        P = MapShaper.getProjection( "wgs84" )
                    }
                    return P
                };
                MapShaper.printProjections = function() {
                    var index = require( "mproj" ).internal.pj_list;
                    message( "Proj4 projections" );
                    Object.keys( index ).sort().forEach( function( id ) {
                        message( "  " + utils.rpad( id, 7, " " ) + "  " + index[ id ].name )
                    } );
                    message( "\nAliases" );
                    Object.keys( MapShaper.projectionIndex ).sort().forEach( function( n ) {
                        message( "  " + n )
                    } )
                };
                MapShaper.parsePrj = function( str ) {
                    var proj4;
                    try {
                        proj4 = require( "mproj" ).internal.wkt_to_proj4( str )
                    } catch ( e ) {
                        stop( "Unusable .prj file (" + e.message + ")" )
                    }
                    return MapShaper.getProjection( proj4 )
                };

                function AlbersNYT() {
                    var mproj = require( "mproj" );
                    var lcc = mproj.pj_init( "+proj=lcc +lon_0=-96 +lat_0=39 +lat_1=33 +lat_2=45" );
                    var aea = mproj.pj_init( "+proj=aea +lon_0=-96 +lat_0=37.5 +lat_1=29.5 +lat_2=45.5" );
                    var mixed = new MixedProjection( aea ).addFrame( lcc, {
                        lam: -152,
                        phi: 63
                    }, {
                        lam: -115,
                        phi: 27
                    }, 6e6, 3e6, .31, 29.2 ).addFrame( lcc, {
                        lam: -157,
                        phi: 20.9
                    }, {
                        lam: -106.6,
                        phi: 28.2
                    }, 3e6, 5e6, .9, 40 );
                    return mixed
                }
                MapShaper.mergeDatasetsForExport = function( arr ) {
                    var copy = arr.map( function( dataset ) {
                        return utils.defaults( {
                            layers: dataset.layers.map( MapShaper.copyLayerShapes )
                        }, dataset )
                    } );
                    return MapShaper.mergeDatasets( copy )
                };
                MapShaper.mergeDatasets = function( arr ) {
                    var arcSources = [],
                        arcCount = 0,
                        mergedLayers = [],
                        mergedInfo = MapShaper.mergeDatasetInfo( arr ),
                        mergedArcs;
                    arr.forEach( function( data ) {
                        var n = data.arcs ? data.arcs.size() : 0;
                        if ( n > 0 ) {
                            arcSources.push( data.arcs )
                        }
                        data.layers.forEach( function( lyr ) {
                            if ( lyr.geometry_type == "polygon" || lyr.geometry_type == "polyline" ) {
                                MapShaper.forEachArcId( lyr.shapes, function( id ) {
                                    return id < 0 ? id - arcCount : id + arcCount
                                } )
                            }
                            mergedLayers.push( lyr )
                        } );
                        arcCount += n
                    } );
                    mergedArcs = MapShaper.mergeArcs( arcSources );
                    if ( mergedArcs.size() != arcCount ) {
                        error( "[mergeDatasets()] Arc indexing error" )
                    }
                    return {
                        info: mergedInfo,
                        arcs: mergedArcs,
                        layers: mergedLayers
                    }
                };
                MapShaper.mergeDatasetInfo = function( arr ) {
                    var crs = arr.reduce( function( memo, d ) {
                        var P = MapShaper.getDatasetProjection( d );
                        if ( !memo ) {
                            memo = P
                        } else if ( memo && P ) {
                            if ( memo.is_latlong != P.is_latlong ) {
                                stop( "Unable to combine projected and unprojected datasets" )
                            } else if ( memo.is_latlong ) {} else {}
                        }
                        return memo
                    }, null );
                    var info = arr.reduce( function( memo, d ) {
                        var info = d.info || {};
                        memo.input_files = memo.input_files.concat( info.input_files || [] );
                        memo.input_formats = memo.input_formats.concat( info.input_formats || [] );
                        return utils.defaults( memo, info )
                    }, {
                        crs: crs,
                        input_formats: [],
                        input_files: []
                    } );
                    return info
                };
                MapShaper.mergeArcs = function( arr ) {
                    var dataArr = arr.map( function( arcs ) {
                        if ( arcs.getRetainedInterval() > 0 ) {
                            verbose( "Baking-in simplification setting." );
                            arcs.flatten()
                        }
                        return arcs.getVertexData()
                    } );
                    var xx = utils.mergeArrays( utils.pluck( dataArr, "xx" ), Float64Array ),
                        yy = utils.mergeArrays( utils.pluck( dataArr, "yy" ), Float64Array ),
                        nn = utils.mergeArrays( utils.pluck( dataArr, "nn" ), Int32Array );
                    return new ArcCollection( nn, xx, yy )
                };
                utils.countElements = function( arrays ) {
                    return arrays.reduce( function( memo, arr ) {
                        return memo + ( arr.length || 0 )
                    }, 0 )
                };
                utils.mergeArrays = function( arrays, TypedArr ) {
                    var size = utils.countElements( arrays ),
                        Arr = TypedArr || Array,
                        merged = new Arr( size ),
                        offs = 0;
                    arrays.forEach( function( src ) {
                        var n = src.length;
                        for ( var i = 0; i < n; i++ ) {
                            merged[ i + offs ] = src[ i ]
                        }
                        offs += n
                    } );
                    return merged
                };
                api.graticule = function( dataset, opts ) {
                    var graticule = MapShaper.createGraticule( opts );
                    var dest, src;
                    if ( dataset ) {
                        dest = MapShaper.getDatasetProjection( dataset );
                        src = MapShaper.getProjection( "wgs84" );
                        if ( !dest ) stop( "[graticule] Coordinate system is unknown, unable to create a graticule" );
                        MapShaper.projectDataset( graticule, src, dest, {} );
                        utils.extend( dataset, MapShaper.mergeDatasets( [ dataset, graticule ] ) )
                    } else {
                        dataset = graticule
                    }
                    return dataset
                };
                MapShaper.createGraticule = function( opts ) {
                    var precision = 1;
                    var step = 10;
                    var majorStep = 90;
                    var xn = Math.round( 360 / step ) + 1;
                    var yn = Math.round( 180 / step ) + 1;
                    var xx = utils.range( xn, -180, step );
                    var yy = utils.range( yn, -90, step );
                    var meridians = xx.map( function( x ) {
                        var ymin = -90,
                            ymax = 90;
                        if ( x % majorStep !== 0 ) {
                            ymin += step;
                            ymax -= step
                        }
                        return MapShaper.createMeridian( x, ymin, ymax, precision )
                    } );
                    var parallels = yy.map( function( y ) {
                        return MapShaper.createParallel( y, -180, 180, precision )
                    } );
                    var geojson = {
                        type: "FeatureCollection",
                        features: meridians.concat( parallels )
                    };
                    var graticule = MapShaper.importGeoJSON( geojson, {} );
                    graticule.layers[ 0 ].name = "graticule";
                    return graticule
                };
                MapShaper.graticuleFeature = function( coords, o ) {
                    return {
                        type: "Feature",
                        properties: o,
                        geometry: {
                            type: "LineString",
                            coordinates: coords
                        }
                    }
                };
                MapShaper.createMeridian = function( x, ymin, ymax, precision ) {
                    var coords = [];
                    for ( var y = ymin; y < ymax; y += precision ) {
                        coords.push( [ x, y ] )
                    }
                    coords.push( [ x, ymax ] );
                    return MapShaper.graticuleFeature( coords, {
                        type: "meridian",
                        value: x
                    } )
                };
                MapShaper.createParallel = function( y, xmin, xmax, precision ) {
                    var coords = [];
                    for ( var x = xmin; x < xmax; x += precision ) {
                        coords.push( [ x, y ] )
                    }
                    coords.push( [ xmax, y ] );
                    return MapShaper.graticuleFeature( coords, {
                        type: "parallel",
                        value: y
                    } )
                };
                api.printInfo = function( dataset, opts ) {
                    var str = dataset.layers.map( function( lyr, i ) {
                        var infoStr = MapShaper.getLayerInfo( lyr, dataset );
                        if ( dataset.layers.length > 1 ) {
                            infoStr = "Layer " + ( i + 1 ) + "\n" + infoStr
                        }
                        return infoStr
                    } ).join( "\n\n" );
                    message( str )
                };
                MapShaper.countNullShapes = function( shapes ) {
                    var count = 0;
                    for ( var i = 0; i < shapes.length; i++ ) {
                        if ( !shapes[ i ] || shapes[ i ].length === 0 ) count++
                    }
                    return count
                };
                MapShaper.getLayerInfo = function( lyr, dataset ) {
                    var str = "Layer name: " + ( lyr.name || "[unnamed]" ) + "\n";
                    str += utils.format( "Records: %,d\n", MapShaper.getFeatureCount( lyr ) );
                    str += MapShaper.getGeometryInfo( lyr, dataset );
                    str += MapShaper.getTableInfo( lyr );
                    return str
                };
                MapShaper.getGeometryInfo = function( lyr, dataset ) {
                    var shapeCount = lyr.shapes ? lyr.shapes.length : 0,
                        nullCount = shapeCount > 0 ? MapShaper.countNullShapes( lyr.shapes ) : 0,
                        lines;
                    if ( !lyr.geometry_type ) {
                        lines = [ "Geometry: [none]" ]
                    } else {
                        lines = [ "Geometry", "Type: " + lyr.geometry_type ];
                        if ( nullCount > 0 ) {
                            lines.push( utils.format( "Null shapes: %'d", nullCount ) )
                        }
                        if ( shapeCount > nullCount ) {
                            lines.push( "Bounds: " + MapShaper.getLayerBounds( lyr, dataset.arcs ).toArray().join( " " ) );
                            lines.push( "Proj.4: " + MapShaper.getProjInfo( dataset ) )
                        }
                    }
                    return lines.join( "\n  " ) + "\n"
                };
                MapShaper.getTableInfo = function( lyr, i ) {
                    if ( !lyr.data || lyr.data.size() === 0 ) {
                        return "Attribute data: [none]"
                    }
                    return MapShaper.getAttributeInfo( lyr.data, i )
                };
                MapShaper.getAttributeInfo = function( data, i ) {
                    var featureId = i || 0;
                    var featureLabel = i >= 0 ? "Value" : "First value";
                    var fields = data.getFields().sort();
                    var col1Chars = fields.reduce( function( memo, name ) {
                        return Math.max( memo, name.length )
                    }, 5 ) + 2;
                    var vals = fields.map( function( fname ) {
                        return data.getRecordAt( featureId )[ fname ]
                    } );
                    var maxIntegralChars = vals.reduce( function( max, val ) {
                        if ( utils.isNumber( val ) ) {
                            max = Math.max( max, MapShaper.countIntegralChars( val ) )
                        }
                        return max
                    }, 0 );
                    var table = vals.map( function( val, i ) {
                        return "  " + MapShaper.formatTableItem( fields[ i ], val, col1Chars, maxIntegralChars )
                    } ).join( "\n" );
                    return "Attribute data\n  " + utils.rpad( "Field", col1Chars, " " ) + featureLabel + "\n" + table
                };
                MapShaper.formatNumber = function( val ) {
                    return val + ""
                };
                MapShaper.formatString = function( str ) {
                    var replacements = {
                        "\n": "\\n",
                        "\r": "\\r",
                        "\t": "\\t"
                    };
                    var cleanChar = function( c ) {
                        return c in replacements ? replacements[ c ] : ""
                    };
                    str = str.replace( /[\r\t\n]/g, cleanChar );
                    return "'" + str + "'"
                };
                MapShaper.countIntegralChars = function( val ) {
                    return utils.isNumber( val ) ? ( MapShaper.formatNumber( val ) + "." ).indexOf( "." ) : 0
                };
                MapShaper.formatTableItem = function( name, val, col1Chars, integralChars ) {
                    var str = utils.rpad( name, col1Chars, " " );
                    if ( utils.isNumber( val ) ) {
                        str += utils.lpad( "", integralChars - MapShaper.countIntegralChars( val ), " " ) + MapShaper.formatNumber( val )
                    } else if ( utils.isString( val ) ) {
                        str += MapShaper.formatString( val )
                    } else if ( utils.isObject( val ) ) {
                        str += JSON.stringify( val )
                    } else {
                        str += String( val )
                    }
                    return str
                };
                MapShaper.getSimplificationInfo = function( arcs ) {
                    var nodeCount = new NodeCollection( arcs ).size();
                    var internalVertexCount = MapShaper.countInteriorVertices( arcs )
                };
                MapShaper.countInteriorVertices = function( arcs ) {
                    var count = 0;
                    arcs.forEach2( function( i, n ) {
                        if ( n > 2 ) {
                            count += n - 2
                        }
                    } );
                    return count
                };
                api.innerlines = function( lyr, arcs, opts ) {
                    MapShaper.requirePolygonLayer( lyr, "[innerlines] Command requires a polygon layer" );
                    var classifier = MapShaper.getArcClassifier( lyr.shapes, arcs );
                    var lines = MapShaper.extractInnerLines( lyr.shapes, classifier );
                    var outputLyr = MapShaper.createLineLayer( lines, null );
                    if ( lines.length === 0 ) {
                        message( "[innerlines] No shared boundaries were found" )
                    }
                    outputLyr.name = opts && opts.no_replace ? null : lyr.name;
                    return outputLyr
                };
                api.lines = function( lyr, arcs, opts ) {
                    opts = opts || {};
                    var classifier = MapShaper.getArcClassifier( lyr.shapes, arcs ),
                        fields = utils.isArray( opts.fields ) ? opts.fields : [],
                        typeId = 0,
                        shapes = [],
                        records = [],
                        outputLyr;
                    MapShaper.requirePolygonLayer( lyr, "[lines] Command requires a polygon layer" );
                    if ( fields.length > 0 && !lyr.data ) {
                        stop( "[lines] Missing a data table" )
                    }
                    addLines( MapShaper.extractOuterLines( lyr.shapes, classifier ) );
                    fields.forEach( function( field ) {
                        var data = lyr.data.getRecords();
                        var key = function( a, b ) {
                            var arec = data[ a ];
                            var brec = data[ b ];
                            var aval, bval;
                            if ( !arec || !brec || arec[ field ] === brec[ field ] ) {
                                return null
                            }
                            return a + "-" + b
                        };
                        if ( !lyr.data.fieldExists( field ) ) {
                            stop( "[lines] Unknown data field:", field )
                        }
                        addLines( MapShaper.extractLines( lyr.shapes, classifier( key ) ) )
                    } );
                    addLines( MapShaper.extractInnerLines( lyr.shapes, classifier ) );
                    outputLyr = MapShaper.createLineLayer( shapes, records );
                    outputLyr.name = opts.no_replace ? null : lyr.name;
                    return outputLyr;

                    function addLines( lines ) {
                        var attr = lines.map( function( shp, i ) {
                            return {
                                TYPE: typeId
                            }
                        } );
                        shapes = utils.merge( lines, shapes );
                        records = utils.merge( attr, records );
                        typeId++
                    }
                };
                MapShaper.createLineLayer = function( lines, records ) {
                    return {
                        geometry_type: "polyline",
                        shapes: lines,
                        data: records ? new DataTable( records ) : null
                    }
                };
                MapShaper.extractOuterLines = function( shapes, classifier ) {
                    var key = function( a, b ) {
                        return b == -1 ? String( a ) : null
                    };
                    return MapShaper.extractLines( shapes, classifier( key ) )
                };
                MapShaper.extractInnerLines = function( shapes, classifier ) {
                    var key = function( a, b ) {
                        return b > -1 ? a + "-" + b : null
                    };
                    return MapShaper.extractLines( shapes, classifier( key ) )
                };
                MapShaper.extractLines = function( shapes, classify ) {
                    var lines = [],
                        index = {},
                        prev = null,
                        prevKey = null,
                        part;
                    MapShaper.traversePaths( shapes, onArc, onPart );

                    function onArc( o ) {
                        var arcId = o.arcId,
                            key = classify( arcId ),
                            isContinuation, line;
                        if ( !!key ) {
                            line = key in index ? index[ key ] : null;
                            isContinuation = key == prevKey && o.shapeId == prev.shapeId && o.partId == prev.partId;
                            if ( !line ) {
                                line = [ [ arcId ] ];
                                index[ key ] = line;
                                lines.push( line )
                            } else if ( isContinuation ) {
                                line[ line.length - 1 ].push( arcId )
                            } else {
                                line.push( [ arcId ] )
                            }
                            if ( o.i == part.arcs.length - 1 && line.length > 1 && line[ 0 ][ 0 ] == part.arcs[ 0 ] ) {
                                line[ 0 ] = line.pop().concat( line[ 0 ] )
                            }
                        }
                        prev = o;
                        prevKey = key
                    }

                    function onPart( o ) {
                        part = o
                    }
                    return lines
                };
                api.inspect = function( lyr, arcs, opts ) {
                    var ids = MapShaper.selectFeatures( lyr, arcs, opts );
                    var msg;
                    if ( ids.length == 1 ) {
                        msg = MapShaper.getFeatureInfo( ids[ 0 ], lyr, arcs )
                    } else {
                        msg = utils.format( "[inspect] Expression matched %d feature%s. Select one feature for details", ids.length, utils.pluralSuffix( ids.length ) )
                    }
                    message( msg )
                };
                MapShaper.getFeatureInfo = function( id, lyr, arcs ) {
                    var msg = "Feature " + id + "\n";
                    msg += MapShaper.getShapeInfo( id, lyr, arcs );
                    msg += MapShaper.getTableInfo( lyr, id );
                    return msg
                };
                MapShaper.getShapeInfo = function( id, lyr, arcs ) {
                    var shp = lyr.shapes ? lyr.shapes[ id ] : null;
                    var type = lyr.geometry_type;
                    var info, msg;
                    if ( !shp || !type ) {
                        return "Geometry: [null]\n"
                    }
                    msg = "Geometry\n  Type: " + type + "\n";
                    if ( type == "point" ) {
                        msg += "  Points: " + shp.length + "\n"
                    } else if ( type == "polyline" ) {
                        msg += "  Parts: " + shp.length + "\n"
                    } else if ( type == "polygon" ) {
                        info = MapShaper.getPolygonInfo( shp, arcs );
                        msg += utils.format( "  Rings: %d cw, %d ccw\n", info.cw, info.ccw );
                        msg += "  Planar area: " + info.area + "\n";
                        if ( info.sph_area ) {
                            msg += "  Spherical area: " + info.sph_area + " sq. meters\n"
                        }
                    }
                    return msg
                };
                MapShaper.getPolygonInfo = function( shp, arcs ) {
                    var o = {
                        rings: shp.length,
                        cw: 0,
                        ccw: 0,
                        area: 0
                    };
                    var area;
                    for ( var i = 0; i < shp.length; i++ ) {
                        area = geom.getPlanarPathArea( shp[ i ], arcs );
                        if ( area > 0 ) {
                            o.cw++
                        } else if ( area < 0 ) {
                            o.ccw++
                        }
                        o.area += area
                    }
                    if ( !arcs.isPlanar() ) {
                        o.sph_area = geom.getSphericalShapeArea( shp, arcs )
                    }
                    return o
                };
                MapShaper.selectFeatures = function( lyr, arcs, opts ) {
                    var n = MapShaper.getFeatureCount( lyr ),
                        ids = [],
                        filter;
                    if ( !opts.expression ) {
                        stop( "[inspect] Missing a JS expression for selecting a feature" )
                    }
                    filter = MapShaper.compileValueExpression( opts.expression, lyr, arcs );
                    utils.repeat( n, function( id ) {
                        var result = filter( id );
                        if ( result === true ) {
                            ids.push( id )
                        } else if ( result !== false ) {
                            stop( "[inspect] Expression must return true or false" )
                        }
                    } );
                    return ids
                };
                MapShaper.importDelim = function( str, opts ) {
                    var delim = MapShaper.guessDelimiter( str );
                    return {
                        layers: [ {
                            data: MapShaper.importDelimTable( str, delim, opts )
                        } ],
                        info: {
                            input_delimiter: delim
                        }
                    }
                };
                MapShaper.importDelimTable = function( str, delim, opts ) {
                    var records = require( "d3-dsv" ).dsvFormat( delim ).parse( str );
                    var table;
                    if ( records.length === 0 ) {
                        stop( "[dsv] Unable to read any records" )
                    }
                    delete records.columns;
                    MapShaper.adjustRecordTypes( records, opts && opts.field_types );
                    table = new DataTable( records );
                    MapShaper.deleteFields( table, MapShaper.isInvalidFieldName );
                    return table
                };
                MapShaper.supportedDelimiters = [ "|", "\t", ",", ";" ];
                MapShaper.isSupportedDelimiter = function( d ) {
                    return utils.contains( MapShaper.supportedDelimiters, d )
                };
                MapShaper.guessDelimiter = function( content ) {
                    return utils.find( MapShaper.supportedDelimiters, function( delim ) {
                        var rxp = MapShaper.getDelimiterRxp( delim );
                        return rxp.test( content )
                    } ) || ","
                };
                MapShaper.getDelimiterRxp = function( delim ) {
                    var rxp = "^[^\\n\\r]+" + utils.regexEscape( delim );
                    return new RegExp( rxp )
                };
                MapShaper.adjustRecordTypes = function( records, fieldList ) {
                    var hintIndex = {},
                        fields = Object.keys( records[ 0 ] || [] ),
                        type;
                    if ( fieldList ) {
                        MapShaper.parseFieldHeaders( fieldList, hintIndex )
                    }
                    fields.forEach( function( key ) {
                        type = hintIndex[ key ] || MapShaper.detectConversionType( key, records );
                        if ( type == "number" ) {
                            MapShaper.convertDataField( records, key, utils.parseNumber )
                        } else if ( type == "string" ) {
                            MapShaper.convertDataField( records, key, utils.parseString )
                        }
                    } )
                };
                MapShaper.convertDataField = function( records, name, f ) {
                    for ( var i = 0, n = records.length; i < n; i++ ) {
                        records[ i ][ name ] = f( records[ i ][ name ] )
                    }
                };
                MapShaper.detectConversionType = function( name, records ) {
                    var type = null,
                        val;
                    for ( var i = 0, n = records.length; i < n; i++ ) {
                        val = records[ i ][ name ];
                        if ( !!val && utils.isString( val ) ) {
                            type = utils.stringIsNumeric( val ) ? "number" : "string";
                            break
                        }
                    }
                    return type
                };
                MapShaper.validateFieldType = function( hint ) {
                    var str = hint.toLowerCase(),
                        type = null;
                    if ( str[ 0 ] == "n" ) {
                        type = "number"
                    } else if ( str[ 0 ] == "s" ) {
                        type = "string"
                    }
                    return type
                };
                MapShaper.removeTypeHints = function( arr ) {
                    return MapShaper.parseFieldHeaders( arr, {} )
                };
                MapShaper.parseFieldHeaders = function( fields, index ) {
                    var parsed = fields.map( function( raw ) {
                        var parts, name, type;
                        if ( raw.indexOf( ":" ) != -1 ) {
                            parts = raw.split( ":" );
                            name = parts[ 0 ];
                            type = MapShaper.validateFieldType( parts[ 1 ] );
                            if ( !type ) {
                                message( "Invalid type hint (expected :str or :num) [" + raw + "]" )
                            }
                        } else if ( raw[ 0 ] === "+" ) {
                            name = raw.substr( 1 );
                            type = "number"
                        } else {
                            name = raw
                        }
                        if ( type ) {
                            index[ name ] = type
                        }
                        return name
                    } );
                    return parsed
                };
                utils.stringIsNumeric = function( str ) {
                    var parsed = utils.parseNumber( str );
                    return !isNaN( parsed ) && parsed == Number( utils.cleanNumericString( str ) )
                };
                utils.cleanNumericString = function( raw ) {
                    return String( raw ).replace( /,/g, "" )
                };
                utils.parseString = function( raw ) {
                    return raw ? raw : ""
                };
                utils.parseNumber = function( raw ) {
                    var parsed = raw ? parseFloat( utils.cleanNumericString( raw ) ) : NaN;
                    return isNaN( parsed ) ? null : parsed
                };
                api.joinPointsToPolygons = function( targetLyr, arcs, pointLyr, opts ) {
                    var joinFunction = MapShaper.getPolygonToPointsFunction( targetLyr, arcs, pointLyr, opts );
                    MapShaper.prepJoinLayers( targetLyr, pointLyr );
                    return MapShaper.joinTables( targetLyr.data, pointLyr.data, joinFunction, opts )
                };
                api.joinPolygonsToPoints = function( targetLyr, polygonLyr, arcs, opts ) {
                    var joinFunction = MapShaper.getPointToPolygonFunction( targetLyr, polygonLyr, arcs, opts );
                    MapShaper.prepJoinLayers( targetLyr, polygonLyr );
                    return MapShaper.joinTables( targetLyr.data, polygonLyr.data, joinFunction, opts )
                };
                MapShaper.prepJoinLayers = function( targetLyr, srcLyr ) {
                    if ( !targetLyr.data ) {
                        targetLyr.data = new DataTable( targetLyr.shapes.length )
                    }
                    if ( !srcLyr.data ) {
                        stop( "[join] Can't join a layer that is missing attribute data" )
                    }
                };
                MapShaper.getPolygonToPointsFunction = function( polygonLyr, arcs, pointLyr, opts ) {
                    var joinFunction = MapShaper.getPointToPolygonFunction( pointLyr, polygonLyr, arcs, opts );
                    var index = [];
                    var hit, polygonId;
                    for ( var i = 0, n = pointLyr.shapes.length; i < n; i++ ) {
                        hit = joinFunction( i );
                        if ( hit ) {
                            polygonId = hit[ 0 ];
                            if ( polygonId in index ) {
                                index[ polygonId ].push( i )
                            } else {
                                index[ polygonId ] = [ i ]
                            }
                        }
                    }
                    return function( i ) {
                        return index[ i ] || null
                    }
                };
                MapShaper.getPointToPolygonFunction = function( pointLyr, polygonLyr, arcs, opts ) {
                    var index = new PathIndex( polygonLyr.shapes, arcs ),
                        points = pointLyr.shapes;
                    return function( i ) {
                        var shp = points[ i ],
                            shpId = -1;
                        if ( shp ) {
                            shpId = index.findEnclosingShape( shp[ 0 ] )
                        }
                        return shpId == -1 ? null : [ shpId ]
                    }
                };
                MapShaper.getJoinFilter = function( data, exp ) {
                    var test = MapShaper.getJoinFilterTestFunction( exp, data );
                    var calc = null;
                    if ( MapShaper.expressionHasCalcFunction( exp ) ) {
                        calc = MapShaper.getJoinFilterCalcFunction( exp, data )
                    }
                    return function( ids ) {
                        var d = calc ? calc( ids ) : null;
                        var filtered = [],
                            retn, i;
                        for ( i = 0; i < ids.length; i++ ) {
                            retn = test( ids[ i ], d );
                            if ( retn === true ) {
                                filtered.push( ids[ i ] )
                            } else if ( retn !== false ) {
                                stop( '[join] "where" expression must return true or false' )
                            }
                        }
                        return filtered
                    }
                };
                MapShaper.expressionHasCalcFunction = function( exp ) {
                    return utils.some( [ "isMax", "isMin", "isMode" ], function( name ) {
                        return exp.indexOf( name ) > -1
                    } )
                };
                MapShaper.getJoinFilterCalcFunction = function( exp, data ) {
                    var values, counts, max, min, context, calc, n;
                    context = {
                        isMax: function( val ) {
                            if ( val > max ) max = val
                        },
                        isMin: function( val ) {
                            if ( val < min ) min = val
                        },
                        isMode: function( val ) {
                            if ( !values ) {
                                values = []
                            }
                            values.push( val )
                        }
                    };
                    calc = MapShaper.compileFeatureExpression( exp, {
                        data: data
                    }, null, {
                        context: context
                    } );

                    function reset() {
                        max = -Infinity;
                        min = Infinity;
                        values = null
                    }
                    return function( ids ) {
                        reset();
                        for ( var i = 0; i < ids.length; i++ ) {
                            calc( ids[ i ] )
                        }
                        return {
                            max: max,
                            min: min,
                            modes: values ? MapShaper.getModeValues( values ) : null
                        }
                    }
                };
                MapShaper.getModeValues = function( values ) {
                    var maxCount = 0,
                        counts, uniq, modes, val, i, count;
                    if ( values.length == 1 ) {
                        return values
                    }
                    uniq = [];
                    counts = {};
                    for ( i = 0; i < values.length; i++ ) {
                        val = values[ i ];
                        if ( val in counts === false ) {
                            counts[ val ] = 0;
                            uniq.push( val )
                        }
                        count = ++counts[ val ];
                        if ( count > maxCount ) maxCount = count
                    }
                    modes = [];
                    for ( i = 0; i < uniq.length; i++ ) {
                        if ( counts[ uniq[ i ] ] === maxCount ) {
                            modes.push( uniq[ i ] )
                        }
                    }
                    return modes
                };
                MapShaper.getJoinFilterTestFunction = function( exp, data ) {
                    var context, test, d;
                    context = {
                        isMax: function( val ) {
                            return val === d.max
                        },
                        isMin: function( val ) {
                            return val === d.min
                        },
                        isMode: function( val ) {
                            return d.modes.indexOf( val ) > -1
                        }
                    };
                    test = MapShaper.compileFeatureExpression( exp, {
                        data: data
                    }, null, {
                        context: context,
                        returns: true
                    } );
                    return function( i, datum ) {
                        d = datum;
                        return test( i )
                    }
                };
                api.join = function( targetLyr, dataset, opts ) {
                    var src, srcLyr, srcType, targetType, retn;
                    if ( opts.keys ) {
                        if ( opts.keys.length != 2 ) {
                            stop( "[join] Expected two key fields: a target field and a source field" )
                        }
                        src = MapShaper.getJoinTable( dataset, opts );
                        retn = api.joinAttributesToFeatures( targetLyr, src, opts )
                    } else {
                        src = MapShaper.getJoinDataset( dataset, opts );
                        if ( !src ) {
                            stop( "[join] Missing a joinable data source" )
                        }
                        srcLyr = src.layers[ 0 ];
                        srcType = srcLyr.geometry_type;
                        targetType = targetLyr.geometry_type;
                        if ( srcType == "point" && targetType == "polygon" ) {
                            retn = api.joinPointsToPolygons( targetLyr, dataset.arcs, srcLyr, opts )
                        } else if ( srcType == "polygon" && targetType == "point" ) {
                            retn = api.joinPolygonsToPoints( targetLyr, srcLyr, src.arcs, opts )
                        } else {
                            stop( utils.format( "[join] Unable to join %s geometry to %s geometry", srcType || "null", targetType || "null" ) )
                        }
                    }
                    if ( retn.unmatched ) {
                        dataset.layers.push( retn.unmatched )
                    }
                    if ( retn.unjoined ) {
                        dataset.layers.push( retn.unjoined )
                    }
                };
                MapShaper.getJoinTable = function( dataset, opts ) {
                    var layers = MapShaper.findMatchingLayers( dataset.layers, opts.source ),
                        table;
                    if ( layers.length > 0 ) {
                        table = layers[ 0 ].data
                    } else {
                        table = api.importJoinTable( opts.source, opts )
                    }
                    return table
                };
                MapShaper.getJoinDataset = function( dataset, opts ) {
                    var layers = MapShaper.findMatchingLayers( dataset.layers, opts.source );
                    if ( !layers.length ) {
                        dataset = api.importFile( opts.source, opts );
                        layers = dataset.layers
                    }
                    return layers.length ? {
                        arcs: dataset.arcs,
                        layers: [ layers[ 0 ] ]
                    } : null
                };
                api.importJoinTable = function( file, opts ) {
                    var fieldsWithTypeHints = [];
                    if ( opts.keys ) {
                        fieldsWithTypeHints.push( opts.keys[ 1 ] )
                    }
                    if ( opts.fields ) {
                        fieldsWithTypeHints = fieldsWithTypeHints.concat( opts.fields )
                    }
                    if ( opts.field_types ) {
                        fieldsWithTypeHints = fieldsWithTypeHints.concat( opts.field_types )
                    }
                    var importOpts = utils.defaults( {
                        field_types: fieldsWithTypeHints
                    }, opts );
                    return api.importDataTable( file, importOpts )
                };
                api.joinAttributesToFeatures = function( lyr, srcTable, opts ) {
                    var keys = MapShaper.removeTypeHints( opts.keys ),
                        destKey = keys[ 0 ],
                        srcKey = keys[ 1 ],
                        destTable = lyr.data,
                        joinFields = opts.fields || utils.difference( srcTable.getFields(), [ srcKey ] ),
                        joinFunction = MapShaper.getJoinByKey( destTable, destKey, srcTable, srcKey );
                    opts = utils.defaults( {
                        fields: joinFields
                    }, opts );
                    return MapShaper.joinTables( destTable, srcTable, joinFunction, opts )
                };
                MapShaper.joinTables = function( dest, src, join, opts ) {
                    var srcRecords = src.getRecords(),
                        destRecords = dest.getRecords(),
                        unmatchedRecords = [],
                        joinFields = MapShaper.getFieldsToJoin( dest, src, opts ),
                        sumFields = opts.sum_fields || [],
                        copyFields = utils.difference( joinFields, sumFields ),
                        countField = MapShaper.getCountFieldName( dest.getFields() ),
                        addCountField = sumFields.length > 0,
                        joinCounts = new Uint32Array( srcRecords.length ),
                        matchCount = 0,
                        collisionCount = 0,
                        retn = {},
                        srcRec, srcId, destRec, joinIds, joins, count, filter;
                    if ( opts.where ) {
                        filter = MapShaper.getJoinFilter( src, opts.where )
                    }
                    for ( var i = 0, n = destRecords.length; i < n; i++ ) {
                        count = 0;
                        destRec = destRecords[ i ];
                        joins = join( i );
                        if ( joins && filter ) {
                            joins = filter( joins )
                        }
                        for ( var j = 0, m = joins ? joins.length : 0; j < m; j++ ) {
                            srcId = joins[ j ];
                            srcRec = srcRecords[ srcId ];
                            if ( copyFields.length > 0 ) {
                                if ( count === 0 ) {
                                    MapShaper.joinByCopy( destRec, srcRec, copyFields )
                                } else {
                                    collisionCount++
                                }
                            }
                            if ( sumFields.length > 0 ) {
                                MapShaper.joinBySum( destRec, srcRec, sumFields )
                            }
                            joinCounts[ srcId ]++;
                            count++
                        }
                        if ( count > 0 ) {
                            matchCount++
                        } else if ( destRec ) {
                            if ( opts.unmatched ) {
                                unmatchedRecords.push( utils.extend( {}, destRec ) )
                            }
                            MapShaper.updateUnmatchedRecord( destRec, copyFields, sumFields )
                        }
                        if ( addCountField ) {
                            destRec[ countField ] = count
                        }
                    }
                    if ( matchCount === 0 ) {
                        stop( "[join] No records could be joined" )
                    }
                    MapShaper.printJoinMessage( matchCount, destRecords.length, MapShaper.countJoins( joinCounts ), srcRecords.length, collisionCount );
                    if ( opts.unjoined ) {
                        retn.unjoined = {
                            name: "unjoined",
                            data: new DataTable( srcRecords.filter( function( o, i ) {
                                return joinCounts[ i ] === 0
                            } ) )
                        }
                    }
                    if ( opts.unmatched ) {
                        retn.unmatched = {
                            name: "unmatched",
                            data: new DataTable( unmatchedRecords )
                        }
                    }
                    return retn
                };
                MapShaper.countJoins = function( counts ) {
                    var joinCount = 0;
                    for ( var i = 0, n = counts.length; i < n; i++ ) {
                        if ( counts[ i ] > 0 ) {
                            joinCount++
                        }
                    }
                    return joinCount
                };
                MapShaper.updateUnmatchedRecord = function( rec, copyFields, sumFields ) {
                    MapShaper.joinByCopy( rec, {}, copyFields );
                    MapShaper.joinBySum( rec, {}, sumFields )
                };
                MapShaper.getCountFieldName = function( fields ) {
                    var uniq = MapShaper.getUniqFieldNames( fields.concat( "joins" ) );
                    return uniq.pop()
                };
                MapShaper.joinByCopy = function( dest, src, fields ) {
                    var f;
                    for ( var i = 0, n = fields.length; i < n; i++ ) {
                        f = fields[ i ];
                        if ( Object.prototype.hasOwnProperty.call( src, f ) ) {
                            dest[ f ] = src[ f ]
                        } else if ( !Object.prototype.hasOwnProperty.call( dest, f ) ) {
                            dest[ f ] = null
                        }
                    }
                };
                MapShaper.joinBySum = function( dest, src, fields ) {
                    var f;
                    for ( var j = 0; j < fields.length; j++ ) {
                        f = fields[ j ];
                        dest[ f ] = ( dest[ f ] || 0 ) + ( src[ f ] || 0 )
                    }
                };
                MapShaper.printJoinMessage = function( matches, n, joins, m, collisions ) {
                    message( utils.format( "[join] Joined %'d data record%s", joins, utils.pluralSuffix( joins ) ) );
                    if ( matches < n ) {
                        message( utils.format( "[join] %d/%d target records received no data", n - matches, n ) )
                    }
                    if ( joins < m ) {
                        message( utils.format( "[join] %d/%d source records could not be joined", m - joins, m ) )
                    }
                    if ( collisions > 0 ) {
                        message( utils.format( "[join] %'d collision%s occured; data was copied from the first matching source record", collisions, utils.pluralSuffix( collisions ) ) )
                    }
                };
                MapShaper.getFieldsToJoin = function( destTable, srcTable, opts ) {
                    var joinFields;
                    if ( opts.fields ) {
                        joinFields = MapShaper.removeTypeHints( opts.fields )
                    } else {
                        joinFields = srcTable.getFields()
                    }
                    if ( !opts.force ) {
                        joinFields = utils.difference( joinFields, destTable.getFields() )
                    }
                    return joinFields
                };
                MapShaper.getJoinByKey = function( dest, destKey, src, srcKey ) {
                    var destRecords = dest.getRecords();
                    var index = MapShaper.createTableIndex( src.getRecords(), srcKey );
                    if ( src.fieldExists( srcKey ) === false ) {
                        stop( "[join] External table is missing a field named:", srcKey )
                    }
                    if ( !dest || !dest.fieldExists( destKey ) ) {
                        stop( "[join] Target layer is missing key field:", destKey )
                    }
                    return function( i ) {
                        var destRec = destRecords[ i ],
                            val = destRec ? destRec[ destKey ] : null;
                        return destRec && val in index ? index[ val ] : null
                    }
                };
                MapShaper.createTableIndex = function( records, f ) {
                    var index = {},
                        rec, key;
                    for ( var i = 0, n = records.length; i < n; i++ ) {
                        rec = records[ i ];
                        key = rec[ f ];
                        if ( key in index ) {
                            index[ key ].push( i )
                        } else {
                            index[ key ] = [ i ]
                        }
                    }
                    return index
                };
                api.keepEveryPolygon = MapShaper.keepEveryPolygon = function( arcData, layers ) {
                    layers.forEach( function( lyr ) {
                        if ( lyr.geometry_type == "polygon" ) {
                            MapShaper.protectLayerShapes( arcData, lyr.shapes )
                        }
                    } )
                };
                MapShaper.protectLayerShapes = function( arcData, shapes ) {
                    shapes.forEach( function( shape ) {
                        MapShaper.protectShape( arcData, shape )
                    } )
                };
                MapShaper.protectShape = function( arcData, shape ) {
                    var maxArea = 0,
                        arcCount = shape ? shape.length : 0,
                        maxRing, area;
                    for ( var i = 0; i < arcCount; i++ ) {
                        area = arcData.getSimpleShapeBounds( shape[ i ] ).area();
                        if ( area > maxArea ) {
                            maxRing = shape[ i ];
                            maxArea = area
                        }
                    }
                    if ( !maxRing || maxRing.length === 0 ) {
                        verbose( "[protectShape()] Invalid shape:", shape )
                    } else if ( maxRing.length == 1 ) {
                        MapShaper.protectIslandRing( arcData, maxRing )
                    } else {
                        MapShaper.protectMultiRing( arcData, maxRing )
                    }
                };
                MapShaper.protectIslandRing = function( arcData, ring ) {
                    var added = MapShaper.lockMaxThreshold( arcData, ring );
                    if ( added == 1 ) {
                        added += MapShaper.lockMaxThreshold( arcData, ring )
                    }
                    if ( added < 2 ) verbose( "[protectIslandRing()] Failed on ring:", ring )
                };
                MapShaper.protectMultiRing = function( arcData, ring ) {
                    var zlim = arcData.getRetainedInterval(),
                        minArea = 0,
                        area, added;
                    arcData.setRetainedInterval( Infinity );
                    area = geom.getPlanarPathArea( ring, arcData );
                    while ( area <= minArea ) {
                        added = MapShaper.lockMaxThreshold( arcData, ring );
                        if ( added === 0 ) {
                            verbose( "[protectMultiRing()] Failed on ring:", ring );
                            break
                        }
                        area = geom.getPlanarPathArea( ring, arcData )
                    }
                    arcData.setRetainedInterval( zlim )
                };
                MapShaper.lockMaxThreshold = function( arcData, ring ) {
                    var targZ = 0,
                        targArcId, raw = arcData.getVertexData(),
                        arcId, id, z, start, end;
                    for ( var i = 0; i < ring.length; i++ ) {
                        arcId = ring[ i ];
                        if ( arcId < 0 ) arcId = ~arcId;
                        start = raw.ii[ arcId ];
                        end = start + raw.nn[ arcId ] - 1;
                        id = MapShaper.findNextRemovableVertex( raw.zz, Infinity, start, end );
                        if ( id == -1 ) continue;
                        z = raw.zz[ id ];
                        if ( z > targZ ) {
                            targZ = z;
                            targArcId = arcId
                        }
                    }
                    if ( targZ > 0 ) {
                        start = raw.ii[ targArcId ];
                        end = start + raw.nn[ targArcId ] - 1;
                        return MapShaper.replaceInArray( raw.zz, targZ, Infinity, start, end )
                    }
                    return 0
                };
                MapShaper.replaceInArray = function( zz, value, replacement, start, end ) {
                    var count = 0;
                    for ( var i = start; i <= end; i++ ) {
                        if ( zz[ i ] === value ) {
                            zz[ i ] = replacement;
                            count++
                        }
                    }
                    return count
                };
                MapShaper.importMergedFiles = function( files, opts ) {
                    var combined = MapShaper.importFiles( files, opts );
                    combined.layers = api.mergeLayers( combined.layers );
                    return combined
                };
                MapShaper.importFiles = function( files, opts ) {
                    var unbuiltTopology = false;
                    var datasets = files.map( function( fname ) {
                        var importOpts = utils.defaults( {
                            no_topology: true,
                            auto_snap: false,
                            snap_interval: null,
                            files: [ fname ]
                        }, opts );
                        var dataset = api.importFile( fname, importOpts );
                        if ( dataset.arcs && dataset.arcs.size() > 0 && dataset.info.input_formats[ 0 ] != "topojson" ) {
                            unbuiltTopology = true
                        }
                        return dataset
                    } );
                    var combined = MapShaper.mergeDatasets( datasets );
                    if ( unbuiltTopology && !opts.no_topology ) {
                        if ( opts.auto_snap || opts.snap_interval ) {
                            MapShaper.snapCoords( combined.arcs, opts.snap_interval )
                        }
                        api.buildTopology( combined )
                    }
                    return combined
                };
                api.mergeLayers = function( layers ) {
                    var merged;
                    MapShaper.checkLayersCanMerge( layers );
                    layers.forEach( function( lyr ) {
                        if ( !merged ) {
                            merged = lyr
                        } else {
                            merged.name = utils.mergeNames( merged.name, lyr.name );
                            if ( merged.shapes && lyr.shapes ) {
                                merged.shapes = merged.shapes.concat( lyr.shapes )
                            } else {
                                merged.shapes = null
                            }
                            if ( merged.data && lyr.data ) {
                                merged.data = new DataTable( merged.data.getRecords().concat( lyr.data.getRecords() ) )
                            } else {
                                merged.data = null
                            }
                        }
                    } );
                    return merged ? [ merged ] : null
                };
                MapShaper.checkFieldTypes = function( key, layers ) {
                    return layers.reduce( function( memo, lyr ) {
                        var type = lyr.data ? MapShaper.getColumnType( key, lyr.data ) : null;
                        if ( type && memo.indexOf( type ) == -1 ) {
                            memo.push( type )
                        }
                        return memo
                    }, [] )
                };
                MapShaper.findMissingFields = function( layers ) {
                    var matrix = layers.map( function( lyr ) {
                        return lyr.data ? lyr.data.getFields() : []
                    } );
                    var allFields = matrix.reduce( function( memo, fields ) {
                        return utils.uniq( memo.concat( fields ) )
                    }, [] );
                    return matrix.reduce( function( memo, fields ) {
                        var diff = utils.difference( allFields, fields );
                        return utils.uniq( memo.concat( diff ) )
                    }, [] )
                };
                MapShaper.checkLayersCanMerge = function( layers ) {
                    var geoTypes = utils.uniq( utils.pluck( layers, "geometry_type" ) ),
                        missingFields = MapShaper.findMissingFields( layers );
                    if ( utils.uniq( geoTypes ).length > 1 ) {
                        stop( "[merge-layers] Incompatible geometry types:", geoTypes.map( function( type ) {
                            return type || "[none]"
                        } ).join( ", " ) )
                    }
                    if ( missingFields.length > 0 ) {
                        stop( "[merge-layers] Field" + utils.pluralSuffix( missingFields.length ), "missing from one or more layers:", missingFields.join( ", " ) )
                    }
                    layers[ 0 ].data.getFields().forEach( function( key ) {
                        var types = MapShaper.checkFieldTypes( key, layers );
                        if ( types.length > 1 ) {
                            stop( '[merge-layers] Inconsistent data types in "' + key + '" field:', types.join( ", " ) )
                        }
                    } )
                };
                api.createPointLayer = function( srcLyr, arcs, opts ) {
                    var destLyr = MapShaper.getOutputLayer( srcLyr, opts );
                    destLyr.shapes = opts.x || opts.y ? MapShaper.pointsFromDataTable( srcLyr.data, opts ) : MapShaper.pointsFromPolygons( srcLyr, arcs, opts );
                    destLyr.geometry_type = "point";
                    var nulls = destLyr.shapes.reduce( function( sum, shp ) {
                        if ( !shp ) sum++;
                        return sum
                    }, 0 );
                    if ( nulls > 0 ) {
                        message( utils.format( "[points] %,d of %,d points are null", nulls, destLyr.shapes.length ) )
                    }
                    if ( srcLyr.data ) {
                        destLyr.data = opts.no_replace ? srcLyr.data.clone() : srcLyr.data
                    }
                    return destLyr
                };
                MapShaper.pointsFromPolygons = function( lyr, arcs, opts ) {
                    if ( lyr.geometry_type != "polygon" ) {
                        stop( "[points] Expected a polygon layer" )
                    }
                    var func = opts.inner ? geom.findInteriorPoint : geom.getShapeCentroid;
                    return lyr.shapes.map( function( shp ) {
                        var p = func( shp, arcs );
                        return p ? [ [ p.x, p.y ] ] : null
                    } )
                };
                MapShaper.pointsFromDataTable = function( data, opts ) {
                    if ( !data ) stop( "[points] Layer is missing a data table" );
                    if ( !opts.x || !opts.y || !data.fieldExists( opts.x ) || !data.fieldExists( opts.y ) ) {
                        stop( "[points] Missing x,y data fields" )
                    }
                    return data.getRecords().map( function( rec ) {
                        var x = rec[ opts.x ],
                            y = rec[ opts.y ];
                        if ( !utils.isFiniteNumber( x ) || !utils.isFiniteNumber( y ) ) {
                            return null
                        }
                        return [ [ x, y ] ]
                    } )
                };
                api.pointGrid = function( dataset, opts ) {
                    var bbox, gridLyr;
                    if ( opts.bbox ) {
                        bbox = opts.bbox
                    } else if ( dataset ) {
                        bbox = MapShaper.getDatasetBounds( dataset ).toArray()
                    } else {
                        bbox = [ -180, -90, 180, 90 ]
                    }
                    gridLyr = MapShaper.createPointGrid( bbox, opts );
                    return gridLyr
                };
                MapShaper.createPointGrid = function( bbox, opts ) {
                    var w = bbox[ 2 ] - bbox[ 0 ],
                        h = bbox[ 3 ] - bbox[ 1 ],
                        points = [],
                        cols, rows, dx, dy, x0, y0, x, y;
                    if ( opts.interval > 0 ) {
                        dx = opts.interval;
                        dy = opts.interval;
                        cols = Math.round( w / dx ) - 1;
                        rows = Math.round( h / dy ) - 1;
                        x0 = bbox[ 0 ] + ( w - cols * dx ) / 2;
                        y0 = bbox[ 1 ] + ( h - rows * dy ) / 2
                    } else if ( opts.rows > 0 && opts.cols > 0 ) {
                        cols = opts.cols;
                        rows = opts.rows;
                        dx = w / cols;
                        dy = h / rows;
                        x0 = bbox[ 0 ] + dx / 2;
                        y0 = bbox[ 1 ] + dy / 2
                    }
                    if ( dx > 0 === false || dy > 0 === false ) {
                        stop( "[point-grid] Invalid grid parameters" )
                    }
                    y = y0;
                    while ( y <= bbox[ 3 ] ) {
                        x = x0;
                        while ( x <= bbox[ 2 ] ) {
                            points.push( [ [ x, y ] ] );
                            x += dx
                        }
                        y += dy
                    }
                    return {
                        geometry_type: "point",
                        shapes: points
                    }
                };
                MapShaper.editArcs = function( arcs, onPoint ) {
                    var nn2 = [],
                        xx2 = [],
                        yy2 = [],
                        n;
                    arcs.forEach( function( arc, i ) {
                        editArc( arc, onPoint )
                    } );
                    arcs.updateVertexData( nn2, xx2, yy2 );

                    function append( p ) {
                        xx2.push( p[ 0 ] );
                        yy2.push( p[ 1 ] );
                        n++
                    }

                    function editArc( arc, cb ) {
                        var x, y, xp, yp;
                        var i = 0;
                        n = 0;
                        while ( arc.hasNext() ) {
                            x = arc.x;
                            y = arc.y;
                            cb( append, x, y, xp, yp, i++ );
                            xp = x;
                            yp = y
                        }
                        if ( n == 1 ) {
                            error( "An invalid arc was created" )
                        }
                        nn2.push( n )
                    }
                };
                api.proj = function( dataset, opts ) {
                    var useCopy = !!api.gui;
                    var target, src, dest, defn;
                    if ( opts && opts.from ) {
                        src = MapShaper.getProjection( opts.from, opts );
                        if ( !src ) {
                            stop( "[proj] Unknown source projection:", opts.from )
                        }
                    } else {
                        src = MapShaper.getDatasetProjection( dataset );
                        if ( !src ) {
                            stop( "[proj] Unable to project -- source coordinate system is unknown" )
                        }
                    }
                    dest = MapShaper.getProjection( opts.projection, opts );
                    if ( !dest ) {
                        stop( "[proj] Unknown projection:", opts.projection )
                    }
                    if ( useCopy ) {
                        target = {};
                        if ( dataset.arcs ) {
                            target.arcs = dataset.arcs.getCopy()
                        }
                        target.layers = dataset.layers.map( function( lyr ) {
                            if ( MapShaper.layerHasPoints( lyr ) ) {
                                lyr = utils.extend( {}, lyr );
                                lyr.shapes = MapShaper.cloneShapes( lyr.shapes )
                            }
                            return lyr
                        } )
                    } else {
                        target = dataset
                    }
                    try {
                        MapShaper.projectDataset( target, src, dest, opts )
                    } catch ( e ) {
                        stop( utils.format( "[proj] Projection failure%s (%s)", e.point ? " at " + e.point.join( " " ) : "", e.message ) )
                    }
                    if ( useCopy ) {
                        dataset.arcs = target.arcs;
                        dataset.layers = target.layers
                    }
                    if ( dataset.info ) {
                        dataset.info.crs = dest
                    }
                };
                MapShaper.projectDataset = function( dataset, src, dest, opts ) {
                    var proj = MapShaper.getProjTransform( src, dest );
                    dataset.layers.forEach( function( lyr ) {
                        if ( MapShaper.layerHasPoints( lyr ) ) {
                            MapShaper.projectPointLayer( lyr, proj )
                        }
                    } );
                    if ( dataset.arcs ) {
                        if ( opts.densify ) {
                            MapShaper.projectAndDensifyArcs( dataset.arcs, proj )
                        } else {
                            MapShaper.projectArcs( dataset.arcs, proj )
                        }
                    }
                };
                MapShaper.getProjTransform = function( src, dest ) {
                    var mproj = require( "mproj" );
                    var clampSrc = src.is_latlong;
                    return function( x, y ) {
                        var xy;
                        if ( clampSrc ) {
                            if ( x < -180 ) x = -180;
                            else if ( x > 180 ) x = 180
                        }
                        xy = [ x, y ];
                        mproj.pj_transform_point( src, dest, xy );
                        return xy
                    }
                };
                MapShaper.projectPointLayer = function( lyr, proj ) {
                    MapShaper.forEachPoint( lyr.shapes, function( p ) {
                        var p2 = proj( p[ 0 ], p[ 1 ] );
                        p[ 0 ] = p2[ 0 ];
                        p[ 1 ] = p2[ 1 ]
                    } )
                };
                MapShaper.projectArcs = function( arcs, proj ) {
                    var data = arcs.getVertexData(),
                        xx = data.xx,
                        yy = data.yy,
                        zz = data.zz,
                        p;
                    for ( var i = 0, n = xx.length; i < n; i++ ) {
                        p = proj( xx[ i ], yy[ i ] );
                        xx[ i ] = p[ 0 ];
                        yy[ i ] = p[ 1 ]
                    }
                    arcs.updateVertexData( data.nn, xx, yy, zz )
                };
                MapShaper.getDefaultDensifyInterval = function( arcs, proj ) {
                    var xy = MapShaper.getAvgSegment2( arcs ),
                        bb = arcs.getBounds(),
                        a = proj( bb.centerX(), bb.centerY() ),
                        b = proj( bb.centerX() + xy[ 0 ], bb.centerY() + xy[ 1 ] );
                    return distance2D( a[ 0 ], a[ 1 ], b[ 0 ], b[ 1 ] )
                };
                MapShaper.densifySegment = function( lng0, lat0, x0, y0, lng2, lat2, x2, y2, proj, interval, points ) {
                    var lng1 = ( lng0 + lng2 ) / 2,
                        lat1 = ( lat0 + lat2 ) / 2,
                        p = proj( lng1, lat1 ),
                        distSq = geom.pointSegDistSq( p[ 0 ], p[ 1 ], x0, y0, x2, y2 );
                    points = points || [];
                    if ( distSq > interval * interval * .25 && distance2D( lng0, lat0, lng2, lat2 ) > .01 ) {
                        MapShaper.densifySegment( lng0, lat0, x0, y0, lng1, lat1, p[ 0 ], p[ 1 ], proj, interval, points );
                        points.push( p );
                        MapShaper.densifySegment( lng1, lat1, p[ 0 ], p[ 1 ], lng2, lat2, x2, y2, proj, interval, points )
                    }
                    return points
                };
                MapShaper.projectAndDensifyArcs = function( arcs, proj ) {
                    var interval = MapShaper.getDefaultDensifyInterval( arcs, proj );
                    var p = [ 0, 0 ];
                    MapShaper.editArcs( arcs, onPoint );

                    function onPoint( append, lng, lat, prevLng, prevLat, i ) {
                        var prevX = p[ 0 ],
                            prevY = p[ 1 ];
                        p = proj( lng, lat );
                        if ( i > 0 && distanceSq( p[ 0 ], p[ 1 ], prevX, prevY ) > interval * interval * 25 ) {
                            MapShaper.densifySegment( prevLng, prevLat, prevX, prevY, lng, lat, p[ 0 ], p[ 1 ], proj, interval ).forEach( append )
                        }
                        append( p )
                    }
                };
                api.renameLayers = function( layers, names ) {
                    var nameCount = names && names.length || 0;
                    layers.forEach( function( lyr, i ) {
                        var name;
                        if ( nameCount === 0 ) {
                            name = "layer" + ( i + 1 )
                        } else {
                            name = i < nameCount - 1 ? names[ i ] : names[ nameCount - 1 ];
                            if ( nameCount < layers.length && i >= nameCount - 2 ) {
                                name += i - nameCount + 2
                            }
                        }
                        lyr.name = name
                    } )
                };

                function Heap() {
                    var heapBuf = utils.expandoBuffer( Int32Array ),
                        indexBuf = utils.expandoBuffer( Int32Array ),
                        itemsInHeap = 0,
                        dataArr, heapArr, indexArr;
                    this.init = function( values ) {
                        var i;
                        dataArr = values;
                        itemsInHeap = values.length;
                        heapArr = heapBuf( itemsInHeap );
                        indexArr = indexBuf( itemsInHeap );
                        for ( i = 0; i < itemsInHeap; i++ ) {
                            insertValue( i, i )
                        }
                        for ( i = itemsInHeap - 2 >> 1; i >= 0; i-- ) {
                            downHeap( i )
                        }
                    };
                    this.size = function() {
                        return itemsInHeap
                    };
                    this.updateValue = function( valIdx, val ) {
                        var heapIdx = indexArr[ valIdx ];
                        dataArr[ valIdx ] = val;
                        if ( !( heapIdx >= 0 && heapIdx < itemsInHeap ) ) {
                            error( "Out-of-range heap index." )
                        }
                        downHeap( upHeap( heapIdx ) )
                    };
                    this.popValue = function() {
                        return dataArr[ this.pop() ]
                    };
                    this.pop = function() {
                        var popIdx;
                        if ( itemsInHeap <= 0 ) {
                            error( "Tried to pop from an empty heap." )
                        }
                        popIdx = heapArr[ 0 ];
                        insertValue( 0, heapArr[ --itemsInHeap ] );
                        downHeap( 0 );
                        return popIdx
                    };

                    function upHeap( idx ) {
                        var parentIdx;
                        while ( idx > 0 ) {
                            parentIdx = idx - 1 >> 1;
                            if ( greaterThan( idx, parentIdx ) ) {
                                break
                            }
                            swapItems( idx, parentIdx );
                            idx = parentIdx
                        }
                        return idx
                    }

                    function downHeap( idx ) {
                        var minIdx = compareDown( idx );
                        while ( minIdx > idx ) {
                            swapItems( idx, minIdx );
                            idx = minIdx;
                            minIdx = compareDown( idx )
                        }
                    }

                    function swapItems( a, b ) {
                        var i = heapArr[ a ];
                        insertValue( a, heapArr[ b ] );
                        insertValue( b, i )
                    }

                    function insertValue( heapIdx, valId ) {
                        indexArr[ valId ] = heapIdx;
                        heapArr[ heapIdx ] = valId
                    }

                    function greaterThan( a, b ) {
                        var idx1 = heapArr[ a ],
                            idx2 = heapArr[ b ],
                            val1 = dataArr[ idx1 ],
                            val2 = dataArr[ idx2 ];
                        return val1 > val2 || val1 === val2 && idx1 > idx2
                    }

                    function compareDown( idx ) {
                        var a = 2 * idx + 1,
                            b = a + 1,
                            n = itemsInHeap;
                        if ( a < n && greaterThan( idx, a ) ) {
                            idx = a
                        }
                        if ( b < n && greaterThan( idx, b ) ) {
                            idx = b
                        }
                        return idx
                    }
                }
                var Visvalingam = {};
                Visvalingam.getArcCalculator = function( metric, is3D ) {
                    var heap = new Heap,
                        prevBuf = utils.expandoBuffer( Int32Array ),
                        nextBuf = utils.expandoBuffer( Int32Array ),
                        calc = is3D ? function( b, c, d, xx, yy, zz ) {
                            return metric( xx[ b ], yy[ b ], zz[ b ], xx[ c ], yy[ c ], zz[ c ], xx[ d ], yy[ d ], zz[ d ] )
                        } : function( b, c, d, xx, yy ) {
                            return metric( xx[ b ], yy[ b ], xx[ c ], yy[ c ], xx[ d ], yy[ d ] )
                        };
                    return function calcVisvalingam( kk, xx, yy, zz ) {
                        var arcLen = kk.length,
                            prevArr = prevBuf( arcLen ),
                            nextArr = nextBuf( arcLen ),
                            val, maxVal = -Infinity,
                            b, c, d;
                        if ( zz && !is3D ) {
                            error( "[visvalingam] Received z-axis data for 2D simplification" )
                        } else if ( !zz && is3D ) {
                            error( "[visvalingam] Missing z-axis data for 3D simplification" )
                        } else if ( kk.length > xx.length ) {
                            error( "[visvalingam] Incompatible data arrays:", kk.length, xx.length )
                        }
                        for ( c = 0; c < arcLen; c++ ) {
                            b = c - 1;
                            d = c + 1;
                            if ( b < 0 || d >= arcLen ) {
                                val = Infinity
                            } else {
                                val = calc( b, c, d, xx, yy, zz )
                            }
                            kk[ c ] = val;
                            nextArr[ c ] = d;
                            prevArr[ c ] = b
                        }
                        heap.init( kk );
                        while ( heap.size() > 0 ) {
                            c = heap.pop();
                            val = kk[ c ];
                            if ( val === Infinity ) {
                                break
                            }
                            if ( val < maxVal ) {
                                kk[ c ] = maxVal
                            } else {
                                maxVal = val
                            }
                            b = prevArr[ c ];
                            d = nextArr[ c ];
                            if ( b > 0 ) {
                                val = calc( prevArr[ b ], b, d, xx, yy, zz );
                                heap.updateValue( b, val )
                            }
                            if ( d < arcLen - 1 ) {
                                val = calc( b, d, nextArr[ d ], xx, yy, zz );
                                heap.updateValue( d, val )
                            }
                            nextArr[ b ] = d;
                            prevArr[ d ] = b
                        }
                    }
                };
                Visvalingam.standardMetric = triangleArea;
                Visvalingam.standardMetric3D = triangleArea3D;
                Visvalingam.getWeightedMetric = function( opts ) {
                    var weight = Visvalingam.getWeightFunction( opts );
                    return function( ax, ay, bx, by, cx, cy ) {
                        var area = triangleArea( ax, ay, bx, by, cx, cy ),
                            cos = cosine( ax, ay, bx, by, cx, cy );
                        return weight( cos ) * area
                    }
                };
                Visvalingam.getWeightedMetric3D = function( opts ) {
                    var weight = Visvalingam.getWeightFunction( opts );
                    return function( ax, ay, az, bx, by, bz, cx, cy, cz ) {
                        var area = triangleArea3D( ax, ay, az, bx, by, bz, cx, cy, cz ),
                            cos = cosine3D( ax, ay, az, bx, by, bz, cx, cy, cz );
                        return weight( cos ) * area
                    }
                };
                Visvalingam.getWeightCoefficient = function( opts ) {
                    return opts && utils.isNumber( opts && opts.weighting ) ? opts.weighting : .7
                };
                Visvalingam.getWeightFunction = function( opts ) {
                    var k = Visvalingam.getWeightCoefficient( opts );
                    return function( cos ) {
                        return -cos * k + 1
                    }
                };
                Visvalingam.weight = function( cos ) {
                    var k = .7;
                    return -cos * k + 1
                };
                Visvalingam.getEffectiveAreaSimplifier = function( use3D ) {
                    var metric = use3D ? Visvalingam.standardMetric3D : Visvalingam.standardMetric;
                    return Visvalingam.getPathSimplifier( metric, use3D )
                };
                Visvalingam.getWeightedSimplifier = function( opts, use3D ) {
                    var metric = use3D ? Visvalingam.getWeightedMetric3D( opts ) : Visvalingam.getWeightedMetric( opts );
                    return Visvalingam.getPathSimplifier( metric, use3D )
                };
                Visvalingam.getPathSimplifier = function( metric, use3D ) {
                    return Visvalingam.scaledSimplify( Visvalingam.getArcCalculator( metric, use3D ) )
                };
                Visvalingam.scaledSimplify = function( f ) {
                    return function( kk, xx, yy, zz ) {
                        f( kk, xx, yy, zz );
                        for ( var i = 1, n = kk.length - 1; i < n; i++ ) {
                            kk[ i ] = Math.sqrt( kk[ i ] ) * .65
                        }
                    }
                };
                var DouglasPeucker = {};
                DouglasPeucker.metricSq3D = geom.pointSegDistSq3D;
                DouglasPeucker.metricSq = geom.pointSegDistSq;
                DouglasPeucker.calcArcData = function( dest, xx, yy, zz ) {
                    var len = dest.length,
                        useZ = !!zz;
                    dest[ 0 ] = dest[ len - 1 ] = Infinity;
                    if ( len > 2 ) {
                        procSegment( 0, len - 1, 1, Number.MAX_VALUE )
                    }

                    function procSegment( startIdx, endIdx, depth, distSqPrev ) {
                        var ax = xx[ startIdx ],
                            ay = yy[ startIdx ],
                            cx = xx[ endIdx ],
                            cy = yy[ endIdx ],
                            az, cz;
                        if ( useZ ) {
                            az = zz[ startIdx ];
                            cz = zz[ endIdx ]
                        }
                        var maxDistSq = 0,
                            maxIdx = 0,
                            distSqLeft = 0,
                            distSqRight = 0,
                            distSq;
                        for ( var i = startIdx + 1; i < endIdx; i++ ) {
                            if ( useZ ) {
                                distSq = DouglasPeucker.metricSq3D( xx[ i ], yy[ i ], zz[ i ], ax, ay, az, cx, cy, cz )
                            } else {
                                distSq = DouglasPeucker.metricSq( xx[ i ], yy[ i ], ax, ay, cx, cy )
                            }
                            if ( distSq >= maxDistSq ) {
                                maxDistSq = distSq;
                                maxIdx = i
                            }
                        }
                        if ( distSqPrev < maxDistSq ) {
                            maxDistSq = distSqPrev
                        }
                        if ( maxIdx - startIdx > 1 ) {
                            distSqLeft = procSegment( startIdx, maxIdx, depth + 1, maxDistSq )
                        }
                        if ( endIdx - maxIdx > 1 ) {
                            distSqRight = procSegment( maxIdx, endIdx, depth + 1, maxDistSq )
                        }
                        if ( depth == 1 && ax == cx && ay == cy ) {
                            maxDistSq = Math.max( distSqLeft, distSqRight )
                        }
                        dest[ maxIdx ] = Math.sqrt( maxDistSq );
                        return maxDistSq
                    }
                };
                MapShaper.postSimplifyRepair = function( arcs ) {
                    var intersections = MapShaper.findSegmentIntersections( arcs ),
                        unfixable = MapShaper.repairIntersections( arcs, intersections ),
                        countPre = intersections.length,
                        countPost = unfixable.length,
                        countFixed = countPre > countPost ? countPre - countPost : 0,
                        msg;
                    if ( countPre > 0 ) {
                        msg = utils.format( "[simplify] Repaired %'i intersection%s", countFixed, utils.pluralSuffix( countFixed ) );
                        if ( countPost > 0 ) {
                            msg += utils.format( "; %'i intersection%s could not be repaired", countPost, utils.pluralSuffix( countPost ) )
                        }
                        message( msg )
                    }
                };
                MapShaper.repairIntersections = function( arcs, intersections ) {
                    while ( MapShaper.unwindIntersections( arcs, intersections ) > 0 ) {
                        intersections = MapShaper.findSegmentIntersections( arcs )
                    }
                    return intersections
                };
                MapShaper.unwindIntersections = function( arcs, intersections ) {
                    var data = arcs.getVertexData(),
                        zlim = arcs.getRetainedInterval(),
                        changes = 0,
                        loops = 0,
                        replacements, queue, target, i;
                    queue = MapShaper.getUnwindTargets( intersections, zlim, data.zz );
                    utils.sortOn( queue, "z", !!"ascending" );
                    while ( queue.length > 0 ) {
                        target = queue.pop();
                        replacements = MapShaper.redetectIntersectionTarget( target, zlim, data.xx, data.yy, data.zz );
                        if ( replacements.length == 1 ) {
                            replacements = MapShaper.unwindIntersection( replacements[ 0 ], zlim, data.zz );
                            changes++
                        } else {}
                        for ( i = 0; i < replacements.length; i++ ) {
                            MapShaper.insertUnwindTarget( queue, replacements[ i ] )
                        }
                    }
                    if ( ++loops > 5e5 ) {
                        verbose( "Caught an infinite loop at intersection:", target );
                        return 0
                    }
                    return changes
                };
                MapShaper.getUnwindTargets = function( intersections, zlim, zz ) {
                    return intersections.reduce( function( memo, o ) {
                        var target = MapShaper.getUnwindTarget( o, zlim, zz );
                        if ( target !== null ) {
                            memo.push( target )
                        }
                        return memo
                    }, [] )
                };
                MapShaper.getUnwindTarget = function( o, zlim, zz ) {
                    var ai = MapShaper.findNextRemovableVertex( zz, zlim, o.a[ 0 ], o.a[ 1 ] ),
                        bi = MapShaper.findNextRemovableVertex( zz, zlim, o.b[ 0 ], o.b[ 1 ] ),
                        targ;
                    if ( ai == -1 && bi == -1 ) {
                        targ = null
                    } else if ( bi == -1 || ai != -1 && zz[ ai ] > zz[ bi ] ) {
                        targ = {
                            a: o.a,
                            b: o.b,
                            z: zz[ ai ]
                        }
                    } else {
                        targ = {
                            a: o.b,
                            b: o.a,
                            z: zz[ bi ]
                        }
                    }
                    return targ
                };
                MapShaper.insertUnwindTarget = function( arr, obj ) {
                    var ins = arr.length;
                    while ( ins > 0 ) {
                        if ( arr[ ins - 1 ].z <= obj.z ) {
                            break
                        }
                        arr[ ins ] = arr[ ins - 1 ];
                        ins--
                    }
                    arr[ ins ] = obj
                };
                MapShaper.unwindIntersection = function( target, zlim, zz ) {
                    var replacements = [];
                    var start = target.a[ 0 ],
                        end = target.a[ 1 ],
                        z = target.z;
                    for ( var i = start + 1; i <= end; i++ ) {
                        if ( zz[ i ] == z || i == end ) {
                            replacements.push( {
                                a: [ start, i ],
                                b: target.b,
                                z: z
                            } );
                            if ( i != end ) zz[ i ] = zlim;
                            start = i
                        }
                    }
                    if ( replacements.length < 2 ) error( "Error in unwindIntersection()" );
                    return replacements
                };
                MapShaper.redetectIntersectionTarget = function( targ, zlim, xx, yy, zz ) {
                    var segIds = MapShaper.getIntersectionCandidates( targ, zlim, xx, yy, zz );
                    var intersections = MapShaper.intersectSegments( segIds, xx, yy );
                    return MapShaper.getUnwindTargets( intersections, zlim, zz )
                };
                MapShaper.getIntersectionCandidates = function( o, zlim, xx, yy, zz ) {
                    var segIds = MapShaper.getSegmentVertices( o.a, zlim, xx, yy, zz );
                    segIds = segIds.concat( MapShaper.getSegmentVertices( o.b, zlim, xx, yy, zz ) );
                    return segIds
                };
                MapShaper.getSegmentVertices = function( seg, zlim, xx, yy, zz ) {
                    var start, end, prev, ids = [];
                    if ( seg[ 0 ] <= seg[ 1 ] ) {
                        start = seg[ 0 ];
                        end = seg[ 1 ]
                    } else {
                        start = seg[ 1 ];
                        end = seg[ 0 ]
                    }
                    prev = start;
                    for ( var i = start + 1; i <= end; i++ ) {
                        if ( zz[ i ] >= zlim ) {
                            if ( xx[ prev ] < xx[ i ] ) {
                                ids.push( prev, i )
                            } else {
                                ids.push( i, prev )
                            }
                            prev = i
                        }
                    }
                    return ids
                };
                MapShaper.calcSimplifyStats = function( arcs, use3D ) {
                    var distSq = use3D ? pointSegGeoDistSq : geom.pointSegDistSq,
                        calcAngle = use3D ? geom.signedAngleSph : geom.signedAngle,
                        removed = 0,
                        retained = 0,
                        collapsedRings = 0,
                        max = 0,
                        sum = 0,
                        sumSq = 0,
                        iprev = -1,
                        jprev = -1,
                        measures = [],
                        angles = [],
                        zz = arcs.getVertexData().zz,
                        count, stats;
                    arcs.forEachSegment( function( i, j, xx, yy ) {
                        var ax, ay, bx, by, d2, d, skipped, angle, tmp;
                        ax = xx[ i ];
                        ay = yy[ i ];
                        bx = xx[ j ];
                        by = yy[ j ];
                        if ( i == jprev ) {
                            angle = calcAngle( xx[ iprev ], yy[ iprev ], ax, ay, bx, by );
                            if ( angle > Math.PI ) angle = 2 * Math.PI - angle;
                            if ( !isNaN( angle ) ) {
                                angles.push( angle * 180 / Math.PI )
                            }
                        }
                        iprev = i;
                        jprev = j;
                        if ( zz[ i ] < Infinity ) {
                            retained++
                        }
                        skipped = j - i - 1;
                        if ( skipped < 1 ) return;
                        removed += skipped;
                        if ( ax == bx && ay == by ) {
                            collapsedRings++
                        } else {
                            d2 = 0;
                            while ( ++i < j ) {
                                tmp = distSq( xx[ i ], yy[ i ], ax, ay, bx, by );
                                d2 = Math.max( d2, tmp )
                            }
                            sumSq += d2;
                            d = Math.sqrt( d2 );
                            sum += d;
                            measures.push( d );
                            max = Math.max( max, d )
                        }
                    } );

                    function pointSegGeoDistSq( alng, alat, blng, blat, clng, clat ) {
                        var xx = [],
                            yy = [],
                            zz = [];
                        geom.convLngLatToSph( [ alng, blng, clng ], [ alat, blat, clat ], xx, yy, zz );
                        return geom.pointSegDistSq3D( xx[ 0 ], yy[ 0 ], zz[ 0 ], xx[ 1 ], yy[ 1 ], zz[ 1 ], xx[ 2 ], yy[ 2 ], zz[ 2 ] )
                    }
                    stats = {
                        angleMean: 0,
                        displacementMean: 0,
                        displacementMax: max,
                        collapsedRings: collapsedRings,
                        removed: removed,
                        retained: retained,
                        uniqueCount: MapShaper.countUniqueVertices( arcs ),
                        removableCount: removed + retained
                    };
                    if ( angles.length > 0 ) {
                        stats.angleMean = utils.sum( angles ) / angles.length;
                        stats.angleQuartiles = [ utils.findValueByPct( angles, .75 ), utils.findValueByPct( angles, .5 ), utils.findValueByPct( angles, .25 ) ]
                    }
                    if ( measures.length > 0 ) {
                        stats.displacementMean = sum / measures.length;
                        stats.displacementQuartiles = [ utils.findValueByPct( measures, .75 ), utils.findValueByPct( measures, .5 ), utils.findValueByPct( measures, .25 ) ]
                    }
                    return stats
                };
                MapShaper.countUniqueVertices = function( arcs ) {
                    var endpoints = arcs.size() * 2;
                    var nodes = new NodeCollection( arcs ).size();
                    return arcs.getPointCount() - endpoints + nodes
                };
                MapShaper.getSimplifyMethodLabel = function( slug ) {
                    return {
                        dp: "Ramer-Douglas-Peucker",
                        visvalingam: "Visvalingam",
                        weighted_visvalingam: "Weighted Visvalingam"
                    }[ slug ] || "Unknown"
                };
                MapShaper.printSimplifyInfo = function( arcs, opts ) {
                    var method = MapShaper.getSimplifyMethod( opts );
                    var name = MapShaper.getSimplifyMethodLabel( method );
                    var spherical = MapShaper.useSphericalSimplify( arcs, opts );
                    var stats = MapShaper.calcSimplifyStats( arcs, spherical );
                    var pct1 = ( stats.removed + stats.collapsedRings ) / stats.uniqueCount || 0;
                    var pct2 = stats.removed / stats.removableCount || 0;
                    var aq = stats.angleQuartiles;
                    var dq = stats.displacementQuartiles;
                    var lines = [ "Simplification statistics" ];
                    lines.push( utils.format( "Method: %s (%s) %s", name, spherical ? "spherical" : "planar", method == "weighted_visvalingam" ? "(weighting=" + Visvalingam.getWeightCoefficient( opts ) + ")" : "" ) );
                    lines.push( utils.format( "Removed vertices: %,d", stats.removed + stats.collapsedRings ) );
                    lines.push( utils.format( "   %.1f% of %,d unique coordinate locations", pct1 * 100, stats.uniqueCount ) );
                    lines.push( utils.format( "   %.1f% of %,d filterable coordinate locations", pct2 * 100, stats.removableCount ) );
                    lines.push( utils.format( "Simplification threshold: %.4f %s", arcs.getRetainedInterval(), spherical ? "meters" : "" ) );
                    lines.push( utils.format( "Collapsed rings: %,d", stats.collapsedRings ) );
                    lines.push( "Displacement statistics" );
                    lines.push( utils.format( "   Mean displacement: %.4f", stats.displacementMean ) );
                    lines.push( utils.format( "   Max displacement: %.4f", stats.displacementMax ) );
                    if ( dq ) {
                        lines.push( utils.format( "   Quartiles: %.2f, %.2f, %.2f", dq[ 0 ], dq[ 1 ], dq[ 2 ] ) )
                    }
                    lines.push( "Vertex angle statistics" );
                    lines.push( utils.format( "   Mean angle: %.2f degrees", stats.angleMean ) );
                    if ( aq ) {
                        lines.push( utils.format( "   Quartiles: %.2f, %.2f, %.2f", aq[ 0 ], aq[ 1 ], aq[ 2 ] ) )
                    }
                    message( lines.join( "\n   " ) )
                };
                api.simplify = function( dataset, opts ) {
                    var arcs = dataset.arcs;
                    if ( !arcs ) stop( "[simplify] Missing path data" );
                    opts = MapShaper.getStandardSimplifyOpts( dataset, opts );
                    dataset.info = utils.defaults( {
                        simplify: opts
                    }, dataset.info );
                    MapShaper.simplifyPaths( arcs, opts );
                    if ( utils.isNumber( opts.pct ) ) {
                        arcs.setRetainedPct( opts.pct )
                    } else if ( utils.isNumber( opts.interval ) ) {
                        arcs.setRetainedInterval( opts.interval )
                    } else if ( opts.resolution ) {
                        arcs.setRetainedInterval( MapShaper.calcSimplifyInterval( arcs, opts ) )
                    }
                    if ( opts.keep_shapes ) {
                        api.keepEveryPolygon( arcs, dataset.layers )
                    }
                    if ( !opts.no_repair && arcs.getRetainedInterval() > 0 ) {
                        MapShaper.postSimplifyRepair( arcs )
                    }
                    if ( opts.stats ) {
                        MapShaper.printSimplifyInfo( arcs, opts )
                    }
                };
                MapShaper.getStandardSimplifyOpts = function( dataset, opts ) {
                    opts = opts || {};
                    return utils.defaults( {
                        method: MapShaper.getSimplifyMethod( opts ),
                        spherical: MapShaper.useSphericalSimplify( dataset.arcs, opts )
                    }, opts )
                };
                MapShaper.useSphericalSimplify = function( arcs, opts ) {
                    return !opts.planar && !arcs.isPlanar()
                };
                MapShaper.simplifyPaths = function( arcs, opts ) {
                    var simplifyPath = MapShaper.getSimplifyFunction( opts );
                    arcs.setThresholds( new Float64Array( arcs.getPointCount() ) );
                    if ( opts.spherical ) {
                        MapShaper.simplifyPaths3D( arcs, simplifyPath );
                        MapShaper.protectWorldEdges( arcs )
                    } else {
                        MapShaper.simplifyPaths2D( arcs, simplifyPath )
                    }
                    if ( opts.lock_box ) {
                        MapShaper.protectContentEdges( arcs )
                    }
                };
                MapShaper.simplifyPaths2D = function( arcs, simplify ) {
                    arcs.forEach3( function( xx, yy, kk, i ) {
                        simplify( kk, xx, yy )
                    } )
                };
                MapShaper.simplifyPaths3D = function( arcs, simplify ) {
                    var xbuf = utils.expandoBuffer( Float64Array ),
                        ybuf = utils.expandoBuffer( Float64Array ),
                        zbuf = utils.expandoBuffer( Float64Array );
                    arcs.forEach3( function( xx, yy, kk, i ) {
                        var n = xx.length,
                            xx2 = xbuf( n ),
                            yy2 = ybuf( n ),
                            zz2 = zbuf( n );
                        geom.convLngLatToSph( xx, yy, xx2, yy2, zz2 );
                        simplify( kk, xx2, yy2, zz2 )
                    } )
                };
                MapShaper.getSimplifyMethod = function( opts ) {
                    var m = opts.method;
                    if ( !m || m == "weighted" || m == "visvalingam" && opts.weighting ) {
                        m = "weighted_visvalingam"
                    }
                    return m
                };
                MapShaper.getSimplifyFunction = function( opts ) {
                    var f;
                    if ( opts.method == "dp" ) {
                        f = DouglasPeucker.calcArcData
                    } else if ( opts.method == "visvalingam" ) {
                        f = Visvalingam.getEffectiveAreaSimplifier( opts.spherical )
                    } else if ( opts.method == "weighted_visvalingam" ) {
                        f = Visvalingam.getWeightedSimplifier( opts, opts.spherical )
                    } else {
                        stop( "[simplify] Unsupported simplify method:", method )
                    }
                    return f
                };
                MapShaper.protectContentEdges = function( arcs ) {
                    var e = 1e-14;
                    var bb = arcs.getBounds();
                    bb.padBounds( -e, -e, -e, -e );
                    MapShaper.limitSimplificationExtent( arcs, bb.toArray(), true )
                };
                MapShaper.limitSimplificationExtent = function( arcs, bb, hardLimit ) {
                    var arcBounds = arcs.getBounds().toArray();
                    if ( containsBounds( bb, arcBounds ) === true ) return;
                    arcs.forEach3( function( xx, yy, zz ) {
                        var lockZ = hardLimit ? Infinity : 0,
                            x, y;
                        for ( var i = 0, n = zz.length; i < n; i++ ) {
                            x = xx[ i ];
                            y = yy[ i ];
                            if ( x >= bb[ 2 ] || x <= bb[ 0 ] || y <= bb[ 1 ] || y >= bb[ 3 ] ) {
                                if ( lockZ === 0 ) {
                                    lockZ = MapShaper.findMaxThreshold( zz )
                                }
                                if ( zz[ i ] !== Infinity ) {
                                    zz[ i ] = lockZ
                                }
                            }
                        }
                    } )
                };
                MapShaper.protectWorldEdges = function( arcs ) {
                    MapShaper.limitSimplificationExtent( arcs, MapShaper.getWorldBounds( 1e-12 ), false )
                };
                MapShaper.findMaxThreshold = function( zz ) {
                    var z, maxZ = 0;
                    for ( var i = 0, n = zz.length; i < n; i++ ) {
                        z = zz[ i ];
                        if ( z > maxZ && z < Infinity ) {
                            maxZ = z
                        }
                    }
                    return maxZ
                };
                MapShaper.parseSimplifyResolution = function( raw ) {
                    var parts, w, h;
                    if ( utils.isNumber( raw ) ) {
                        w = raw;
                        h = raw
                    } else if ( utils.isString( raw ) ) {
                        parts = raw.split( "x" );
                        w = Number( parts[ 0 ] ) || 0;
                        h = parts.length == 2 ? Number( parts[ 1 ] ) || 0 : w
                    }
                    if ( !( w >= 0 && h >= 0 && w + h > 0 ) ) {
                        stop( "Invalid simplify resolution:", raw )
                    }
                    return [ w, h ]
                };
                MapShaper.calcPlanarInterval = function( xres, yres, width, height ) {
                    var fitWidth = xres !== 0 && width / height > xres / yres || yres === 0;
                    return fitWidth ? width / xres : height / yres
                };
                MapShaper.calcSphericalInterval = function( xres, yres, bounds ) {
                    var width = geom.degreesToMeters( bounds.width() ) * Math.cos( bounds.centerY() * geom.D2R );
                    var height = geom.degreesToMeters( bounds.height() );
                    return MapShaper.calcPlanarInterval( xres, yres, width, height )
                };
                MapShaper.calcSimplifyInterval = function( arcs, opts ) {
                    var res, interval, bounds;
                    if ( opts.interval ) {
                        interval = opts.interval
                    } else if ( opts.resolution ) {
                        res = MapShaper.parseSimplifyResolution( opts.resolution );
                        bounds = arcs.getBounds();
                        if ( MapShaper.useSphericalSimplify( arcs, opts ) ) {
                            interval = MapShaper.calcSphericalInterval( res[ 0 ], res[ 1 ], bounds )
                        } else {
                            interval = MapShaper.calcPlanarInterval( res[ 0 ], res[ 1 ], bounds.width(), bounds.height() )
                        }
                        interval *= .5
                    }
                    return interval
                };
                api.splitLayerOnGrid = function( lyr, arcs, opts ) {
                    var shapes = lyr.shapes,
                        type = lyr.geometry_type,
                        setId = !!opts.id_field,
                        fieldName = opts.id_field || "__split__",
                        classify = getShapeClassifier( MapShaper.getLayerBounds( lyr, arcs ), opts.cols, opts.rows ),
                        properties, layers;
                    if ( !type ) {
                        stop( "[split-on-grid] Layer has no geometry" )
                    }
                    if ( !lyr.data ) {
                        lyr.data = new DataTable( shapes.length )
                    }
                    properties = lyr.data.getRecords();
                    lyr.shapes.forEach( function( shp, i ) {
                        var bounds = type == "point" ? MapShaper.getPointBounds( [ shp ] ) : arcs.getMultiShapeBounds( shp );
                        var name = bounds.hasBounds() ? classify( bounds ) : "";
                        var rec = properties[ i ] = properties[ i ] || {};
                        rec[ fieldName ] = name
                    } );
                    if ( setId ) return lyr;
                    return api.splitLayer( lyr, fieldName ).filter( function( lyr ) {
                        var name = lyr.data.getRecordAt( 0 )[ fieldName ];
                        lyr.name = name;
                        lyr.data.deleteField( fieldName );
                        return !!name
                    } );

                    function getShapeClassifier( bounds, cols, rows ) {
                        var xmin = bounds.xmin,
                            ymin = bounds.ymin,
                            w = bounds.width(),
                            h = bounds.height();
                        if ( rows > 0 === false || cols > 0 === false ) {
                            stop( "[split-on-grid] Invalid grid parameters" )
                        }
                        if ( w > 0 === false || h > 0 === false ) {
                            cols = 1;
                            rows = 1
                        }
                        return function( bounds ) {
                            var c = Math.floor( ( bounds.centerX() - xmin ) / w * cols ),
                                r = Math.floor( ( bounds.centerY() - ymin ) / h * rows );
                            c = utils.clamp( c, 0, cols - 1 ) || 0;
                            r = utils.clamp( r, 0, rows - 1 ) || 0;
                            return "r" + r + "c" + c
                        }
                    }
                };
                api.subdivideLayer = function( lyr, arcs, exp ) {
                    return MapShaper.subdivide( lyr, arcs, exp )
                };
                MapShaper.subdivide = function( lyr, arcs, exp ) {
                    var divide = MapShaper.evalCalcExpression( lyr, arcs, exp ),
                        subdividedLayers = [],
                        tmp, bounds, lyr1, lyr2;
                    if ( !utils.isBoolean( divide ) ) {
                        stop( "[subdivide] Expression must evaluate to true or false" )
                    }
                    if ( divide ) {
                        bounds = MapShaper.getLayerBounds( lyr, arcs );
                        tmp = MapShaper.divideLayer( lyr, arcs, bounds );
                        lyr1 = tmp[ 0 ];
                        if ( lyr1.shapes.length > 1 && lyr1.shapes.length < lyr.shapes.length ) {
                            utils.merge( subdividedLayers, MapShaper.subdivide( lyr1, arcs, exp ) )
                        } else {
                            subdividedLayers.push( lyr1 )
                        }
                        lyr2 = tmp[ 1 ];
                        if ( lyr2.shapes.length > 1 && lyr2.shapes.length < lyr.shapes.length ) {
                            utils.merge( subdividedLayers, MapShaper.subdivide( lyr2, arcs, exp ) )
                        } else {
                            subdividedLayers.push( lyr2 )
                        }
                    } else {
                        subdividedLayers.push( lyr )
                    }
                    subdividedLayers.forEach( function( lyr2, i ) {
                        lyr2.name = MapShaper.getSplitLayerName( lyr.name || "split", i + 1 );
                        utils.defaults( lyr2, lyr )
                    } );
                    return subdividedLayers
                };
                MapShaper.divideLayer = function( lyr, arcs, bounds ) {
                    var properties = lyr.data ? lyr.data.getRecords() : null,
                        shapes = lyr.shapes,
                        lyr1, lyr2;
                    lyr1 = {
                        geometry_type: lyr.geometry_type,
                        shapes: [],
                        data: properties ? [] : null
                    };
                    lyr2 = {
                        geometry_type: lyr.geometry_type,
                        shapes: [],
                        data: properties ? [] : null
                    };
                    var useX = bounds && bounds.width() > bounds.height();
                    var centers = shapes.map( function( shp ) {
                        var bounds = arcs.getMultiShapeBounds( shp );
                        return useX ? bounds.centerX() : bounds.centerY()
                    } );
                    var ids = utils.range( centers.length );
                    ids.sort( function( a, b ) {
                        return centers[ a ] - centers[ b ]
                    } );
                    ids.forEach( function( shapeId, i ) {
                        var dest = i < shapes.length / 2 ? lyr1 : lyr2;
                        dest.shapes.push( shapes[ shapeId ] );
                        if ( properties ) {
                            dest.data.push( properties[ shapeId ] )
                        }
                    } );
                    if ( properties ) {
                        lyr1.data = new DataTable( lyr1.data );
                        lyr2.data = new DataTable( lyr2.data )
                    }
                    return [ lyr1, lyr2 ]
                };
                api.sortFeatures = function( lyr, arcs, opts ) {
                    var n = MapShaper.getFeatureCount( lyr ),
                        ascending = !opts.descending,
                        compiled = MapShaper.compileValueExpression( opts.expression, lyr, arcs ),
                        values = [];
                    utils.repeat( n, function( i ) {
                        values.push( compiled( i ) )
                    } );
                    var ids = utils.getSortedIds( values, ascending );
                    if ( lyr.shapes ) {
                        utils.reorderArray( lyr.shapes, ids )
                    }
                    if ( lyr.data ) {
                        utils.reorderArray( lyr.data.getRecords(), ids )
                    }
                };
                api.uniq = function( lyr, arcs, opts ) {
                    var n = MapShaper.getFeatureCount( lyr ),
                        compiled = MapShaper.compileValueExpression( opts.expression, lyr, arcs ),
                        index = {},
                        flags = [],
                        f = function( d, i ) {
                            return !flags[ i ]
                        };
                    utils.repeat( n, function( i ) {
                        var val = compiled( i );
                        flags[ i ] = val in index;
                        index[ val ] = true
                    } );
                    if ( lyr.shapes ) {
                        lyr.shapes = lyr.shapes.filter( f )
                    }
                    if ( lyr.data ) {
                        lyr.data = new DataTable( lyr.data.getRecords().filter( f ) )
                    }
                    if ( opts.verbose !== false ) {
                        message( utils.format( "[uniq] Retained %,d of %,d features", MapShaper.getFeatureCount( lyr ), n ) )
                    }
                };
                api.runCommand = function( cmd, dataset, cb ) {
                    var name = cmd.name,
                        opts = cmd.options,
                        targetLayers, outputLayers, outputFiles, arcs;
                    try {
                        T.start();
                        if ( dataset ) {
                            arcs = dataset.arcs;
                            if ( dataset.layers.length > 0 === false ) {
                                error( "Dataset contains 0 layers" )
                            }
                            if ( opts.target ) {
                                targetLayers = MapShaper.findMatchingLayers( dataset.layers, opts.target );
                                if ( !targetLayers.length ) {
                                    stop( utils.format( "[%s] Missing target layer: %s\nAvailable layers: %s", name, opts.target, MapShaper.getFormattedLayerList( dataset.layers ) ) )
                                }
                            } else {
                                targetLayers = dataset.layers
                            }
                        } else {
                            if ( !( name == "graticule" || name == "i" || name == "point-grid" ) ) {
                                throw new APIError( "Missing a -i command" )
                            }
                        }
                        if ( name == "cluster" ) {
                            MapShaper.applyCommand( api.cluster, targetLayers, arcs, opts )
                        } else if ( name == "calc" ) {
                            MapShaper.applyCommand( api.calc, targetLayers, arcs, opts )
                        } else if ( name == "clean" ) {
                            api.cleanLayers( targetLayers, dataset, opts )
                        } else if ( name == "clip" ) {
                            api.clipLayers( targetLayers, opts.source, dataset, opts )
                        } else if ( name == "dissolve" ) {
                            outputLayers = MapShaper.applyCommand( api.dissolve, targetLayers, arcs, opts )
                        } else if ( name == "dissolve2" ) {
                            outputLayers = api.dissolve2( targetLayers, dataset, opts )
                        } else if ( name == "each" ) {
                            MapShaper.applyCommand( api.evaluateEachFeature, targetLayers, arcs, opts.expression, opts )
                        } else if ( name == "erase" ) {
                            api.eraseLayers( targetLayers, opts.source, dataset, opts )
                        } else if ( name == "explode" ) {
                            outputLayers = MapShaper.applyCommand( api.explodeFeatures, targetLayers, arcs, opts )
                        } else if ( name == "filter" ) {
                            outputLayers = MapShaper.applyCommand( api.filterFeatures, targetLayers, arcs, opts )
                        } else if ( name == "filter-fields" ) {
                            MapShaper.applyCommand( api.filterFields, targetLayers, opts.fields )
                        } else if ( name == "filter-islands" ) {
                            MapShaper.applyCommand( api.filterIslands, targetLayers, arcs, opts )
                        } else if ( name == "filter-slivers" ) {
                            MapShaper.applyCommand( api.filterSlivers, targetLayers, arcs, opts )
                        } else if ( name == "graticule" ) {
                            dataset = api.graticule( dataset, opts )
                        } else if ( name == "i" ) {
                            dataset = api.importFiles( cmd.options )
                        } else if ( name == "info" ) {
                            api.printInfo( dataset )
                        } else if ( name == "inspect" ) {
                            MapShaper.applyCommand( api.inspect, targetLayers, arcs, opts )
                        } else if ( name == "innerlines" ) {
                            outputLayers = MapShaper.applyCommand( api.innerlines, targetLayers, arcs, opts )
                        } else if ( name == "join" ) {
                            MapShaper.applyCommand( api.join, targetLayers, dataset, opts )
                        } else if ( name == "lines" ) {
                            outputLayers = MapShaper.applyCommand( api.lines, targetLayers, arcs, opts )
                        } else if ( name == "merge-layers" ) {
                            outputLayers = api.mergeLayers( targetLayers )
                        } else if ( name == "o" ) {
                            outputFiles = MapShaper.exportFileContent( utils.defaults( {
                                layers: targetLayers
                            }, dataset ), opts );
                            if ( opts.final ) {
                                dataset = null
                            }
                            if ( opts.callback ) {
                                opts.callback( outputFiles )
                            } else {
                                return MapShaper.writeFiles( outputFiles, opts, done )
                            }
                        } else if ( name == "point-grid" ) {
                            outputLayers = [ api.pointGrid( dataset, opts ) ];
                            targetLayers = [];
                            if ( !dataset ) {
                                dataset = {
                                    layers: []
                                }
                            }
                        } else if ( name == "points" ) {
                            outputLayers = MapShaper.applyCommand( api.createPointLayer, targetLayers, arcs, opts )
                        } else if ( name == "proj" ) {
                            api.proj( dataset, opts )
                        } else if ( name == "rename-fields" ) {
                            MapShaper.applyCommand( api.renameFields, targetLayers, opts.fields )
                        } else if ( name == "rename-layers" ) {
                            api.renameLayers( targetLayers, opts.names )
                        } else if ( name == "simplify" ) {
                            api.simplify( dataset, opts )
                        } else if ( name == "slice" ) {
                            api.sliceLayers( targetLayers, opts.source, dataset, opts )
                        } else if ( name == "sort" ) {
                            MapShaper.applyCommand( api.sortFeatures, targetLayers, arcs, opts )
                        } else if ( name == "split" ) {
                            outputLayers = MapShaper.applyCommand( api.splitLayer, targetLayers, opts.field, opts )
                        } else if ( name == "split-on-grid" ) {
                            outputLayers = MapShaper.applyCommand( api.splitLayerOnGrid, targetLayers, arcs, opts )
                        } else if ( name == "stitch" ) {
                            api.stitch( dataset )
                        } else if ( name == "subdivide" ) {
                            outputLayers = MapShaper.applyCommand( api.subdivideLayer, targetLayers, arcs, opts.expression )
                        } else if ( name == "svg-style" ) {
                            MapShaper.applyCommand( api.svgStyle, targetLayers, dataset, opts )
                        } else if ( name == "uniq" ) {
                            MapShaper.applyCommand( api.uniq, targetLayers, arcs, opts )
                        } else {
                            error( "Unhandled command: [" + name + "]" )
                        }
                        if ( "name" in opts ) {
                            ( outputLayers || targetLayers || dataset.layers ).forEach( function( lyr ) {
                                lyr.name = opts.name
                            } )
                        }
                        if ( outputLayers ) {
                            if ( opts.no_replace ) {
                                dataset.layers = dataset.layers.concat( outputLayers )
                            } else {
                                MapShaper.replaceLayers( dataset, targetLayers, outputLayers )
                            }
                        }
                    } catch ( e ) {
                        return done( e )
                    }
                    done( null );

                    function done( err ) {
                        T.stop( "-" + name );
                        cb( err, err ? null : dataset )
                    }
                };
                MapShaper.applyCommand = function( func, targetLayers ) {
                    var args = utils.toArray( arguments ).slice( 2 );
                    return targetLayers.reduce( function( memo, lyr ) {
                        var result = func.apply( null, [ lyr ].concat( args ) );
                        if ( utils.isArray( result ) ) {
                            memo = memo.concat( result )
                        } else if ( result ) {
                            memo.push( result )
                        }
                        return memo
                    }, [] )
                };
                MapShaper.getFormattedLayerList = function( layers ) {
                    return layers.reduce( function( memo, lyr, i ) {
                        return memo + "\n  [" + i + "]  " + ( lyr.name || "[unnamed]" )
                    }, "" ) || "[none]"
                };

                function CommandParser() {
                    var commandRxp = /^--?([a-z][\w-]*)$/i,
                        assignmentRxp = /^([a-z0-9_+-]+)=(?!\=)(.*)$/i,
                        _usage = "",
                        _examples = [],
                        _commands = [],
                        _default = null,
                        _note;
                    if ( this instanceof CommandParser === false ) return new CommandParser;
                    this.usage = function( str ) {
                        _usage = str;
                        return this
                    };
                    this.note = function( str ) {
                        _note = str;
                        return this
                    };
                    this.default = function( str ) {
                        _default = str
                    };
                    this.example = function( str ) {
                        _examples.push( str )
                    };
                    this.command = function( name ) {
                        var opts = new CommandOptions( name );
                        _commands.push( opts );
                        return opts
                    };
                    this.parseArgv = function( raw ) {
                        var commandDefs = getCommands(),
                            commands = [],
                            cmd, argv = MapShaper.cleanArgv( raw ),
                            cmdName, cmdDef, opt;
                        if ( argv.length == 1 && tokenIsCommandName( argv[ 0 ] ) ) {
                            argv.unshift( "-help" )
                        } else if ( argv.length > 0 && !tokenLooksLikeCommand( argv[ 0 ] ) && _default ) {
                            argv.unshift( "-" + _default )
                        }
                        while ( argv.length > 0 ) {
                            cmdName = readCommandName( argv );
                            if ( !cmdName ) {
                                stop( "Invalid command:", argv[ 0 ] )
                            }
                            cmdDef = findCommandDefn( cmdName, commandDefs );
                            if ( !cmdDef ) {
                                stop( "Unknown command:", cmdName )
                            }
                            cmd = {
                                name: cmdDef.name,
                                options: {},
                                _: []
                            };
                            while ( argv.length > 0 && !tokenLooksLikeCommand( argv[ 0 ] ) ) {
                                readOption( cmd, argv, cmdDef )
                            }
                            if ( cmdDef.validate ) {
                                try {
                                    cmdDef.validate( cmd )
                                } catch ( e ) {
                                    stop( "[" + cmdName + "] " + e.message )
                                }
                            }
                            commands.push( cmd )
                        }
                        return commands;

                        function tokenIsCommandName( s ) {
                            return !!utils.find( getCommands(), function( cmd ) {
                                return s === cmd.name || s === cmd.alias
                            } )
                        }

                        function tokenLooksLikeCommand( s ) {
                            return commandRxp.test( s )
                        }

                        function parseAssignment( cmd, token, cmdDef ) {
                            var match = assignmentRxp.exec( token ),
                                name = match[ 1 ],
                                val = utils.trimQuotes( match[ 2 ] ),
                                optDef = findOptionDefn( name, cmdDef );
                            if ( !optDef ) {
                                cmd._.push( token )
                            } else if ( optDef.type == "flag" || optDef.assign_to ) {
                                stop( "-" + cmdDef.name + " " + name + " option doesn't take a value" )
                            } else {
                                readOption( cmd, [ name, val ], cmdDef )
                            }
                        }

                        function readOption( cmd, argv, cmdDef ) {
                            var token = argv.shift(),
                                optDef = findOptionDefn( token, cmdDef ),
                                optName;
                            if ( assignmentRxp.test( token ) ) {
                                parseAssignment( cmd, token, cmdDef );
                                return
                            }
                            if ( !optDef ) {
                                cmd._.push( token );
                                return
                            }
                            optName = optDef.alias_to || optDef.name;
                            optName = optName.replace( /-/g, "_" );
                            if ( optDef.assign_to ) {
                                cmd.options[ optDef.assign_to ] = optDef.name
                            } else if ( optDef.type == "flag" ) {
                                cmd.options[ optName ] = true
                            } else {
                                cmd.options[ optName ] = readOptionValue( argv, optDef )
                            }
                        }

                        function readOptionValue( argv, optDef ) {
                            var type = optDef.type,
                                val, err, token;
                            if ( argv.length === 0 || tokenLooksLikeCommand( argv[ 0 ] ) ) {
                                err = "Missing value"
                            } else {
                                token = argv.shift();
                                if ( type == "number" ) {
                                    val = Number( token )
                                } else if ( type == "integer" ) {
                                    val = Math.round( Number( token ) )
                                } else if ( type == "comma-sep" ) {
                                    val = token.split( "," )
                                } else if ( type == "bbox" ) {
                                    val = token.split( "," ).map( parseFloat )
                                } else if ( type == "percent" ) {
                                    val = utils.parsePercent( token )
                                } else {
                                    val = token
                                }
                                if ( val !== val ) {
                                    err = "Invalid numeric value"
                                }
                            }
                            if ( err ) {
                                stop( err + " for option " + optDef.name + "=<value>" )
                            }
                            return val
                        }

                        function readCommandName( args ) {
                            var match = commandRxp.exec( args[ 0 ] );
                            if ( match ) {
                                args.shift();
                                return match[ 1 ]
                            }
                            return null
                        }

                        function findCommandDefn( name, arr ) {
                            return utils.find( arr, function( cmd ) {
                                return cmd.name === name || cmd.alias === name
                            } )
                        }

                        function findOptionDefn( name, cmd ) {
                            return utils.find( cmd.options, function( o ) {
                                return o.name === name || o.alias === name
                            } )
                        }
                    };
                    this.getHelpMessage = function( commandNames ) {
                        var helpStr = "",
                            cmdPre = "  ",
                            optPre = "  ",
                            exPre = "  ",
                            gutter = "  ",
                            colWidth = 0,
                            detailView = false,
                            helpCommands, allCommands;
                        allCommands = getCommands().filter( function( cmd ) {
                            return !!cmd.describe
                        } );
                        if ( commandNames ) {
                            detailView = true;
                            helpCommands = commandNames.reduce( function( memo, name ) {
                                var cmd = utils.find( allCommands, function( cmd ) {
                                    return cmd.name == name
                                } );
                                if ( cmd ) memo.push( cmd );
                                return memo
                            }, [] );
                            allCommands.filter( function( cmd ) {
                                return utils.contains( commandNames, cmd.name )
                            } );
                            if ( helpCommands.length === 0 ) {
                                detailView = false
                            }
                        }
                        if ( !detailView ) {
                            if ( _usage ) {
                                helpStr += "\n" + _usage + "\n\n"
                            }
                            helpCommands = allCommands
                        }
                        colWidth = helpCommands.reduce( function( w, obj ) {
                            var help = cmdPre + ( obj.name ? "-" + obj.name : "" );
                            if ( obj.alias ) help += ", -" + obj.alias;
                            obj.help = help;
                            if ( detailView ) {
                                w = obj.options.reduce( function( w, opt ) {
                                    if ( opt.describe ) {
                                        w = Math.max( formatOption( opt ), w )
                                    }
                                    return w
                                }, w )
                            }
                            return Math.max( w, help.length )
                        }, 0 );
                        helpCommands.forEach( function( cmd ) {
                            if ( !detailView && cmd.title ) {
                                helpStr += cmd.title + "\n"
                            }
                            if ( detailView ) {
                                helpStr += "\nCommand\n"
                            }
                            helpStr += formatHelpLine( cmd.help, cmd.describe );
                            if ( detailView && cmd.options.length > 0 ) {
                                helpStr += "\nOptions\n";
                                cmd.options.forEach( function( opt ) {
                                    if ( opt.help && opt.describe ) {
                                        helpStr += formatHelpLine( opt.help, opt.describe )
                                    }
                                } )
                            }
                            if ( detailView && cmd.examples ) {
                                helpStr += "\nExample" + ( cmd.examples.length > 1 ? "s" : "" );
                                cmd.examples.forEach( function( ex ) {
                                    ex.split( "\n" ).forEach( function( line ) {
                                        helpStr += "\n" + exPre + line
                                    } );
                                    helpStr += "\n"
                                } )
                            }
                        } );
                        if ( !detailView ) {
                            if ( _examples.length > 0 ) {
                                helpStr += "\nExamples\n";
                                _examples.forEach( function( str ) {
                                    helpStr += "\n" + str + "\n"
                                } )
                            }
                            if ( _note ) {
                                helpStr += "\n" + _note
                            }
                        }
                        return helpStr;

                        function formatHelpLine( help, desc ) {
                            return utils.rpad( help, colWidth, " " ) + gutter + ( desc || "" ) + "\n"
                        }

                        function formatOption( o ) {
                            o.help = optPre;
                            if ( o.label ) {
                                o.help += o.label
                            } else {
                                o.help += o.name;
                                if ( o.alias ) o.help += ", " + o.alias;
                                if ( o.type != "flag" && !o.assign_to ) o.help += "="
                            }
                            return o.help.length
                        }
                    };
                    this.printHelp = function( commands ) {
                        message( this.getHelpMessage( commands ) )
                    };

                    function getCommands() {
                        return _commands.map( function( cmd ) {
                            return cmd.done()
                        } )
                    }
                }

                function CommandOptions( name ) {
                    var _command = {
                        name: name,
                        options: []
                    };
                    this.validate = function( f ) {
                        _command.validate = f;
                        return this
                    };
                    this.describe = function( str ) {
                        _command.describe = str;
                        return this
                    };
                    this.example = function( str ) {
                        if ( !_command.examples ) {
                            _command.examples = []
                        }
                        _command.examples.push( str );
                        return this
                    };
                    this.alias = function( name ) {
                        _command.alias = name;
                        return this
                    };
                    this.title = function( str ) {
                        _command.title = str;
                        return this
                    };
                    this.option = function( name, opts ) {
                        opts = opts || {};
                        if ( !utils.isString( name ) || !name ) error( "Missing option name" );
                        if ( !utils.isObject( opts ) ) error( "Invalid option definition:", opts );
                        opts.name = name;
                        _command.options.push( opts );
                        return this
                    };
                    this.done = function() {
                        return _command
                    }
                }
                MapShaper.cleanArgv = function( argv ) {
                    argv = argv.map( function( s ) {
                        return s.trim()
                    } );
                    argv = argv.filter( function( s ) {
                        return s !== ""
                    } );
                    argv = argv.map( utils.trimQuotes );
                    return argv
                };

                function validateHelpOpts( cmd ) {
                    var commands = validateCommaSepNames( cmd._[ 0 ] );
                    if ( commands ) {
                        cmd.options.commands = commands
                    }
                }

                function validateInputOpts( cmd ) {
                    var o = cmd.options,
                        _ = cmd._;
                    if ( _[ 0 ] == "-" || _[ 0 ] == "/dev/stdin" ) {
                        o.stdin = true
                    } else if ( _.length > 0 ) {
                        o.files = _
                    }
                    if ( "precision" in o && o.precision > 0 === false ) {
                        error( "precision= option should be a positive number" )
                    }
                    if ( o.encoding ) {
                        o.encoding = MapShaper.validateEncoding( o.encoding )
                    }
                }

                function validateSimplifyOpts( cmd ) {
                    var o = cmd.options,
                        _ = cmd._;
                    var pctStr = o.pct || "";
                    if ( _.length > 0 ) {
                        if ( /^[0-9.]+%?$/.test( _[ 0 ] ) ) {
                            pctStr = _.shift()
                        }
                        if ( _.length > 0 ) {
                            error( "Unparsable option:", _.join( " " ) )
                        }
                    }
                    if ( pctStr ) {
                        o.pct = utils.parsePercent( pctStr )
                    }
                    var intervalStr = o.interval;
                    if ( intervalStr ) {
                        o.interval = Number( intervalStr );
                        if ( o.interval >= 0 === false ) {
                            error( utils.format( "Out-of-range interval value: %s", intervalStr ) )
                        }
                    }
                    if ( isNaN( o.interval ) && isNaN( o.pct ) && !o.resolution ) {
                        error( "Command requires an interval, pct or resolution parameter" )
                    }
                }

                function validateJoinOpts( cmd ) {
                    var o = cmd.options;
                    o.source = o.source || cmd._[ 0 ];
                    if ( !o.source ) {
                        error( "Command requires the name of a layer or file to join" )
                    }
                }

                function validateSplitOpts( cmd ) {
                    if ( cmd._.length == 1 ) {
                        cmd.options.field = cmd._[ 0 ]
                    } else if ( cmd._.length > 1 ) {
                        error( "Command takes a single field name" )
                    }
                }

                function validateClipOpts( cmd ) {
                    var opts = cmd.options;
                    if ( cmd._[ 0 ] ) {
                        opts.source = cmd._[ 0 ]
                    }
                    if ( opts.cleanup ) {
                        delete opts.cleanup;
                        opts.remove_slivers = true
                    }
                    if ( !opts.source && !opts.bbox ) {
                        error( "Command requires a source file, layer id or bbox" )
                    }
                }

                function validateDissolveOpts( cmd ) {
                    var _ = cmd._,
                        o = cmd.options;
                    if ( _.length == 1 ) {
                        o.field = _[ 0 ]
                    } else if ( _.length > 1 ) {
                        error( "Command takes a single field name" )
                    }
                }

                function validateMergeLayersOpts( cmd ) {
                    if ( cmd._.length > 0 ) error( "Unexpected option:", cmd._ )
                }

                function validateRenameLayersOpts( cmd ) {
                    cmd.options.names = validateCommaSepNames( cmd._[ 0 ] ) || null
                }

                function validateGridOpts( cmd ) {
                    var o = cmd.options;
                    if ( cmd._.length == 1 ) {
                        var tmp = cmd._[ 0 ].split( "," );
                        o.cols = parseInt( tmp[ 0 ], 10 );
                        o.rows = parseInt( tmp[ 1 ], 10 ) || o.cols
                    }
                }

                function validateLinesOpts( cmd ) {
                    try {
                        var fields = validateCommaSepNames( cmd.options.fields || cmd._[ 0 ] );
                        if ( fields ) cmd.options.fields = fields
                    } catch ( e ) {
                        error( "Command takes a comma-separated list of fields" )
                    }
                }

                function validateInnerLinesOpts( cmd ) {
                    if ( cmd._.length > 0 ) {
                        error( "Command takes no arguments" )
                    }
                }

                function validateSubdivideOpts( cmd ) {
                    if ( cmd._.length !== 1 ) {
                        error( "Command requires a JavaScript expression" )
                    }
                    cmd.options.expression = cmd._[ 0 ]
                }

                function validateFilterFieldsOpts( cmd ) {
                    try {
                        var fields = validateCommaSepNames( cmd._[ 0 ] );
                        cmd.options.fields = fields || []
                    } catch ( e ) {
                        error( "Command requires a comma-sep. list of fields" )
                    }
                }

                function validateExpressionOpts( cmd ) {
                    if ( cmd._.length == 1 ) {
                        cmd.options.expression = cmd._[ 0 ]
                    } else if ( cmd._.length > 1 ) {
                        error( "Unparsable arguments:", cmd._ )
                    }
                }

                function validateOutputOpts( cmd ) {
                    var _ = cmd._,
                        o = cmd.options,
                        arg = _[ 0 ] || "",
                        pathInfo = utils.parseLocalPath( arg );
                    if ( _.length > 1 ) {
                        error( "Command takes one file or directory argument" )
                    }
                    if ( arg == "-" || arg == "/dev/stdout" ) {
                        o.stdout = true
                    } else if ( arg && !pathInfo.extension ) {
                        if ( !cli.isDirectory( arg ) ) {
                            error( "Unknown output option:", arg )
                        }
                        o.output_dir = arg
                    } else if ( arg ) {
                        if ( pathInfo.directory ) {
                            o.output_dir = pathInfo.directory;
                            cli.validateOutputDir( o.output_dir )
                        }
                        o.output_file = pathInfo.filename;
                        if ( MapShaper.filenameIsUnsupportedOutputType( o.output_file ) ) {
                            error( "Output file looks like an unsupported file type:", o.output_file )
                        }
                    }
                    if ( o.format ) {
                        o.format = o.format.toLowerCase();
                        if ( o.format == "csv" ) {
                            o.format = "dsv";
                            o.delimiter = o.delimiter || ","
                        } else if ( o.format == "tsv" ) {
                            o.format = "dsv";
                            o.delimiter = o.delimiter || "\t"
                        }
                        if ( !MapShaper.isSupportedOutputFormat( o.format ) ) {
                            error( "Unsupported output format:", o.format )
                        }
                    }
                    if ( o.delimiter ) {
                        o.delimiter = o.delimiter.replace( /^["']?\\t["']?$/, "\t" );
                        if ( !MapShaper.isSupportedDelimiter( o.delimiter ) ) {
                            error( "Unsupported delimiter:", o.delimiter )
                        }
                    }
                    if ( o.encoding ) {
                        o.encoding = MapShaper.validateEncoding( o.encoding )
                    }
                    if ( "quantization" in o && o.quantization > 0 === false ) {
                        error( "quantization= option should be a nonnegative integer" )
                    }
                    if ( "topojson_precision" in o && o.topojson_precision > 0 === false ) {
                        error( "topojson-precision= option should be a positive number" )
                    }
                }

                function validateCommaSepNames( str, min ) {
                    if ( !min && !str ) return null;
                    if ( !utils.isString( str ) ) {
                        error( "Expected a comma-separated list; found:", str )
                    }
                    var parts = str.split( "," ).map( utils.trim ).filter( function( s ) {
                        return !!s
                    } );
                    if ( min && min > parts.length < min ) {
                        error( utils.format( "Expected a list of at least %d member%s; found: %s", min, utils.pluralSuffix( min ), str ) )
                    }
                    return parts.length > 0 ? parts : null
                }
                MapShaper.splitShellTokens = function( str ) {
                    var BAREWORD = "([^\\s'\"])+";
                    var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
                    var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
                    var rxp = new RegExp( "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")*", "g" );
                    var matches = str.match( rxp ) || [];
                    var chunks = matches.filter( function( chunk ) {
                        return !!chunk && chunk != "\\"
                    } ).map( utils.trimQuotes );
                    return chunks
                };
                utils.trimQuotes = function( raw ) {
                    var len = raw.length,
                        first, last;
                    if ( len >= 2 ) {
                        first = raw.charAt( 0 );
                        last = raw.charAt( len - 1 );
                        if ( first == '"' && last == '"' || first == "'" && last == "'" ) {
                            return raw.substr( 1, len - 2 )
                        }
                    }
                    return raw
                };
                MapShaper.getOptionParser = function() {
                    var targetOpt = {
                            describe: "layer(s) to target (comma-sep. list); default is all layers"
                        },
                        nameOpt = {
                            describe: "rename the edited layer(s)"
                        },
                        noReplaceOpt = {
                            alias: "+",
                            type: "flag",
                            describe: "retain the original layer(s) instead of replacing"
                        },
                        noSnapOpt = {
                            type: "flag"
                        },
                        encodingOpt = {
                            describe: "text encoding (applies to .dbf and delimited text files)"
                        },
                        autoSnapOpt = {
                            alias: "snap",
                            describe: "snap nearly identical points to fix minor topology errors",
                            type: "flag"
                        },
                        snapIntervalOpt = {
                            describe: "specify snapping distance in source units",
                            type: "number"
                        },
                        sumFieldsOpt = {
                            describe: "fields to sum when dissolving  (comma-sep. list)",
                            type: "comma-sep"
                        },
                        copyFieldsOpt = {
                            describe: "fields to copy when dissolving (comma-sep. list)",
                            type: "comma-sep"
                        },
                        dissolveFieldOpt = {
                            label: "<field>",
                            describe: "(optional) name of a data field to dissolve on"
                        },
                        bboxOpt = {
                            type: "bbox",
                            describe: "comma-sep. bounding box: xmin,ymin,xmax,ymax"
                        };
                    var parser = new CommandParser;
                    parser.usage( "Usage:  mapshaper -<command> [options] ..." );
                    parser.note( "Enter mapshaper -help <command> to view options for a single command" );
                    parser.default( "i" );
                    parser.command( "i" ).title( "I/O commands" ).describe( "input one or more files" ).validate( validateInputOpts ).option( "files", {
                        label: "<file(s)>",
                        describe: "files to import (separated by spaces), or - to use stdin"
                    } ).option( "merge-files", {
                        describe: "merge features from compatible files into the same layer",
                        type: "flag"
                    } ).option( "combine-files", {
                        describe: "import files to separate layers with shared topology",
                        type: "flag"
                    } ).option( "no-topology", {
                        describe: "treat each shape as topologically independent",
                        type: "flag"
                    } ).option( "precision", {
                        describe: "coordinate precision in source units, e.g. 0.001",
                        type: "number"
                    } ).option( "auto-snap", autoSnapOpt ).option( "snap-interval", snapIntervalOpt ).option( "encoding", encodingOpt ).option( "id-field", {
                        describe: "import Topo/GeoJSON id property to this field"
                    } ).option( "field-types", {
                        describe: "type hints for csv files, e.g. FIPS:str,STATE_FIPS:str",
                        type: "comma-sep"
                    } ).option( "name", {
                        describe: "Rename the imported layer(s)"
                    } );
                    parser.command( "o" ).describe( "output edited content" ).validate( validateOutputOpts ).option( "_", {
                        label: "<file|dir|->",
                        describe: "(optional) name of output file or directory, or - for stdout"
                    } ).option( "format", {
                        describe: "options: shapefile,geojson,topojson,json,dbf,csv,tsv,svg"
                    } ).option( "target", targetOpt ).option( "force", {
                        type: "flag",
                        describe: "let output files overwrite existing files"
                    } ).option( "dry-run", {
                        type: "flag"
                    } ).option( "encoding", {
                        describe: "text encoding of output dbf file"
                    } ).option( "ldid", {
                        type: "number"
                    } ).option( "bbox-index", {
                        describe: "export a .json file with bbox of each layer",
                        type: "flag"
                    } ).option( "cut-table", {
                        describe: "detach data attributes from shapes and save as a JSON file",
                        type: "flag"
                    } ).option( "drop-table", {
                        describe: "remove data attributes from output",
                        type: "flag"
                    } ).option( "precision", {
                        describe: "coordinate precision in source units, e.g. 0.001",
                        type: "number"
                    } ).option( "bbox", {
                        type: "flag",
                        describe: "(Topo/GeoJSON) add bbox property"
                    } ).option( "prettify", {
                        type: "flag",
                        describe: "(Topo/GeoJSON) format output for readability"
                    } ).option( "id-field", {
                        describe: "(Topo/GeoJSON/SVG) field to use for id property",
                        type: "comma-sep"
                    } ).option( "singles", {
                        type: "flag"
                    } ).option( "quantization", {
                        describe: "(TopoJSON) specify quantization (auto-set by default)",
                        type: "integer"
                    } ).option( "no-quantization", {
                        describe: "(TopoJSON) export arc coordinates without quantization",
                        type: "flag"
                    } ).option( "presimplify", {
                        describe: "(TopoJSON) add per-vertex data for dynamic simplification",
                        type: "flag"
                    } ).option( "topojson-precision", {
                        type: "number"
                    } ).option( "width", {
                        describe: "(SVG) width of the SVG viewport (default is 800)",
                        type: "number"
                    } ).option( "margin", {
                        describe: "(SVG) margin between data and viewport bounds (default is 1)",
                        type: "number"
                    } ).option( "svg-scale", {
                        type: "number"
                    } ).option( "delimiter", {
                        describe: "(CSV) field delimiter"
                    } ).option( "final", {
                        type: "flag"
                    } );
                    parser.command( "clean" ).option( "target", targetOpt );
                    parser.command( "clip" ).describe( "use a polygon layer to clip another layer" ).example( "$ mapshaper states.shp -clip land_area.shp -o clipped.shp" ).validate( validateClipOpts ).option( "source", {
                        label: "<file|layer>",
                        describe: "file or layer containing clip polygons"
                    } ).option( "remove-slivers", {
                        describe: "remove sliver polygons created by clipping",
                        type: "flag"
                    } ).option( "cleanup", {
                        type: "flag"
                    } ).option( "bbox", bboxOpt ).option( "name", nameOpt ).option( "no-replace", noReplaceOpt ).option( "no-snap", noSnapOpt ).option( "target", targetOpt );
                    parser.command( "cluster" ).title( "\nEditing commands" ).describe( "group polygons into compact clusters" ).option( "id-field", {
                        describe: 'field name of cluster id (default is "cluster")'
                    } ).option( "pct", {
                        alias: "p",
                        type: "percent",
                        describe: "percentage of shapes to retain, e.g. 50%"
                    } ).option( "max-width", {
                        describe: "max width of cluster bounding box",
                        type: "number"
                    } ).option( "max-height", {
                        describe: "max height of cluster bounding box",
                        type: "number"
                    } ).option( "max-area", {
                        describe: "max area of a cluster",
                        type: "number"
                    } ).option( "group-by", {
                        describe: "field name; only same-value shapes will be grouped"
                    } ).option( "target", targetOpt );
                    parser.command( "dissolve" ).validate( validateDissolveOpts ).describe( "merge polygon or point features" ).example( "Dissolve all polygons in a feature layer into a single polygon\n" + "$ mapshaper states.shp -dissolve -o country.shp" ).example( "Generate state-level polygons by dissolving a layer of counties\n" + "(STATE_FIPS, POPULATION and STATE_NAME are attribute field names)\n" + "$ mapshaper counties.shp -dissolve STATE_FIPS copy-fields=STATE_NAME sum-fields=POPULATION -o states.shp" ).option( "field", dissolveFieldOpt ).option( "sum-fields", sumFieldsOpt ).option( "copy-fields", copyFieldsOpt ).option( "weight", {
                        describe: "[points] field or expression to use for weighting centroid"
                    } ).option( "planar", {
                        type: "flag",
                        describe: "[points] use 2D math to find centroids of latlong points"
                    } ).option( "name", nameOpt ).option( "no-replace", noReplaceOpt ).option( "target", targetOpt );
                    parser.command( "dissolve2" ).validate( validateDissolveOpts ).describe( "merge adjacent and overlapping polygons" ).option( "field", dissolveFieldOpt ).option( "sum-fields", sumFieldsOpt ).option( "copy-fields", copyFieldsOpt ).option( "name", nameOpt ).option( "no-replace", noReplaceOpt ).option( "no-snap", noSnapOpt ).option( "target", targetOpt );
                    parser.command( "each" ).describe( "create/update/delete data fields using a JS expression" ).example( "Add two calculated data fields to a layer of U.S. counties\n" + "$ mapshaper counties.shp -each 'STATE_FIPS=CNTY_FIPS.substr(0, 2), AREA=$.area'" ).validate( validateExpressionOpts ).option( "expression", {
                        label: "<expression>",
                        describe: "JS expression to apply to each target feature"
                    } ).option( "where", {
                        describe: "use a JS expression to select a subset of features"
                    } ).option( "target", targetOpt );
                    parser.command( "erase" ).describe( "use a polygon layer to erase another layer" ).example( "$ mapshaper land_areas.shp -erase water_bodies.shp -o erased.shp" ).validate( validateClipOpts ).option( "source", {
                        label: "<file|layer>",
                        describe: "file or layer containing erase polygons"
                    } ).option( "remove-slivers", {
                        describe: "remove sliver polygons created by erasing",
                        type: "flag"
                    } ).option( "cleanup", {
                        type: "flag"
                    } ).option( "bbox", bboxOpt ).option( "name", nameOpt ).option( "no-replace", noReplaceOpt ).option( "no-snap", noSnapOpt ).option( "target", targetOpt );
                    parser.command( "explode" ).describe( "divide multi-part features into single-part features" ).option( "convert-holes", {
                        type: "flag"
                    } ).option( "target", targetOpt );
                    parser.command( "filter" ).describe( "delete features using a JS expression" ).validate( validateExpressionOpts ).option( "expression", {
                        label: "<expression>",
                        describe: "delete features that evaluate to false"
                    } ).option( "remove-empty", {
                        type: "flag",
                        describe: "delete features with null geometry"
                    } ).option( "keep-shapes", {
                        type: "flag"
                    } ).option( "name", nameOpt ).option( "no-replace", noReplaceOpt ).option( "target", targetOpt );
                    parser.command( "filter-fields" ).describe( "retain a subset of data fields" ).validate( validateFilterFieldsOpts ).option( "fields", {
                        label: "<field(s)>",
                        describe: "fields to retain (comma-sep.), e.g. 'fips,name'"
                    } ).option( "target", targetOpt );
                    parser.command( "filter-islands" ).describe( "remove small detached polygon rings (islands)" ).validate( validateExpressionOpts ).option( "min-area", {
                        type: "number",
                        describe: "remove small-area islands (sq meters or projected units)"
                    } ).option( "min-vertices", {
                        type: "integer",
                        describe: "remove low-vertex-count islands"
                    } ).option( "remove-empty", {
                        type: "flag",
                        describe: "delete features with null geometry"
                    } ).option( "target", targetOpt );
                    parser.command( "filter-slivers" ).describe( "remove small polygon rings" ).validate( validateExpressionOpts ).option( "min-area", {
                        type: "number",
                        describe: "remove small-area rings (sq meters or projected units)"
                    } ).option( "target", targetOpt );
                    parser.command( "graticule" ).describe( "create a graticule layer" );
                    parser.command( "point-grid" ).describe( "create a rectangular grid of points" ).validate( validateGridOpts ).option( "-", {
                        label: "<cols,rows>",
                        describe: "size of the grid, e.g. -point-grid 100,100"
                    } ).option( "interval", {
                        describe: "distance between adjacent points, in source units",
                        type: "number"
                    } ).option( "cols", {
                        type: "integer"
                    } ).option( "rows", {
                        type: "integer"
                    } ).option( "bbox", {
                        type: "bbox",
                        describe: "xmin,ymin,xmax,ymax (default is bbox of data)"
                    } ).option( "name", nameOpt );
                    parser.command( "innerlines" ).describe( "convert polygons to polylines along shared edges" ).validate( validateInnerLinesOpts ).option( "name", nameOpt ).option( "no-replace", noReplaceOpt ).option( "target", targetOpt );
                    parser.command( "join" ).describe( "join data records from a file or layer to a layer" ).example( "Join a csv table to a Shapefile\n" + "(The :str suffix prevents FIPS field from being converted from strings to numbers)\n" + "$ mapshaper states.shp -join data.csv keys=STATE_FIPS,FIPS -field-types=FIPS:str -o joined.shp" ).validate( validateJoinOpts ).option( "source", {
                        label: "<file>",
                        describe: "file containing data records"
                    } ).option( "keys", {
                        describe: "join by matching target,source key fields; e.g. keys=FIPS,GEOID",
                        type: "comma-sep"
                    } ).option( "fields", {
                        describe: "fields to join, e.g. fields=FIPS,POP (default is all fields)",
                        type: "comma-sep"
                    } ).option( "field-types", {
                        describe: "type hints for importing csv files, e.g. FIPS:str,STATE_FIPS:str",
                        type: "comma-sep"
                    } ).option( "sum-fields", {
                        describe: "fields to sum when multiple source records match the same target",
                        type: "comma-sep"
                    } ).option( "where", {
                        describe: "use a JS expression to filter source records"
                    } ).option( "force", {
                        describe: "replace values from same-named fields",
                        type: "flag"
                    } ).option( "unjoined", {
                        describe: 'copy unjoined records from source table to "unjoined" layer',
                        type: "flag"
                    } ).option( "unmatched", {
                        describe: 'copy unmatched records in target table to "unmatched" layer',
                        type: "flag"
                    } ).option( "encoding", encodingOpt ).option( "target", targetOpt );
                    parser.command( "lines" ).describe( "convert polygons to polylines, classified by edge type" ).validate( validateLinesOpts ).option( "fields", {
                        label: "<field(s)>",
                        describe: "optional comma-sep. list of fields to create a hierarchy",
                        type: "comma-sep"
                    } ).option( "name", nameOpt ).option( "no-replace", noReplaceOpt ).option( "target", targetOpt );
                    parser.command( "merge-layers" ).describe( "merge multiple layers into as few layers as possible" ).validate( validateMergeLayersOpts ).option( "name", nameOpt ).option( "target", targetOpt );
                    parser.command( "points" ).describe( "create a point layer from polygons or attribute data" ).validate( function( cmd ) {
                        if ( cmd._.length > 0 ) {
                            error( "Unknown argument:", cmd._[ 0 ] )
                        }
                    } ).option( "x", {
                        describe: "field containing x coordinate"
                    } ).option( "y", {
                        describe: "field containing y coordinate"
                    } ).option( "inner", {
                        describe: "create an interior point for each polygon's largest ring",
                        type: "flag"
                    } ).option( "centroid", {
                        describe: "create a centroid point for each polygon's largest ring",
                        type: "flag"
                    } ).option( "name", nameOpt ).option( "no-replace", noReplaceOpt ).option( "target", targetOpt );
                    parser.command( "proj" ).describe( "project a dataset using a proj4 string or alias" ).option( "densify", {
                        type: "flag",
                        describe: "add points along straight segments to approximate curves"
                    } ).option( "from", {
                        describe: "define the source projection"
                    } ).validate( function( cmd ) {
                        var _ = cmd._,
                            proj4 = [];
                        _ = _.filter( function( arg ) {
                            if ( /^\+[a-z]/i.test( arg ) ) {
                                proj4.push( arg );
                                return false
                            }
                            return true
                        } );
                        if ( proj4.length > 0 ) {
                            cmd.options.projection = proj4.join( " " )
                        } else if ( _.length > 0 ) {
                            cmd.options.projection = _.shift()
                        }
                        if ( _.length > 0 ) {
                            error( "Received one or more unknown projection parameters" )
                        }
                        if ( !cmd.options.projection ) {
                            error( "Missing projection data" )
                        }
                    } );
                    parser.command( "rename-fields" ).describe( "rename data fields" ).validate( validateFilterFieldsOpts ).option( "fields", {
                        label: "<field(s)>",
                        describe: "fields to rename (comma-sep.), e.g. 'fips=STATE_FIPS,st=state'"
                    } ).option( "target", targetOpt );
                    parser.command( "rename-layers" ).describe( "assign new names to layers" ).validate( validateRenameLayersOpts ).option( "names", {
                        label: "<name(s)>",
                        type: "comma-sep",
                        describe: "new layer name(s) (comma-sep. list)"
                    } ).option( "target", targetOpt );
                    parser.command( "simplify" ).validate( validateSimplifyOpts ).example( "Retain 10% of removable vertices\n$ mapshaper input.shp -simplify 10%" ).describe( "simplify the geometry of polygon and polyline features" ).option( "pct", {
                        alias: "p",
                        label: "<x%>",
                        describe: "percentage of removable points to retain, e.g. 10%"
                    } ).option( "dp", {
                        alias: "rdp",
                        describe: "use Ramer-Douglas-Peucker simplification",
                        assign_to: "method"
                    } ).option( "visvalingam", {
                        describe: 'use Visvalingam simplification with "effective area" metric',
                        assign_to: "method"
                    } ).option( "weighted", {
                        describe: "use weighted Visvalingam simplification (default)",
                        assign_to: "method"
                    } ).option( "method", {} ).option( "weighting", {
                        type: "number",
                        describe: "weighted Visvalingam coefficient (default is 0.7)"
                    } ).option( "resolution", {
                        describe: "output resolution as a grid (e.g. 1000x500)"
                    } ).option( "interval", {
                        describe: "output resolution as a distance (e.g. 100)",
                        type: "number"
                    } ).option( "planar", {
                        describe: "simplify decimal degree coords in 2D space (default is 3D)",
                        type: "flag"
                    } ).option( "cartesian", {
                        describe: "(deprecated) alias for planar",
                        type: "flag",
                        alias_to: "planar"
                    } ).option( "keep-shapes", {
                        describe: "prevent small polygon features from disappearing",
                        type: "flag"
                    } ).option( "lock-box", {
                        type: "flag"
                    } ).option( "no-repair", {
                        describe: "don't remove intersections introduced by simplification",
                        type: "flag"
                    } ).option( "stats", {
                        describe: "display simplification statistics",
                        type: "flag"
                    } );
                    parser.command( "slice" ).validate( validateClipOpts ).option( "source", {
                        label: "<file|layer>",
                        describe: "file or layer containing clip polygons"
                    } ).option( "id-field", {
                        describe: "slice id field (from source layer)"
                    } ).option( "name", nameOpt ).option( "no-replace", noReplaceOpt ).option( "no-snap", noSnapOpt ).option( "target", targetOpt );
                    parser.command( "sort" ).describe( "sort features using a JS expression" ).validate( validateExpressionOpts ).option( "expression", {
                        label: "<expression>",
                        describe: "JS expression to generate a sort key for each feature"
                    } ).option( "ascending", {
                        describe: "sort in ascending order (default)",
                        type: "flag"
                    } ).option( "descending", {
                        describe: "sort in descending order",
                        type: "flag"
                    } ).option( "target", targetOpt );
                    parser.command( "split" ).describe( "split features into separate layers using a data field" ).validate( validateSplitOpts ).option( "field", {
                        label: "<field>",
                        describe: "name of an attribute field (omit to split all features)"
                    } ).option( "no-replace", noReplaceOpt ).option( "target", targetOpt );
                    parser.command( "split-on-grid" ).describe( "split features into separate layers using a grid" ).validate( validateGridOpts ).option( "-", {
                        label: "<cols,rows>",
                        describe: "size of the grid, e.g. -split-on-grid 12,10"
                    } ).option( "cols", {
                        type: "integer"
                    } ).option( "rows", {
                        type: "integer"
                    } ).option( "id-field", {
                        describe: "assign each feature a cell id instead of splitting layer"
                    } ).option( "target", targetOpt );
                    parser.command( "subdivide" ).describe( "recursively split a layer using a JS expression" ).validate( validateSubdivideOpts ).option( "expression", {
                        label: "<expression>",
                        describe: "boolean JS expression"
                    } ).option( "target", targetOpt );
                    parser.command( "svg-style" ).describe( "set SVG style using JS expressions or literal values" ).option( "class", {
                        describe: "name of CSS class or classes (space sep.)"
                    } ).option( "fill", {
                        describe: "fill color, examples: #eee pink rgba(0, 0, 0, 0.2)"
                    } ).option( "stroke", {
                        describe: "stroke color"
                    } ).option( "stroke-width", {
                        describe: "stroke width"
                    } ).option( "opacity", {
                        describe: "opacity, example: 0.5"
                    } ).option( "r", {
                        describe: "radius of circle symbols"
                    } ).option( "target", targetOpt );
                    parser.command( "uniq" ).describe( "delete features with the same id as a previous feature" ).validate( validateExpressionOpts ).option( "expression", {
                        label: "<expression>",
                        describe: "JS expression to obtain the id of a feature"
                    } ).option( "target", targetOpt );
                    parser.command( "calc" ).title( "\nInformational commands" ).describe( "calculate statistics about the features in a layer" ).example( "Calculate the total area of a polygon layer\n" + "$ mapshaper polygons.shp -calc 'sum($.area)'" ).example( "Count census blocks in NY with zero population\n" + "$ mapshaper ny-census-blocks.shp -calc 'count()' where='POPULATION == 0'" ).validate( function( cmd ) {
                        if ( cmd._.length === 0 ) {
                            error( "Missing a JS expression" )
                        }
                        validateExpressionOpts( cmd )
                    } ).option( "expression", {
                        label: "<expression>",
                        describe: "functions: sum() average() median() max() min() count()"
                    } ).option( "where", {
                        describe: "use a JS expression to select a subset of features"
                    } ).option( "target", targetOpt );
                    parser.command( "encodings" ).describe( "print list of supported text encodings (for .dbf import)" );
                    parser.command( "help" ).alias( "h" ).validate( validateHelpOpts ).describe( "print help; takes optional command name" ).option( "commands", {
                        label: "<command>",
                        type: "comma-sep",
                        describe: "view detailed information about a command"
                    } );
                    parser.command( "info" ).describe( "print information about data layers" );
                    parser.command( "inspect" ).describe( "print information about a feature" ).option( "expression", {
                        label: "<expression>",
                        describe: "boolean JS expression for selecting a feature"
                    } ).option( "target", targetOpt ).validate( function( cmd ) {
                        if ( cmd._.length > 0 ) {
                            cmd.options.expression = cmd._[ 0 ]
                        }
                    } );
                    parser.command( "projections" ).describe( "print list of supported projections" );
                    parser.command( "version" ).alias( "v" ).describe( "print mapshaper version" );
                    parser.command( "verbose" ).describe( "print verbose processing messages" );
                    parser.command( "tracing" );
                    return parser
                };
                MapShaper.parseCommands = function( tokens ) {
                    if ( utils.isString( tokens ) ) {
                        tokens = MapShaper.splitShellTokens( tokens )
                    }
                    return MapShaper.getOptionParser().parseArgv( tokens )
                };
                MapShaper.parseConsoleCommands = function( raw ) {
                    var str = raw.replace( /^mapshaper\b/, "" ).trim();
                    var parsed;
                    if ( /^[a-z]/.test( str ) ) {
                        str = "-" + str
                    }
                    if ( utils.contains( MapShaper.splitShellTokens( str ), "-i" ) ) {
                        stop( "The input command cannot be run in the browser" )
                    }
                    parsed = MapShaper.parseCommands( str );
                    if ( parsed.length > 0 && parsed[ 0 ].name == "i" ) {
                        stop( utils.format( "Unable to run [%s]", raw ) )
                    }
                    return parsed
                };
                api.runCommands = function( argv, done ) {
                    var commands, last;
                    try {
                        commands = MapShaper.parseCommands( argv );
                        last = commands[ commands.length - 1 ];
                        if ( last && last.name == "o" ) {
                            last.options.final = true
                        }
                    } catch ( e ) {
                        return done( e )
                    }
                    if ( commands.length === 0 ) {
                        return done( new APIError( "No commands to run" ) )
                    }
                    commands = MapShaper.runAndRemoveInfoCommands( commands );
                    commands = MapShaper.divideImportCommand( commands );
                    MapShaper.runParsedCommands( commands, function( err, output ) {
                        done( err, output )
                    } )
                };
                api.applyCommands = function( argv, content, done ) {
                    MapShaper.processFileContent( argv, content, function( err, exports ) {
                        var output = null;
                        if ( !err ) {
                            output = exports.map( function( obj ) {
                                return obj.content
                            } );
                            if ( output.length == 1 ) {
                                output = output[ 0 ]
                            }
                        }
                        done( err, output )
                    } )
                };
                MapShaper.processFileContent = function( tokens, content, done ) {
                    var dataset, commands, lastCmd, inOpts, output;
                    try {
                        commands = MapShaper.parseCommands( tokens );
                        commands = MapShaper.runAndRemoveInfoCommands( commands );
                        if ( content ) {
                            if ( commands[ 0 ] && commands[ 0 ].name == "i" ) {
                                inOpts = commands.shift().options
                            } else {
                                inOpts = {}
                            }
                            dataset = MapShaper.importFileContent( content, null, inOpts )
                        }
                        lastCmd = commands[ commands.length - 1 ];
                        if ( !lastCmd || lastCmd.name != "o" ) {
                            lastCmd = {
                                name: "o",
                                options: {}
                            };
                            commands.push( lastCmd )
                        }
                        lastCmd.options.callback = function( data ) {
                            output = data
                        }
                    } catch ( e ) {
                        return done( e )
                    }
                    MapShaper.runParsedCommands( commands, dataset, function( err ) {
                        done( err, output )
                    } )
                };
                MapShaper.runParsedCommands = function( commands ) {
                    var dataset = null,
                        done;
                    if ( arguments.length == 2 ) {
                        done = arguments[ 1 ]
                    } else if ( arguments.length == 3 ) {
                        dataset = arguments[ 1 ];
                        done = arguments[ 2 ]
                    }
                    if ( !utils.isFunction( done ) ) {
                        error( "[runParsedCommands()] Missing a callback function" )
                    }
                    if ( !utils.isArray( commands ) ) {
                        error( "[runParsedCommands()] Expected an array of parsed commands" )
                    }
                    commands = MapShaper.runAndRemoveInfoCommands( commands );
                    if ( commands.length === 0 ) {
                        return done( null, dataset )
                    }
                    utils.reduceAsync( commands, dataset, function( dataset, cmd, nextCmd ) {
                        api.runCommand( cmd, dataset, nextCmd )
                    }, done )
                };
                MapShaper.divideImportCommand = function( commands ) {
                    var firstCmd = commands[ 0 ],
                        opts = firstCmd && firstCmd.options;
                    if ( !firstCmd || firstCmd.name != "i" || opts.stdin || opts.merge_files || opts.combine_files || !opts.files || opts.files.length < 2 ) {
                        return commands
                    }
                    return opts.files.reduce( function( memo, file ) {
                        var importCmd = {
                            name: "i",
                            options: utils.defaults( {
                                files: [ file ]
                            }, opts )
                        };
                        memo.push( importCmd );
                        memo.push.apply( memo, commands.slice( 1 ) );
                        return memo
                    }, [] )
                };
                utils.reduceAsync = function( arr, memo, iter, done ) {
                    var call = typeof setImmediate == "undefined" ? setTimeout : setImmediate;
                    var i = 0;
                    next( null, memo );

                    function next( err, memo ) {
                        if ( err ) {
                            return done( err, null )
                        }
                        call( function() {
                            if ( i < arr.length === false ) {
                                done( null, memo )
                            } else {
                                iter( memo, arr[ i++ ], next )
                            }
                        }, 0 )
                    }
                };
                MapShaper.runAndRemoveInfoCommands = function( commands ) {
                    return commands.filter( function( cmd ) {
                        if ( cmd.name == "version" ) {
                            message( MapShaper.VERSION )
                        } else if ( cmd.name == "encodings" ) {
                            MapShaper.printEncodings()
                        } else if ( cmd.name == "projections" ) {
                            MapShaper.printProjections()
                        } else if ( cmd.name == "help" ) {
                            MapShaper.getOptionParser().printHelp( cmd.options.commands )
                        } else if ( cmd.name == "verbose" ) {
                            MapShaper.VERBOSE = true
                        } else if ( cmd.name == "tracing" ) {
                            MapShaper.TRACING = true
                        } else {
                            return true
                        }
                        return false
                    } )
                };
                api.cli = cli;
                api.internal = MapShaper;
                api.utils = utils;
                api.geom = geom;
                this.mapshaper = api;
                utils.extend( api.internal, {
                    DataTable: DataTable,
                    BinArray: BinArray,
                    DouglasPeucker: DouglasPeucker,
                    Visvalingam: Visvalingam,
                    Heap: Heap,
                    ShpReader: ShpReader,
                    ShpType: ShpType,
                    Dbf: Dbf,
                    DbfReader: DbfReader,
                    ShapefileTable: ShapefileTable,
                    ArcCollection: ArcCollection,
                    ArcIter: ArcIter,
                    ShapeIter: ShapeIter,
                    Bounds: Bounds,
                    Transform: Transform,
                    NodeCollection: NodeCollection,
                    PolygonIndex: PolygonIndex,
                    PathIndex: PathIndex,
                    topojson: TopoJSON,
                    geojson: GeoJSON,
                    svg: SVG,
                    APIError: APIError
                } );
                if ( typeof define === "function" && define.amd ) {
                    define( "mapshaper", api )
                } else if ( typeof module === "object" && module.exports ) {
                    module.exports = api
                }
            } )()
        }, {
            buffer: 4,
            "d3-dsv": 6,
            fs: 3,
            "iconv-lite": 27,
            mproj: 35,
            path: 36,
            rbush: 33,
            rw: 52
        } ],
        35: [ function( require, module, exports ) {
            ( function( __dirname ) {
                ( function() {
                    var fabs = Math.abs,
                        floor = Math.floor,
                        sin = Math.sin,
                        cos = Math.cos,
                        tan = Math.tan,
                        asin = Math.asin,
                        acos = Math.acos,
                        atan = Math.atan,
                        atan2 = Math.atan2,
                        sqrt = Math.sqrt,
                        pow = Math.pow,
                        exp = Math.exp,
                        log = Math.log,
                        hypot = Math.hypot,
                        sinh = Math.sinh,
                        cosh = Math.cosh,
                        min = Math.min,
                        max = Math.max;
                    var HUGE_VAL = Infinity,
                        M_PI = Math.PI;
                    var RAD_TO_DEG = 57.29577951308232,
                        DEG_TO_RAD = .017453292519943295;
                    var SRS_WGS84_SEMIMAJOR = 6378137;
                    var SRS_WGS84_ESQUARED = .0066943799901413165;
                    var M_FORTPI = M_PI / 4,
                        M_HALFPI = M_PI / 2,
                        M_PI_HALFPI = 1.5 * M_PI,
                        M_TWOPI = 2 * M_PI,
                        M_TWO_D_PI = 2 / M_PI,
                        M_TWOPI_HALFPI = 2.5 * M_PI;
                    var PJD_UNKNOWN = 0,
                        PJD_3PARAM = 1,
                        PJD_7PARAM = 2,
                        PJD_GRIDSHIFT = 3,
                        PJD_WGS84 = 4;
                    var PJD_ERR_GEOCENTRIC = -45,
                        PJD_ERR_AXIS = -47,
                        PJD_ERR_GRID_AREA = -48,
                        PJD_ERR_CATALOG = -49;
                    var EPS10 = 1e-10;
                    var PJ_LOG_NONE = 0,
                        PJ_LOG_ERROR = 1,
                        PJ_LOG_DEBUG_MAJOR = 2,
                        PJ_LOG_DEBUG_MINOR = 3;
                    var ctx = {
                        last_errno: 0,
                        debug_level: PJ_LOG_NONE,
                        logger: null
                    };
                    var pj_err_list = [ "no arguments in initialization list", "no options found in 'init' file", "no colon in init= string", "projection not named", "unknown projection id", "effective eccentricity = 1", "unknown unit conversion id", "invalid boolean param argument", "unknown elliptical parameter name", "reciprocal flattening (1/f) = 0", "|radius reference latitude| > 90", "squared eccentricity < 0", "major axis or radius = 0 or not given", "latitude or longitude exceeded limits", "invalid x or y", "improperly formed DMS value", "non-convergent inverse meridional dist", "non-convergent inverse phi2", "acos/asin: |arg| >1+1e-14", "tolerance condition error", "conic lat_1 = -lat_2", "lat_1 >= 90", "lat_1 = 0", "lat_ts >= 90", "no distance between control points", "projection not selected to be rotated", "W <= 0 or M <= 0", "lsat not in 1-5 range", "path not in range", "h <= 0", "k <= 0", "lat_0 = 0 or 90 or alpha = 90", "lat_1=lat_2 or lat_1=0 or lat_2=90", "elliptical usage required", "invalid UTM zone number", "arg(s) out of range for Tcheby eval", "failed to find projection to be rotated", "failed to load datum shift file", "both n & m must be spec'd and > 0", "n <= 0, n > 1 or not specified", "lat_1 or lat_2 not specified", "|lat_1| == |lat_2|", "lat_0 is pi/2 from mean lat", "unparseable coordinate system definition", "geocentric transformation missing z or ellps", "unknown prime meridian conversion id", "illegal axis orientation combination", "point not within available datum shift grids", "invalid sweep axis, choose x or y" ];

                    function check_fatal_error() {
                        var code = ctx.last_errno;
                        if ( !code ) return;
                        if ( code > 0 || !is_transient_error( code ) ) {
                            e_error( code )
                        } else {}
                    }

                    function is_transient_error( code ) {
                        return transient_error.indexOf( code ) > -1
                    }
                    var transient_error = [ -14, -15, -17, -18, -19, -20, -27, -48 ];

                    function pj_ctx_set_errno( code ) {
                        ctx.last_errno = code
                    }

                    function f_error() {
                        pj_ctx_set_errno( -20 )
                    }

                    function i_error() {
                        pj_ctx_set_errno( -20 )
                    }

                    function error_msg( code ) {
                        return pj_err_list[ ~code ] || "unknown error"
                    }

                    function error( code ) {
                        e_error( code )
                    }

                    function e_error( code ) {
                        pj_ctx_set_errno( code );
                        fatal()
                    }

                    function fatal( msg, o ) {
                        if ( !o ) o = {};
                        if ( !o.code ) o.code = ctx.last_errno || 0;
                        if ( !msg ) msg = error_msg( o.code );
                        throw new ProjError( msg, o )
                    }

                    function ProjError( msg, o ) {
                        var err = new Error( msg );
                        err.name = "ProjError";
                        Object.keys( o ).forEach( function( k ) {
                            err[ k ] = o[ k ]
                        } );
                        return err
                    }

                    function dmstor( str ) {
                        return dmstod( str ) * DEG_TO_RAD
                    }

                    function dmstod( str ) {
                        var deg = /-?[0-9.]+d/i.exec( str );
                        var min = /[0-9.]+'/.exec( str );
                        var sec = /[0-9.]+"/.exec( str );
                        var inv = /[ws][\s]*$/i.test( str );
                        var d = parseFloat( deg ? deg[ 0 ] : str );
                        if ( min ) {
                            d += parseFloat( min[ 0 ] ) / 60
                        }
                        if ( sec ) {
                            d += parseFloat( sec[ 0 ] ) / 3600
                        }
                        if ( inv ) {
                            d = -d
                        }
                        if ( isNaN( d ) ) {
                            e_error( -16 )
                        }
                        return d
                    }

                    function pj_atof( str ) {
                        return pj_strtod( str )
                    }

                    function pj_strtod( str ) {
                        return parseFloat( str )
                    }

                    function pj_param( params, code ) {
                        var type = code[ 0 ],
                            name = code.substr( 1 ),
                            obj = params[ name ],
                            isset = obj !== void 0,
                            val, param;
                        if ( type == "t" ) {
                            val = isset
                        } else if ( isset ) {
                            param = obj.param;
                            obj.used = true;
                            if ( type == "i" ) {
                                val = parseInt( param )
                            } else if ( type == "d" ) {
                                val = pj_atof( param )
                            } else if ( type == "r" ) {
                                val = dmstor( param )
                            } else if ( type == "s" ) {
                                val = String( param )
                            } else if ( type == "b" ) {
                                if ( param == "T" || param == "t" || param === true ) {
                                    val = true
                                } else if ( param == "F" || param == "f" ) {
                                    val = false
                                } else {
                                    pj_ctx_set_errno( -8 );
                                    val = false
                                }
                            }
                        } else {
                            val = {
                                i: 0,
                                b: false,
                                d: 0,
                                r: 0,
                                s: ""
                            }[ type ]
                        }
                        if ( val === void 0 ) {
                            fatal( "invalid request to pj_param, fatal" )
                        }
                        return val
                    }

                    function pj_get_params( args ) {
                        var rxp = /\+([a-z][a-z0-9_]*(?:=[^\s]*)?)/gi;
                        var params = {};
                        var match;
                        while ( match = rxp.exec( args ) ) {
                            pj_mkparam( params, match[ 1 ] )
                        }
                        return params
                    }

                    function pj_mkparam( params, token ) {
                        var parts = token.split( "=" );
                        var name, val;
                        if ( parts.length == 1 ) {
                            name = token;
                            val = true
                        } else {
                            name = parts[ 0 ];
                            val = token.substr( parts[ 0 ].length + 1 )
                        }
                        params[ name ] = {
                            used: false,
                            param: val
                        }
                    }
                    var pj_list = {};

                    function pj_add( func, key, name, desc ) {
                        pj_list[ key ] = {
                            init: func,
                            name: name,
                            description: desc
                        }
                    }

                    function pj_is_latlong( P ) {
                        return !P || P.is_latlong
                    }

                    function pj_is_geocent( P ) {
                        return !P || P.is_geocent
                    }

                    function pj_latlong_from_proj( P ) {
                        var defn = "+proj=latlong" + get_geod_defn( P );
                        return pj_init( defn )
                    }

                    function get_geod_defn( P ) {
                        var got_datum = false,
                            defn = "";
                        if ( "datum" in P.params ) {
                            got_datum = true;
                            defn += get_param( P, "datum" )
                        } else if ( "ellps" in P.params ) {
                            defn += get_param( P, "ellps" )
                        } else if ( "a" in P.params ) {
                            defn += get_param( P, "a" );
                            if ( "b" in P.params ) {
                                defn += get_param( P, "b" )
                            } else if ( "es" in P.params ) {
                                defn += get_param( P, "es" )
                            } else if ( "f" in P.params ) {
                                defn += get_param( P, "f" )
                            } else {
                                defn += " +es=" + P.es
                            }
                        } else {
                            error( -13 )
                        }
                        if ( !got_datum ) {
                            defn += get_param( P, "towgs84" );
                            defn += get_param( P, "nadgrids" )
                        }
                        defn += get_param( P, "R" );
                        defn += get_param( P, "R_A" );
                        defn += get_param( P, "R_V" );
                        defn += get_param( P, "R_a" );
                        defn += get_param( P, "R_lat_a" );
                        defn += get_param( P, "R_lat_g" );
                        defn += get_param( P, "pm" );
                        return defn
                    }

                    function get_proj_defn( P ) {
                        var skip = "datum,ellps,a,b,es,rf,f,towgs84,nadgrids,R,R_A,R_V,R_a,R_lat_a,R_lat_g,pm,init,no_defs".split( "," );
                        var defn = "";
                        Object.keys( P.params ).forEach( function( name ) {
                            if ( skip.indexOf( name ) == -1 ) {
                                defn += get_param( P, name )
                            }
                        } );
                        defn += get_geod_defn( P );
                        return defn.trim()
                    }

                    function get_param( P, name ) {
                        var param = "";
                        if ( name in P.params ) {
                            param = " +" + name;
                            if ( P.params[ name ].param !== true ) {
                                param += "=" + pj_param( P.params, "s" + name )
                            }
                        }
                        return param
                    }
                    var pj_datums = [ [ "WGS84", "towgs84=0,0,0", "WGS84", "" ], [ "GGRS87", "towgs84=-199.87,74.79,246.62", "GRS80", "Greek_Geodetic_Reference_System_1987" ], [ "NAD83", "towgs84=0,0,0", "GRS80", "North_American_Datum_1983" ], [ "NAD27", "nadgrids=@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat", "clrk66", "North_American_Datum_1927" ], [ "potsdam", "towgs84=598.1,73.7,418.2,0.202,0.045,-2.455,6.7", "bessel", "Potsdam Rauenberg 1950 DHDN" ], [ "carthage", "towgs84=-263.0,6.0,431.0", "clrk80ign", "Carthage 1934 Tunisia" ], [ "hermannskogel", "towgs84=577.326,90.129,463.919,5.137,1.474,5.297,2.4232", "bessel", "Hermannskogel" ], [ "ire65", "towgs84=482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", "mod_airy", "Ireland 1965" ], [ "nzgd49", "towgs84=59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993", "intl", "New Zealand Geodetic Datum 1949" ], [ "OSGB36", "towgs84=446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894", "airy", "Airy 1830" ], [ null, null, null, null ] ];
                    var pj_prime_meridians = [ [ "greenwich", "0dE" ], [ "lisbon", "9d07'54.862\"W" ], [ "paris", "2d20'14.025\"E" ], [ "bogota", "74d04'51.3\"W" ], [ "madrid", "3d41'16.58\"W" ], [ "rome", "12d27'8.4\"E" ], [ "bern", "7d26'22.5\"E" ], [ "jakarta", "106d48'27.79\"E" ], [ "ferro", "17d40'W" ], [ "brussels", "4d22'4.71\"E" ], [ "stockholm", "18d3'29.8\"E" ], [ "athens", "23d42'58.815\"E" ], [ "oslo", "10d43'22.5\"E" ], [ null, null ] ];

                    function find_prime_meridian( id ) {
                        var defn = pj_prime_meridians.reduce( function( memo, arr ) {
                            return arr[ 0 ] === id ? arr : memo
                        }, null );
                        return defn ? {
                            id: defn[ 0 ],
                            definition: defn[ 1 ]
                        } : null
                    }

                    function find_datum( id ) {
                        var defn = pj_datums.reduce( function( memo, arr ) {
                            return arr[ 0 ] === id ? arr : memo
                        }, null );
                        return defn ? {
                            id: defn[ 0 ],
                            defn: defn[ 1 ],
                            ellipse_id: defn[ 2 ],
                            comments: defn[ 3 ]
                        } : null
                    }

                    function pj_datum_set( P ) {
                        var SEC_TO_RAD = 484813681109536e-20;
                        var params = P.datum_params = [ 0, 0, 0, 0, 0, 0, 0 ];
                        var name, datum, nadgrids, catalog, towgs84;
                        P.datum_type = PJD_UNKNOWN;
                        if ( name = pj_param( P.params, "sdatum" ) ) {
                            datum = find_datum( name );
                            if ( !datum ) {
                                error( -9 )
                            }
                            if ( datum.ellipse_id ) {
                                pj_mkparam( P.params, "ellps=" + datum.ellipse_id )
                            }
                            if ( datum.defn ) {
                                pj_mkparam( P.params, datum.defn )
                            }
                        }
                        if ( nadgrids = pj_param( P.params, "snadgrids" ) ) {
                            fatal( "+nadgrids is not implemented" )
                        } else if ( catalog = pj_param( P.params, "scatalog" ) ) {
                            fatal( "+catalog is not implemented" )
                        } else if ( towgs84 = pj_param( P.params, "stowgs84" ) ) {
                            towgs84.split( "," ).forEach( function( s, i ) {
                                params[ i ] = pj_atof( s ) || 0
                            } );
                            if ( params[ 3 ] != 0 || params[ 4 ] != 0 || params[ 5 ] != 0 || params[ 6 ] != 0 ) {
                                P.datum_type = PJD_7PARAM;
                                params[ 3 ] *= SEC_TO_RAD;
                                params[ 4 ] *= SEC_TO_RAD;
                                params[ 5 ] *= SEC_TO_RAD;
                                params[ 6 ] = params[ 6 ] / 1e6 + 1
                            } else {
                                P.datum_type = PJD_3PARAM
                            }
                        }
                    }
                    var pj_ellps = [ [ "MERIT", "a=6378137.0", "rf=298.257", "MERIT 1983" ], [ "SGS85", "a=6378136.0", "rf=298.257", "Soviet Geodetic System 85" ], [ "GRS80", "a=6378137.0", "rf=298.257222101", "GRS 1980(IUGG, 1980)" ], [ "IAU76", "a=6378140.0", "rf=298.257", "IAU 1976" ], [ "airy", "a=6377563.396", "b=6356256.910", "Airy 1830" ], [ "APL4.9", "a=6378137.0", "rf=298.25", "Appl. Physics. 1965" ], [ "NWL9D", "a=6378145.0", "rf=298.25", "Naval Weapons Lab., 1965" ], [ "mod_airy", "a=6377340.189", "b=6356034.446", "Modified Airy" ], [ "andrae", "a=6377104.43", "rf=300.0", "Andrae 1876 (Den., Iclnd.)" ], [ "aust_SA", "a=6378160.0", "rf=298.25", "Australian Natl & S. Amer. 1969" ], [ "GRS67", "a=6378160.0", "rf=298.2471674270", "GRS 67(IUGG 1967)" ], [ "bessel", "a=6377397.155", "rf=299.1528128", "Bessel 1841" ], [ "bess_nam", "a=6377483.865", "rf=299.1528128", "Bessel 1841 (Namibia)" ], [ "clrk66", "a=6378206.4", "b=6356583.8", "Clarke 1866" ], [ "clrk80", "a=6378249.145", "rf=293.4663", "Clarke 1880 mod." ], [ "clrk80ign", "a=6378249.2", "rf=293.4660212936269", "Clarke 1880 (IGN)." ], [ "CPM", "a=6375738.7", "rf=334.29", "Comm. des Poids et Mesures 1799" ], [ "delmbr", "a=6376428", "rf=311.5", "Delambre 1810 (Belgium)" ], [ "engelis", "a=6378136.05", "rf=298.2566", "Engelis 1985" ], [ "evrst30", "a=6377276.345", "rf=300.8017", "Everest 1830" ], [ "evrst48", "a=6377304.063", "rf=300.8017", "Everest 1948" ], [ "evrst56", "a=6377301.243", "rf=300.8017", "Everest 1956" ], [ "evrst69", "a=6377295.664", "rf=300.8017", "Everest 1969" ], [ "evrstSS", "a=6377298.556", "rf=300.8017", "Everest (Sabah & Sarawak)" ], [ "fschr60", "a=6378166", "rf=298.3", "Fischer (Mercury Datum) 1960" ], [ "fschr60m", "a=6378155", "rf=298.3", "Modified Fischer 1960" ], [ "fschr68", "a=6378150", "rf=298.3", "Fischer 1968" ], [ "helmert", "a=6378200", "rf=298.3", "Helmert 1906" ], [ "hough", "a=6378270.0", "rf=297", "Hough" ], [ "intl", "a=6378388.0", "rf=297", "International 1909 (Hayford)" ], [ "krass", "a=6378245.0", "rf=298.3", "Krassovsky, 1942" ], [ "kaula", "a=6378163", "rf=298.24", "Kaula 1961" ], [ "lerch", "a=6378139", "rf=298.257", "Lerch 1979" ], [ "mprts", "a=6397300", "rf=191", "Maupertius 1738" ], [ "new_intl", "a=6378157.5", "b=6356772.2", "New International 1967" ], [ "plessis", "a=6376523", "b=6355863", "Plessis 1817 (France)" ], [ "SEasia", "a=6378155.0", "b=6356773.3205", "Southeast Asia" ], [ "walbeck", "a=6376896.0", "b=6355834.8467", "Walbeck" ], [ "WGS60", "a=6378165.0", "rf=298.3", "WGS 60" ], [ "WGS66", "a=6378145.0", "rf=298.25", "WGS 66" ], [ "WGS72", "a=6378135.0", "rf=298.26", "WGS 72" ], [ "WGS84", "a=6378137.0", "rf=298.257223563", "WGS 84" ], [ "sphere", "a=6370997.0", "b=6370997.0", "Normal Sphere (r=6370997)" ], [ null, null, null, null ] ];

                    function find_ellps( id ) {
                        var defn = pj_ellps.reduce( function( memo, arr ) {
                            return arr[ 0 ] === id ? arr : memo
                        }, null );
                        return defn ? {
                            id: defn[ 0 ],
                            major: defn[ 1 ],
                            ell: defn[ 2 ],
                            name: defn[ 3 ]
                        } : null
                    }

                    function pj_ell_set( P ) {
                        var SIXTH = .16666666666666666,
                            RA4 = .04722222222222222,
                            RA6 = .022156084656084655,
                            RV4 = .06944444444444445,
                            RV6 = .04243827160493827;
                        var params = P.params;
                        var a = 0;
                        var es = 0;
                        var name, ellps, tmp, b, i;
                        if ( pj_param( params, "tR" ) ) {
                            a = pj_param( params, "dR" )
                        } else {
                            if ( name = pj_param( params, "sellps" ) ) {
                                ellps = find_ellps( name );
                                if ( !ellps ) {
                                    error( -9 )
                                }
                                pj_mkparam( params, ellps.major );
                                pj_mkparam( params, ellps.ell )
                            }
                            a = pj_param( params, "da" );
                            if ( pj_param( params, "tes" ) ) {
                                es = pj_param( params, "des" )
                            } else if ( pj_param( params, "te" ) ) {
                                tmp = pj_param( params, "de" );
                                es = tmp * tmp
                            } else if ( pj_param( params, "trf" ) ) {
                                tmp = pj_param( params, "drf" );
                                if ( !tmp ) {
                                    error( -10 )
                                }
                                tmp = 1 / tmp;
                                es = tmp * ( 2 - tmp )
                            } else if ( pj_param( params, "tf" ) ) {
                                tmp = pj_param( params, "df" );
                                es = tmp * ( 2 - tmp )
                            } else if ( pj_param( params, "tb" ) ) {
                                b = pj_param( params, "db" );
                                es = 1 - b * b / ( a * a )
                            }
                            if ( !b ) {
                                b = a * sqrt( 1 - es )
                            }
                            if ( pj_param( params, "bR_A" ) ) {
                                a *= 1 - es * ( SIXTH + es * ( RA4 + es * RA6 ) );
                                es = 0
                            } else if ( pj_param( params, "bR_V" ) ) {
                                a *= 1 - es * ( SIXTH + es * ( RV4 + es * RV6 ) )
                            } else if ( pj_param( params, "bR_a" ) ) {
                                a = .5 * ( a + b );
                                es = 0
                            } else if ( pj_param( params, "bR_g" ) ) {
                                a = sqrt( a * b );
                                es = 0
                            } else if ( pj_param( params, "bR_h" ) ) {
                                a = 2 * a * b / ( a + b );
                                es = 0
                            } else if ( i = pj_param( params, "tR_lat_a" ) || pj_param( params, "tR_lat_g" ) ) {
                                tmp = sin( pj_param( params, i ? "rR_lat_a" : "rR_lat_g" ) );
                                if ( fabs( tmp ) > M_HALFPI ) {
                                    error( -11 )
                                }
                                tmp = 1 - es * tmp * tmp;
                                a *= i ? .5 * ( 1 - es + tmp ) / ( tmp * sqrt( tmp ) ) : sqrt( 1 - es ) / tmp;
                                es = 0
                            }
                        }
                        if ( es < 0 ) error( -12 );
                        if ( a <= 0 ) error( -13 );
                        P.es = es;
                        P.a = a
                    }
                    var pj_units = [ [ "km", "1000", "Kilometer" ], [ "m", "1", "Meter" ], [ "dm", "1/10", "Decimeter" ], [ "cm", "1/100", "Centimeter" ], [ "mm", "1/1000", "Millimeter" ], [ "kmi", "1852.0", "International Nautical Mile" ], [ "in", "0.0254", "International Inch" ], [ "ft", "0.3048", "International Foot" ], [ "yd", "0.9144", "International Yard" ], [ "mi", "1609.344", "International Statute Mile" ], [ "fath", "1.8288", "International Fathom" ], [ "ch", "20.1168", "International Chain" ], [ "link", "0.201168", "International Link" ], [ "us-in", "1/39.37", "U.S. Surveyor's Inch" ], [ "us-ft", "0.304800609601219", "U.S. Surveyor's Foot" ], [ "us-yd", "0.914401828803658", "U.S. Surveyor's Yard" ], [ "us-ch", "20.11684023368047", "U.S. Surveyor's Chain" ], [ "us-mi", "1609.347218694437", "U.S. Surveyor's Statute Mile" ], [ "ind-yd", "0.91439523", "Indian Yard" ], [ "ind-ft", "0.30479841", "Indian Foot" ], [ "ind-ch", "20.11669506", "Indian Chain" ], [ null, null, null ] ];

                    function find_units( id ) {
                        var arr = pj_units.reduce( function( memo, defn ) {
                            return id === defn[ 0 ] ? defn : memo
                        }, null );
                        return arr ? {
                            id: arr[ 0 ],
                            to_meter: arr[ 1 ],
                            name: arr[ 2 ]
                        } : null
                    }
                    var cache = {};

                    function pj_search_initcache( key ) {
                        return cache[ key.toLowerCase() ] || null
                    }

                    function pj_insert_initcache( key, defn ) {
                        cache[ key.toLowerCase() ] = defn
                    }

                    function pj_read_lib_opts( file, id ) {
                        var path, str;
                        try {
                            path = require( "path" ).join( __dirname, "../nad", file );
                            str = pj_read_opts( path, id )
                        } catch ( e ) {}
                        return str || null
                    }

                    function pj_read_opts( path, id ) {
                        var contents = require( "fs" ).readFileSync( path, "utf8" ),
                            str = "",
                            idx;
                        idx = contents.indexOf( "<" + id + ">" );
                        if ( idx > -1 ) {
                            str = contents.substr( idx + id.length + 2 );
                            str = str.substr( 0, str.indexOf( "<" ) )
                        }
                        str = str.replace( /#.*/g, "" );
                        str = str.replace( /[\s]+/g, " " );
                        str = str.replace( /\+title=[^+]*[^ +]/g, function( match ) {
                            return match.replace( / /g, "\t" )
                        } );
                        str = " " + str;
                        str = str.replace( / (?=[a-z])/gi, " +" );
                        str = str.replace( /\t/g, " " );
                        return str.trim() || null
                    }

                    function pj_init( args ) {
                        var params = pj_get_params( args );
                        var P = {
                            params: params,
                            is_latlong: false,
                            is_geocent: false,
                            is_long_wrap_set: false,
                            long_wrap_center: 0,
                            axis: "enu",
                            gridlist: null,
                            gridlist_count: 0,
                            vgridlist_geoid: null,
                            vgridlist_geoid_count: 0
                        };
                        var name, defn;
                        if ( !Object.keys( params ).length ) {
                            error( -1 )
                        }
                        if ( pj_param( params, "tinit" ) ) {
                            get_init( params, pj_param( params, "sinit" ) )
                        }
                        name = pj_param( params, "sproj" );
                        if ( !name ) {
                            error( -4 )
                        }
                        defn = pj_list[ name ];
                        if ( !defn ) {
                            error( -5 )
                        }
                        if ( !pj_param( params, "bno_defs" ) ) {
                            get_defaults( P.params, name )
                        }
                        pj_datum_set( P );
                        pj_ell_set( P );
                        P.a_orig = P.a;
                        P.es_orig = P.es;
                        P.e = sqrt( P.es );
                        P.ra = 1 / P.a;
                        P.one_es = 1 - P.es;
                        if ( !P.one_es ) {
                            error( -6 )
                        }
                        P.rone_es = 1 / P.one_es;
                        if ( is_wgs84( P ) ) {
                            P.datum_type = PJD_WGS84
                        }
                        P.geoc = !!P.es && pj_param( params, "bgeoc" );
                        P.over = pj_param( params, "bover" );
                        P.has_geoid_vgrids = pj_param( params, "tgeoidgrids" );
                        if ( P.has_geoid_vgrids ) {
                            pj_param( params, "sgeoidgrids" )
                        }
                        P.is_long_wrap_set = pj_param( params, "tlon_wrap" );
                        if ( P.is_long_wrap_set ) {
                            P.long_wrap_center = pj_param( params, "rlon_wrap" )
                        }
                        if ( pj_param( params, "saxis" ) ) {
                            init_axis( P )
                        }
                        P.lam0 = pj_param( params, "rlon_0" );
                        P.phi0 = pj_param( params, "rlat_0" );
                        P.x0 = pj_param( params, "dx_0" );
                        P.y0 = pj_param( params, "dy_0" );
                        if ( pj_param( params, "tk_0" ) ) {
                            P.k0 = pj_param( params, "dk_0" )
                        } else if ( pj_param( params, "tk" ) ) {
                            P.k0 = pj_param( params, "dk" )
                        } else {
                            P.k0 = 1
                        }
                        if ( P.k0 <= 0 ) {
                            error( -31 )
                        }
                        init_units( P );
                        init_prime_meridian( P );
                        defn.init( P );
                        return P
                    }

                    function get_defaults( params, name ) {
                        get_opt( params, "+ellps=WGS84" )
                    }

                    function get_init( params, initStr ) {
                        var defn = pj_search_initcache( initStr ),
                            parts, paramStr;
                        if ( defn ) return defn;
                        parts = initStr.split( ":" );
                        if ( parts.length < 2 ) {
                            error( -3 )
                        }
                        paramStr = pj_read_lib_opts( parts[ 0 ], parts[ 1 ] );
                        if ( !paramStr ) {
                            error( -2 )
                        }
                        pj_insert_initcache( initStr, defn );
                        get_opt( params, paramStr )
                    }

                    function get_opt( params, args ) {
                        var newParams = pj_get_params( args );
                        var geoIsSet = [ "datum", "ellps", "a", "b", "rf", "f" ].reduce( function( memo, key ) {
                            return memo || key in params
                        }, false );
                        Object.keys( newParams ).forEach( function( key ) {
                            if ( key in params ) return;
                            if ( key == "ellps" && geoIsSet ) return;
                            params[ key ] = newParams[ key ]
                        } )
                    }

                    function init_prime_meridian( P ) {
                        var params = P.params,
                            name, pm, offs;
                        name = pj_param( params, "spm" );
                        if ( name ) {
                            pm = find_prime_meridian( name );
                            offs = dmstor( pm ? pm.definition : name );
                            if ( isNaN( offs ) ) {
                                error( -46 )
                            }
                            P.from_greenwich = offs
                        } else {
                            P.from_greenwich = 0
                        }
                    }

                    function init_units( P ) {
                        var params = P.params;
                        var name, s, units;
                        if ( name = pj_param( params, "sunits" ) ) {
                            units = find_units( name );
                            if ( !units ) {
                                error( -7 )
                            }
                            s = units.to_meter
                        }
                        if ( s || ( s = pj_param( params, "sto_meter" ) ) ) {
                            P.to_meter = parse_to_meter( s );
                            P.fr_meter = 1 / P.to_meter
                        } else {
                            P.to_meter = P.fr_meter = 1
                        }
                        s = null;
                        if ( name = pj_param( params, "svunits" ) ) {
                            units = find_units( name );
                            if ( !units ) {
                                error( -7 )
                            }
                            s = units.to_meter
                        }
                        if ( s || pj_param( params, "svto_meter" ) ) {
                            P.vto_meter = parse_to_meter( s );
                            P.vfr_meter = 1 / P.vto_meter
                        } else {
                            P.vto_meter = P.to_meter;
                            P.vfr_meter = P.fr_meter
                        }
                    }

                    function parse_to_meter( s ) {
                        var parts = s.split( "/" );
                        var val = pj_strtod( parts[ 0 ] );
                        if ( parts.length > 1 ) {
                            val /= pj_strtod( parts[ 1 ] )
                        }
                        return val
                    }

                    function init_axis( P ) {
                        var axis_legal = "ewnsud";
                        var axis = pj_param( P.params, "saxis" );
                        if ( axis.length != 3 ) {
                            error( PJD_ERR_AXIS )
                        }
                        if ( axis_legal.indexOf( axis[ 0 ] ) == -1 || axis_legal.indexOf( axis[ 1 ] ) == -1 || axis_legal.indexOf( axis[ 2 ] ) == -1 ) {
                            error( PJD_ERR_AXIS )
                        }
                        P.axis = axis
                    }

                    function is_wgs84( P ) {
                        return P.datum_type == PJD_3PARAM && P.datum_params[ 0 ] == P.datum_params[ 1 ] == P.datum_params[ 2 ] === 0 && P.a == 6378137 && Math.abs( P.es - .00669437999 ) < 5e-11
                    }
                    var GEOCENT_NO_ERROR = 0,
                        GEOCENT_LAT_ERROR = 1,
                        GEOCENT_LON_ERROR = 2,
                        GEOCENT_A_ERROR = 4,
                        GEOCENT_B_ERROR = 8,
                        GEOCENT_A_LESS_B_ERROR = 16;

                    function pj_Set_Geocentric_Parameters( a, b ) {
                        var err = GEOCENT_NO_ERROR,
                            a2 = a * a,
                            b2 = b * b;
                        if ( a <= 0 ) err |= GEOCENT_A_ERROR;
                        if ( b <= 0 ) err |= GEOCENT_B_ERROR;
                        if ( a < b ) err |= GEOCENT_A_LESS_B_ERROR;
                        return err ? null : {
                            a: a,
                            b: b,
                            a2: a2,
                            b2: b2,
                            e2: ( a2 - b2 ) / a2,
                            ep2: ( a2 - b2 ) / b2
                        }
                    }

                    function pj_Convert_Geodetic_To_Geocentric( gi, i, xx, yy, zz ) {
                        var err = GEOCENT_NO_ERROR,
                            lng = xx[ i ],
                            lat = yy[ i ],
                            height = zz[ i ],
                            x, y, z, rn, sinlat, sin2lat, coslat;
                        if ( lat < -M_HALFPI && lat > -1.001 * M_HALFPI ) {
                            lat = -M_HALFPI
                        } else if ( lat > M_HALFPI && lat < 1.001 * M_HALFPI ) {
                            lat = M_HALFPI
                        } else if ( lat < -M_HALFPI || lat > M_HALFPI ) {
                            err |= GEOCENT_LAT_ERROR
                        }
                        if ( !err ) {
                            if ( lng > M_PI ) lng -= 2 * M_PI;
                            sinlat = sin( lat );
                            coslat = cos( lat );
                            sin2lat = sinlat * sinlat;
                            rn = gi.a / sqrt( 1 - gi.e2 * sin2lat );
                            xx[ i ] = ( rn + height ) * coslat * cos( lng );
                            yy[ i ] = ( rn + height ) * coslat * sin( lng );
                            zz[ i ] = ( rn * ( 1 - gi.e2 ) + height ) * sinlat
                        }
                        return err
                    }

                    function pj_Convert_Geocentric_To_Geodetic( gi, i, xx, yy, zz ) {
                        var EPS = 1e-12,
                            EPS2 = EPS * EPS,
                            MAXITER = 30,
                            x = xx[ i ],
                            y = yy[ i ],
                            z = zz[ i ],
                            lat, lng, height, p, rr, ct, st, rx, rn, rk, cphi0, sphi0, cphi, sphi, sdphi, iter;
                        p = sqrt( x * x + y * y );
                        rr = sqrt( x * x + y * y + z * z );
                        if ( p / gi.a < EPS ) {
                            lng = 0;
                            if ( rr / gi.a < EPS ) {
                                xx[ i ] = 0;
                                yy[ i ] = M_HALFPI;
                                zz[ i ] = -gi.b;
                                return 0
                            }
                        } else {
                            lng = atan2( y, x )
                        }
                        ct = z / rr;
                        st = p / rr;
                        rx = 1 / sqrt( 1 - gi.e2 * ( 2 - gi.e2 ) * st * st );
                        cphi0 = st * ( 1 - gi.e2 ) * rx;
                        sphi0 = ct * rx;
                        iter = 0;
                        do {
                            iter++;
                            rn = gi.a / sqrt( 1 - gi.e2 * sphi0 * sphi0 );
                            height = p * cphi0 + z * sphi0 - rn * ( 1 - gi.e2 * sphi0 * sphi0 );
                            rk = gi.e2 * rn / ( rn + height );
                            rx = 1 / sqrt( 1 - rk * ( 2 - rk ) * st * st );
                            cphi = st * ( 1 - rk ) * rx;
                            sphi = ct * rx;
                            sdphi = sphi * cphi0 - cphi * sphi0;
                            cphi0 = cphi;
                            sphi0 = sphi
                        } while ( sdphi * sdphi > EPS2 && iter < MAXITER );
                        lat = atan( sphi / fabs( cphi ) );
                        xx[ i ] = lng;
                        yy[ i ] = lat;
                        zz[ i ] = height
                    }

                    function pj_transform_point( srcdefn, dstdefn, p ) {
                        var z = p.length > 2,
                            xx = [ p[ 0 ] ],
                            yy = [ p[ 1 ] ],
                            zz = [ z ? p[ 2 ] : 0 ];
                        if ( srcdefn.is_latlong ) {
                            xx[ 0 ] *= DEG_TO_RAD;
                            yy[ 0 ] *= DEG_TO_RAD
                        }
                        ctx.last_errno = 0;
                        pj_transform( srcdefn, dstdefn, xx, yy, zz );
                        if ( ctx.last_errno || xx[ 0 ] == HUGE_VAL ) {
                            fatal( null, {
                                point: p
                            } )
                        }
                        if ( dstdefn.is_latlong ) {
                            xx[ 0 ] *= RAD_TO_DEG;
                            yy[ 0 ] *= RAD_TO_DEG
                        }
                        p[ 0 ] = xx[ 0 ];
                        p[ 1 ] = yy[ 0 ];
                        if ( z ) p[ 2 ] = zz[ 0 ]
                    }

                    function pj_transform( srcdefn, dstdefn, xx, yy, zz ) {
                        var point_count = xx.length;
                        var lp = {};
                        var xy = {};
                        var err, i, tmp;
                        if ( srcdefn.axis != "enu" ) {
                            pj_adjust_axis( srcdefn.axis, false, xx, yy, zz )
                        }
                        if ( srcdefn.vto_meter != 1 && zz ) {
                            for ( i = 0; i < point_count; i++ ) zz[ i ] *= srcdefn.vto_meter
                        }
                        if ( srcdefn.is_geocent ) {
                            if ( !zz ) {
                                error( PJD_ERR_GEOCENTRIC )
                            }
                            if ( srcdefn.to_meter != 1 ) {
                                for ( i = 0; i < point_count; i++ ) {
                                    if ( xx[ i ] != HUGE_VAL ) {
                                        xx[ i ] *= srcdefn.to_meter;
                                        yy[ i ] *= srcdefn.to_meter
                                    }
                                }
                            }
                            pj_geocentric_to_geodetic( srcdefn.a_orig, srcdefn.es_orig, xx, yy, zz )
                        } else if ( !srcdefn.is_latlong ) {
                            if ( !srcdefn.inv3d && !srcdefn.inv ) {
                                fatal( "source projection not invertible" )
                            }
                            if ( srcdefn.inv3d ) {
                                fatal( "inverse 3d transformations not supported" )
                            } else {
                                for ( i = 0; i < point_count; i++ ) {
                                    xy.x = xx[ i ];
                                    xy.y = yy[ i ];
                                    tmp = pj_inv( xy, srcdefn );
                                    xx[ i ] = tmp.lam;
                                    yy[ i ] = tmp.phi;
                                    check_fatal_error()
                                }
                            }
                        }
                        if ( srcdefn.from_greenwich !== 0 ) {
                            for ( i = 0; i < point_count; i++ ) {
                                if ( xx[ i ] != HUGE_VAL ) {
                                    xx[ i ] += srcdefn.from_greenwich
                                }
                            }
                        }
                        if ( srcdefn.has_geoid_vgrids && zz ) {
                            fatal( "vgrid transformation not supported" )
                        }
                        pj_datum_transform( srcdefn, dstdefn, xx, yy, zz );
                        if ( dstdefn.has_geoid_vgrids && zz ) {
                            fatal( "vgrid transformation not supported" )
                        }
                        if ( dstdefn.from_greenwich !== 0 ) {
                            for ( i = 0; i < point_count; i++ ) {
                                if ( xx[ i ] != HUGE_VAL ) {
                                    xx[ i ] -= dstdefn.from_greenwich
                                }
                            }
                        }
                        if ( dstdefn.is_geocent ) {
                            if ( !zz ) {
                                error( PJD_ERR_GEOCENTRIC )
                            }
                            pj_geodetic_to_geocentric( dstdefn.a_orig, dstdefn.es_orig, xx, yy, zz );
                            if ( dstdefn.fr_meter != 1 ) {
                                for ( i = 0; i < point_count; i++ ) {
                                    if ( xx[ i ] != HUGE_VAL ) {
                                        xx[ i ] *= dstdefn.fr_meter;
                                        yy[ i ] *= dstdefn.fr_meter
                                    }
                                }
                            }
                        } else if ( !dstdefn.is_latlong ) {
                            if ( dstdefn.fwd3d ) {
                                fatal( "3d transformation not supported" )
                            } else {
                                for ( i = 0; i < point_count; i++ ) {
                                    lp.lam = xx[ i ];
                                    lp.phi = yy[ i ];
                                    tmp = pj_fwd( lp, dstdefn );
                                    xx[ i ] = tmp.x;
                                    yy[ i ] = tmp.y;
                                    check_fatal_error()
                                }
                            }
                        } else if ( dstdefn.is_latlong && dstdefn.is_long_wrap_set ) {
                            for ( i = 0; i < point_count; i++ ) {
                                if ( xx[ i ] == HUGE_VAL ) continue;
                                while ( xx[ i ] < dstdefn.long_wrap_center - M_PI ) {
                                    xx[ i ] += M_TWOPI
                                }
                                while ( xx[ i ] > dstdefn.long_wrap_center + M_PI ) {
                                    xx[ i ] -= M_TWOPI
                                }
                            }
                        }
                        if ( dstdefn.vto_meter != 1 && zz ) {
                            for ( i = 0; i < point_count; i++ ) {
                                zz[ i ] *= dstdefn.vfr_meter
                            }
                        }
                        if ( dstdefn.axis != "enu" ) {
                            pj_adjust_axis( dstdefn.axis, true, xx, yy, zz )
                        }
                        return point_count == 1 ? ctx.last_errno : 0
                    }

                    function pj_adjust_axis( axis, denormalize_flag, xx, yy, zz ) {
                        var point_count = xx.length;
                        var x_in, y_in, z_in = 0;
                        var i, i_axis, value, target;
                        if ( !denormalize_flag ) {
                            for ( i = 0; i < point_count; i++ ) {
                                x_in = xx[ i ];
                                y_in = yy[ i ];
                                if ( x_in == HUGE_VAL ) continue;
                                if ( zz ) z_in = zz[ i ];
                                for ( i_axis = 0; i_axis < 3; i_axis++ ) {
                                    if ( i_axis == 0 ) value = x_in;
                                    else if ( i_axis == 1 ) value = y_in;
                                    else value = z_in;
                                    switch ( axis[ i_axis ] ) {
                                        case "e":
                                            xx[ i ] = value;
                                            break;
                                        case "w":
                                            xx[ i ] = -value;
                                            break;
                                        case "n":
                                            yy[ i ] = value;
                                            break;
                                        case "s":
                                            yy[ i ] = -value;
                                            break;
                                        case "u":
                                            if ( zz ) zz[ i ] = value;
                                            break;
                                        case "d":
                                            if ( zz ) zz[ i ] = -value;
                                            break;
                                        default:
                                            error( PJD_ERR_AXIS )
                                    }
                                }
                            }
                        } else {
                            for ( i = 0; i < point_count; i++ ) {
                                x_in = xx[ i ];
                                y_in = yy[ i ];
                                if ( x_in == HUGE_VAL ) continue;
                                if ( zz ) z_in = zz[ i ];
                                for ( i_axis = 0; i_axis < 3; i_axis++ ) {
                                    if ( i_axis == 2 && !zz ) continue;
                                    if ( i_axis == 0 ) target = xx;
                                    else if ( i_axis == 1 ) target = yy;
                                    else target = zz;
                                    switch ( axis[ i_axis ] ) {
                                        case "e":
                                            target[ i ] = x_in;
                                            break;
                                        case "w":
                                            target[ i ] = -x_in;
                                            break;
                                        case "n":
                                            target[ i ] = y_in;
                                            break;
                                        case "s":
                                            target[ i ] = -y_in;
                                            break;
                                        case "u":
                                            target[ i ] = z_in;
                                            break;
                                        case "d":
                                            target[ i ] = -z_in;
                                            break;
                                        default:
                                            error( PJD_ERR_AXIS )
                                    }
                                }
                            }
                        }
                    }

                    function pj_datum_transform( srcdefn, dstdefn, xx, yy, zz ) {
                        var point_count = xx.length;
                        var src_a, src_es, dst_a, dst_es;
                        var z_is_temp = false;
                        if ( srcdefn.datum_type == PJD_UNKNOWN || dstdefn.datum_type == PJD_UNKNOWN ) {
                            return
                        }
                        if ( pj_compare_datums( srcdefn, dstdefn ) ) {
                            return
                        }
                        src_a = srcdefn.a_orig;
                        src_es = srcdefn.es_orig;
                        dst_a = dstdefn.a_orig;
                        dst_es = dstdefn.es_orig;
                        if ( !zz ) {
                            zz = new Float64Array( point_count );
                            z_is_temp = true
                        }
                        if ( srcdefn.datum_type == PJD_GRIDSHIFT ) {
                            fatal( "gridshift not implemented" );
                            src_a = SRS_WGS84_SEMIMAJOR;
                            src_es = SRS_WGS84_ESQUARED
                        }
                        if ( dstdefn.datum_type == PJD_GRIDSHIFT ) {
                            dst_a = SRS_WGS84_SEMIMAJOR;
                            dst_es = SRS_WGS84_ESQUARED
                        }
                        if ( src_es != dst_es || src_a != dst_a || srcdefn.datum_type == PJD_3PARAM || srcdefn.datum_type == PJD_7PARAM || dstdefn.datum_type == PJD_3PARAM || dstdefn.datum_type == PJD_7PARAM ) {
                            pj_geodetic_to_geocentric( src_a, src_es, xx, yy, zz );
                            if ( srcdefn.datum_type == PJD_3PARAM || srcdefn.datum_type == PJD_7PARAM ) {
                                pj_geocentric_to_wgs84( srcdefn, xx, yy, zz )
                            }
                            if ( dstdefn.datum_type == PJD_3PARAM || dstdefn.datum_type == PJD_7PARAM ) {
                                pj_geocentric_from_wgs84( dstdefn, xx, yy, zz )
                            }
                            pj_geocentric_to_geodetic( dst_a, dst_es, xx, yy, zz );
                            if ( dstdefn.datum_type == PJD_GRIDSHIFT ) {
                                pj_apply_gridshift_2( dstdefn, 1, xx, yy, zz )
                            }
                        }
                    }

                    function pj_compare_datums( srcdefn, dstdefn ) {
                        if ( srcdefn.datum_type != dstdefn.datum_type ) return false;
                        if ( srcdefn.a_orig != dstdefn.a_orig || Math.abs( srcdefn.es_orig - dstdefn.es_orig ) > 5e-11 ) {
                            return false
                        }
                        if ( srcdefn.datum_type == PJD_3PARAM ) {
                            return srcdefn.datum_params[ 0 ] == dstdefn.datum_params[ 0 ] && srcdefn.datum_params[ 1 ] == dstdefn.datum_params[ 1 ] && srcdefn.datum_params[ 2 ] == dstdefn.datum_params[ 2 ]
                        }
                        if ( srcdefn.datum_type == PJD_7PARAM ) {
                            return srcdefn.datum_params[ 0 ] == dstdefn.datum_params[ 0 ] && srcdefn.datum_params[ 1 ] == dstdefn.datum_params[ 1 ] && srcdefn.datum_params[ 2 ] == dstdefn.datum_params[ 2 ] && srcdefn.datum_params[ 3 ] == dstdefn.datum_params[ 3 ] && srcdefn.datum_params[ 4 ] == dstdefn.datum_params[ 4 ] && srcdefn.datum_params[ 5 ] == dstdefn.datum_params[ 5 ] && srcdefn.datum_params[ 6 ] == dstdefn.datum_params[ 6 ]
                        }
                        if ( srcdefn.datum_type == PJD_GRIDSHIFT ) {
                            return pj_param( srcdefn.params, "snadgrids" ) == pj_param( dstdefn.params, "snadgrids" )
                        }
                        return true
                    }

                    function pj_geocentric_to_wgs84( defn, xx, yy, zz ) {
                        var point_count = xx.length,
                            pp = defn.datum_params,
                            Dx_BF = pp[ 0 ],
                            Dy_BF = pp[ 1 ],
                            Dz_BF = pp[ 2 ],
                            x, y, z, Rx_BF, Ry_BF, Rz_BF, M_BF, i;
                        if ( defn.datum_type == PJD_3PARAM ) {
                            for ( i = 0; i < point_count; i++ ) {
                                if ( xx[ i ] == HUGE_VAL ) continue;
                                xx[ i ] += Dx_BF;
                                yy[ i ] += Dy_BF;
                                zz[ i ] += Dz_BF
                            }
                        } else if ( defn.datum_type == PJD_7PARAM ) {
                            Rx_BF = pp[ 3 ];
                            Ry_BF = pp[ 4 ];
                            Rz_BF = pp[ 5 ];
                            M_BF = pp[ 6 ];
                            for ( i = 0; i < point_count; i++ ) {
                                if ( xx[ i ] == HUGE_VAL ) continue;
                                x = M_BF * ( xx[ i ] - Rz_BF * yy[ i ] + Ry_BF * zz[ i ] ) + Dx_BF;
                                y = M_BF * ( Rz_BF * xx[ i ] + yy[ i ] - Rx_BF * zz[ i ] ) + Dy_BF;
                                z = M_BF * ( -Ry_BF * xx[ i ] + Rx_BF * yy[ i ] + zz[ i ] ) + Dz_BF;
                                xx[ i ] = x;
                                yy[ i ] = y;
                                zz[ i ] = z
                            }
                        }
                    }

                    function pj_geocentric_from_wgs84( defn, xx, yy, zz ) {
                        var point_count = xx.length,
                            pp = defn.datum_params,
                            Dx_BF = pp[ 0 ],
                            Dy_BF = pp[ 1 ],
                            Dz_BF = pp[ 2 ],
                            x, y, z, Rx_BF, Ry_BF, Rz_BF, M_BF, i;
                        if ( defn.datum_type == PJD_3PARAM ) {
                            for ( i = 0; i < point_count; i++ ) {
                                if ( xx[ i ] == HUGE_VAL ) continue;
                                xx[ i ] -= Dx_BF;
                                yy[ i ] -= Dy_BF;
                                zz[ i ] -= Dz_BF
                            }
                        } else if ( defn.datum_type == PJD_7PARAM ) {
                            Rx_BF = pp[ 3 ];
                            Ry_BF = pp[ 4 ];
                            Rz_BF = pp[ 5 ];
                            M_BF = pp[ 6 ];
                            for ( i = 0; i < point_count; i++ ) {
                                if ( xx[ i ] == HUGE_VAL ) continue;
                                x = ( xx[ i ] - Dx_BF ) / M_BF;
                                y = ( yy[ i ] - Dy_BF ) / M_BF;
                                z = ( zz[ i ] - Dz_BF ) / M_BF;
                                xx[ i ] = x + Rz_BF * y - Ry_BF * z;
                                yy[ i ] = -Rz_BF * x + y + Rx_BF * z;
                                zz[ i ] = Ry_BF * x - Rx_BF * y + z
                            }
                        }
                    }

                    function pj_geocentric_to_geodetic( a, es, xx, yy, zz ) {
                        var point_count = xx.length;
                        var b, i, gi;
                        if ( es == 0 ) b = a;
                        else b = a * sqrt( 1 - es );
                        gi = pj_Set_Geocentric_Parameters( a, b );
                        if ( !gi ) {
                            error( PJD_ERR_GEOCENTRIC )
                        }
                        for ( i = 0; i < point_count; i++ ) {
                            if ( xx[ i ] != HUGE_VAL ) {
                                pj_Convert_Geocentric_To_Geodetic( gi, i, xx, yy, zz )
                            }
                        }
                    }

                    function pj_geodetic_to_geocentric( a, es, xx, yy, zz ) {
                        var point_count = xx.length,
                            b, i, gi;
                        if ( es === 0 ) {
                            b = a
                        } else {
                            b = a * sqrt( 1 - es )
                        }
                        gi = pj_Set_Geocentric_Parameters( a, b );
                        if ( !gi ) {
                            error( PJD_ERR_GEOCENTRIC )
                        }
                        for ( i = 0; i < point_count; i++ ) {
                            if ( xx[ i ] == HUGE_VAL ) continue;
                            if ( pj_Convert_Geodetic_To_Geocentric( gi, i, xx, yy, zz ) ) {
                                xx[ i ] = yy[ i ] = HUGE_VAL
                            }
                        }
                    }

                    function adjlon( lon ) {
                        var SPI = 3.14159265359,
                            TWOPI = 6.283185307179586,
                            ONEPI = 3.141592653589793;
                        if ( fabs( lon ) > SPI ) {
                            lon += ONEPI;
                            lon -= TWOPI * floor( lon / TWOPI );
                            lon -= ONEPI
                        }
                        return lon
                    }

                    function pj_fwd_deg( lp, P ) {
                        var lp2 = {
                            lam: lp.lam * DEG_TO_RAD,
                            phi: lp.phi * DEG_TO_RAD
                        };
                        return pj_fwd( lp2, P )
                    }

                    function pj_fwd( lp, P ) {
                        var xy = {
                            x: 0,
                            y: 0
                        };
                        var EPS = 1e-12;
                        var t = fabs( lp.phi ) - M_HALFPI;
                        if ( !( t <= EPS && fabs( lp.lam ) <= 10 ) ) {
                            pj_ctx_set_errno( -14 )
                        } else {
                            ctx.last_errno = 0;
                            if ( fabs( t ) <= EPS ) {
                                lp.phi = lp.phi < 0 ? -M_HALFPI : M_HALFPI
                            } else if ( P.geoc ) {
                                lp.phi = atan( P.rone_es * tan( lp.phi ) )
                            }
                            lp.lam -= P.lam0;
                            if ( !P.over ) {
                                lp.lam = adjlon( lp.lam )
                            }
                            if ( P.fwd ) {
                                P.fwd( lp, xy );
                                xy.x = P.fr_meter * ( P.a * xy.x + P.x0 );
                                xy.y = P.fr_meter * ( P.a * xy.y + P.y0 )
                            } else {
                                xy.x = xy.y = HUGE_VAL
                            }
                        }
                        if ( ctx.last_errno || isNaN( xy.x ) || isNaN( xy.y ) ) {
                            xy.x = xy.y = HUGE_VAL
                        }
                        return xy
                    }

                    function pj_inv_deg( xy, P ) {
                        var lp = pj_inv( xy, P );
                        return {
                            lam: lp.lam * RAD_TO_DEG,
                            phi: lp.phi * RAD_TO_DEG
                        }
                    }

                    function pj_inv( xy, P ) {
                        var EPS = 1e-12;
                        var lp = {
                            lam: 0,
                            phi: 0
                        };
                        if ( !( xy.x < HUGE_VAL && xy.y < HUGE_VAL ) ) {
                            pj_ctx_set_errno( -15 )
                        } else {
                            ctx.last_errno = 0;
                            if ( P.inv ) {
                                xy.x = ( xy.x * P.to_meter - P.x0 ) * P.ra;
                                xy.y = ( xy.y * P.to_meter - P.y0 ) * P.ra;
                                P.inv( xy, lp );
                                lp.lam += P.lam0;
                                if ( !P.over ) {
                                    lp.lam = adjlon( lp.lam )
                                }
                                if ( P.geoc && fabs( fabs( lp.phi ) - M_HALFPI ) > EPS ) {
                                    lp.phi = atan( P.one_es * tan( lp.phi ) )
                                }
                            } else {
                                lp.lam = lp.phi = HUGE_VAL
                            }
                        }
                        if ( ctx.last_errno || isNaN( lp.lam ) || isNaN( lp.phi ) ) {
                            lp.lam = lp.phi = HUGE_VAL
                        }
                        return lp
                    }

                    function get_rtodms( decimals, fixedWidth, pos, neg ) {
                        var dtodms = get_dtodms( decimals, fixedWidth, pos, neg );
                        return function( r ) {
                            return dtodms( r * RAD_TO_DEG )
                        }
                    }

                    function get_dtodms( decimals, fixedWidth, pos, neg ) {
                        var RES, CONV, i;
                        if ( decimals < 0 || decimals >= 9 ) {
                            decimals = 3
                        }
                        RES = 1;
                        for ( i = 0; i < decimals; i++ ) {
                            RES *= 10
                        }
                        CONV = 3600 * RES;
                        return function( r ) {
                            var sign = "",
                                mstr = "",
                                sstr = "",
                                min, sec, suff, dstr;
                            if ( r === HUGE_VAL || isNaN( r ) ) return "";
                            if ( r < 0 ) {
                                r = -r;
                                suff = neg || "";
                                if ( !suff ) {
                                    sign = "-"
                                }
                            } else {
                                suff = pos || ""
                            }
                            r = floor( r * CONV + .5 );
                            sec = r / RES % 60;
                            r = floor( r / ( RES * 60 ) );
                            min = r % 60;
                            dstr = floor( r / 60 ) + "d";
                            sstr = sec.toFixed( decimals );
                            sec = parseFloat( sstr );
                            if ( sec ) {
                                sstr = ( fixedWidth ? sstr : String( sec ) ) + '"'
                            } else {
                                sstr = ""
                            }
                            if ( sec || min ) {
                                mstr = String( min ) + "'";
                                if ( mstr.length == 2 && fixedWidth ) {
                                    mstr = "0" + mstr
                                }
                            }
                            return sign + dstr + mstr + sstr + suff
                        }
                    }

                    function proj4js( arg1, arg2, arg3 ) {
                        var oneArg = typeof arg2 !== "string";
                        var p, fromStr, toStr, P1, P2, transform;
                        if ( oneArg ) {
                            fromStr = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";
                            toStr = arg1;
                            p = arg2
                        } else {
                            fromStr = arg1;
                            toStr = arg2;
                            p = arg3
                        }
                        P1 = pj_init( fromStr );
                        P2 = pj_init( toStr );
                        transform = get_proj4js_transform( P1, P2 );
                        if ( p ) {
                            return transform( p )
                        } else {
                            return {
                                forward: transform,
                                inverse: get_proj4js_transform( P2, P1 )
                            }
                        }
                    }
                    proj4js.WGS84 = "+proj=longlat +datum=WGS84";
                    proj4js.toPoint = function( array ) {
                        var out = {
                            x: array[ 0 ],
                            y: array[ 1 ]
                        };
                        if ( array.length > 2 ) {
                            out.z = array[ 2 ]
                        }
                        if ( array.length > 3 ) {
                            out.m = array[ 3 ]
                        }
                        return out
                    };

                    function get_proj4js_transform( P1, P2 ) {
                        return function( p ) {
                            var useArray = Array.isArray( p );
                            p = useArray ? p.concat() : [ p.x, p.y ];
                            pj_transform_point( P1, P2, p );
                            if ( !useArray ) {
                                p = {
                                    x: p[ 0 ],
                                    y: p[ 1 ]
                                }
                            }
                            return p
                        }
                    }

                    function wkt_error( msg ) {
                        throw new Error( msg )
                    }

                    function wkt_warn( msg ) {
                        console.error( msg )
                    }
                    var wkt_projections = [ [ "aitoff", "Aitoff" ], [ "aea", "Albers_Conic_Equal_Area" ], [ "aea", "Albers" ], [ "aeqd", "Azimuthal_Equidistant" ], [ "cass", "Cassini_Soldner" ], [ "cass", "Cassini" ], [ "cea", "Cylindrical_Equal_Area" ], [ "bonne", "Bonne" ], [ "eck1", "Eckert_I" ], [ "eck2", "Eckert_II" ], [ "eck3", "Eckert_III" ], [ "eck4", "Eckert_IV" ], [ "eck5", "Eckert_V" ], [ "eck6", "Eckert_VI" ], [ "eqdc", "Equidistant_Conic" ], [ "eqc", "Equidistant_Cylindrical" ], [ "eqc", "Plate_Carree" ], [ "eqc", "Equirectangular" ], [ "gall", "Gall_Stereographic" ], [ "gnom", "Gnomonic" ], [ "lcc", "Lambert_Conformal_Conic" ], [ "lcc", "Lambert_Conformal_Conic_1SP" ], [ "lcc", "Lambert_Conformal_Conic_2SP" ], [ "laea", "Lambert_Azimuthal_Equal_Area" ], [ "loxim", "Loximuthal" ], [ "merc", "Mercator" ], [ "merc", "Mercator_1SP" ], [ "merc", "Mercator_2SP" ], [ "merc", "Mercator_Auxiliary_Sphere" ], [ "mill", "Miller_Cylindrical" ], [ "moll", "Mollweide" ], [ "nsper", "Vertical_Near_Side_Perspective" ], [ "omerc", "Hotine_Oblique_Mercator" ], [ "omerc", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin" ], [ "omerc", "Oblique_Mercator" ], [ "omerc", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin" ], [ "omerc", "Hotine_Oblique_Mercator_Azimuth_Center" ], [ "ortho", "Orthographic" ], [ "poly", "Polyconic" ], [ "robin", "Robinson" ], [ "sinu", "Sinusoidal" ], [ "stere", "Stereographic" ], [ "stere", "Stereographic_North_Pole" ], [ "stere", "Stereographic_South_Pole" ], [ "stere", "Polar_Stereographic" ], [ "sterea", "Double_Stereographic" ], [ "sterea", "Oblique_Stereographic" ], [ "tmerc", "Transverse_Mercator" ], [ "tpeqd", "Two_Point_Equidistant" ], [ "vandg", "VanDerGrinten" ], [ "vandg", "Van_der_Grinten_I" ], [ "wag1", "Wagner_I" ], [ "wag2", "Wagner_II" ], [ "wag3", "Wagner_III" ], [ "wag4", "Wagner_IV" ], [ "wag5", "Wagner_V" ], [ "wag6", "Wagner_VI" ], [ "wag7", "Wagner_VII" ], [ "wink1", "Winkel_I" ], [ "wink2", "Winkel_II" ], [ "wintri", "Winkel_Tripel" ], [] ];

                    function wkt_get_proj( name ) {
                        var defn, i;
                        for ( i = 0; i < wkt_projections.length; i++ ) {
                            defn = wkt_projections[ i ];
                            if ( defn[ 1 ] == name ) {
                                return {
                                    proj: defn[ 0 ],
                                    wkt: defn[ 1 ]
                                }
                            }
                        }
                        return null
                    }

                    function wkt_convert_geogcs( geogcs, opts ) {
                        var datum = geogcs.DATUM,
                            spheroid = datum.SPHEROID,
                            datumName = wkt_harmonize_geo_name( datum.NAME ),
                            sphName = wkt_harmonize_geo_name( spheroid[ 0 ] ),
                            aux_sphere = opts && opts.aux_sphere,
                            a = spheroid[ 1 ],
                            rf = spheroid[ 2 ],
                            str, pm;
                        wkt_check_units( geogcs.UNIT, "degree" );
                        if ( aux_sphere ) {
                            str = "+a=" + spheroid[ 1 ]
                        } else if ( datumName == "wgs1984" ) {
                            str = "+datum=WGS84"
                        } else if ( datumName == "northamerican1983" ) {
                            str = "+datum=NAD83"
                        } else if ( datumName == "osgb1936" ) {
                            str = "+datum=OSGB36"
                        } else if ( sphName == "grs1980" ) {
                            str = "+ellps=GRS80"
                        } else {
                            str = "+a=" + a;
                            if ( rf > 0 ) {
                                str += " +rf=" + rf
                            }
                        }
                        if ( datum.TOWGS84 && !aux_sphere ) {
                            str += " +towgs84=" + datum.TOWGS84.join( "," )
                        }
                        pm = geogcs.PRIMEM ? geogcs.PRIMEM[ 1 ] : 0;
                        if ( pm > 0 || pm < 0 ) {
                            str += " +pm=" + pm
                        }
                        return str
                    }

                    function wkt_harmonize_geo_name( name ) {
                        return name.replace( /^(GCS|D)_/i, "" ).replace( /[ _]/g, "" ).toLowerCase()
                    }

                    function wkt_check_units( UNIT, expect ) {
                        if ( UNIT && UNIT[ 0 ].toLowerCase() != expect ) {
                            wkt_error( "unexpected geographic units: " + geogcs.UNIT[ 0 ] )
                        }
                    }
                    var wkt_params = [ [ "x_0", "false_easting" ], [ "y_0", "false_northing" ], [ "k_0", "scale_factor" ], [ "lon_0", "longitude_of_center" ], [ "lat_0", "latitude_of_center" ], [ "lat_1", "standard_parallel_1" ], [ "lat_2", "standard_parallel_2" ], [ "lat_1", "latitude_of_point_1" ], [ "lon_1", "longitude_of_point_1" ], [ "lon_2", "longitude_of_point_2" ], [ "lat_1", "latitude_of_point_1" ], [ "lat_2", "latitude_of_point_2" ], [ "h", "height" ] ];
                    var wkt_param_aliases = {
                        central_meridian: "longitude_of_center",
                        latitude_of_origin: "latitude_of_center",
                        longitude_of_1st_point: "longitude_of_point_1",
                        longitude_of_2nd_point: "longitude_of_point_2",
                        latitude_of_1st_point: "latitude_of_point_1",
                        latitude_of_2nd_point: "latitude_of_point_2"
                    };

                    function wkt_find_param( wktName ) {
                        for ( var i = 0; i < wkt_params.length; i++ ) {
                            if ( wkt_params[ i ][ 1 ] == wktName ) {
                                return wkt_params[ i ][ 0 ]
                            }
                        }
                        return ""
                    }

                    function wkt_harmonize_param_name( name ) {
                        name = name.toLowerCase();
                        return wkt_param_aliases[ name ] || name
                    }

                    function wkt_convert_params( params, projDefn, unitDefn ) {
                        var index = {};
                        var parts = [];
                        params.forEach( function( param ) {
                            var pair = wkt_convert_param( param, projDefn, unitDefn ),
                                val, name;
                            if ( pair ) {
                                name = pair[ 0 ];
                                val = pair[ 1 ];
                                index[ name ] = val;
                                parts.push( "+" + name + "=" + val )
                            }
                        } );
                        if ( projDefn.proj == "lcc" ) {
                            if ( "lat_0" in index && "lat_1" in index === false ) {
                                parts.push( "+lat_1=" + index.lat_0 )
                            }
                        }
                        if ( projDefn.proj == "omerc" ) {
                            if ( projDefn.wkt == "Hotine_Oblique_Mercator" || projDefn.wkt == "Hotine_Oblique_Mercator_Azimuth_Natural_Origin" ) {
                                parts.push( "+no_uoff" )
                            }
                        }
                        return parts.join( " " )
                    }

                    function wkt_convert_param( param, projDefn, unitDefn ) {
                        var projName = projDefn.proj;
                        var wktName = wkt_harmonize_param_name( param[ 0 ] );
                        var val = param[ 1 ];
                        var p4Name;
                        if ( projName == "stere" ) {
                            if ( wktName == "standard_parallel_1" ) p4Name = "lat_0"
                        }
                        if ( projName == "omerc" ) {
                            if ( wktName == "longitude_of_center" ) p4Name = "lonc";
                            if ( wktName == "azimuth" ) p4Name = "alpha";
                            if ( wktName == "rectified_grid_angle" ) p4Name = "gamma"
                        }
                        if ( projName == "merc" ) {
                            if ( projDefn.wkt == "Mercator_2SP" && wktName == "standard_parallel_1" ) {
                                p4Name = "lat_ts"
                            }
                        }
                        if ( projName == "eqc" ) {
                            if ( wktName == "standard_parallel_1" ) {
                                p4Name = "lat_ts"
                            }
                        }
                        if ( !p4Name ) {
                            p4Name = wkt_find_param( wktName )
                        }
                        if ( p4Name == "x_0" || p4Name == "y_0" || p4Name == "h" ) {
                            val *= unitDefn.to_meter
                        }
                        if ( WKT_OMIT_DEFAULTS ) {
                            if ( "x_0,y_0,lat_0,lon_0".indexOf( p4Name ) > -1 && val === 0 || p4Name == "k_0" && val == 1 ) {
                                return
                            }
                        }
                        if ( p4Name ) {
                            return [ p4Name, val ]
                        }
                        wkt_warn( "unhandled param: " + param[ 0 ] )
                    }

                    function wkt_get_unit( param ) {
                        return {
                            to_meter: param[ 1 ]
                        }
                    }
                    var wkt_aliases = {};

                    function wkt_parse( str ) {
                        var obj;
                        str = str.replace( /""/g, '\\"' );
                        str = str.replace( /([A-Z0-9]+)\[/g, '["$1",' );
                        str = str.replace( /, *([a-zA-Z]+) *(?=[,\]])/g, ',"$1"' );
                        try {
                            obj = JSON.parse( str )
                        } catch ( e ) {
                            wkt_error( "unparsable WKT format" )
                        }
                        return wkt_reorder( obj, {} )
                    }

                    function wkt_harmonize_keyword( name ) {
                        return wkt_aliases[ name ] || name
                    }

                    function wkt_reorder( arr, obj ) {
                        var name = wkt_harmonize_keyword( arr[ 0 ] ),
                            i;
                        if ( name == "GEOGCS" || name == "GEOCCS" || name == "PROJCS" || name == "DATUM" ) {
                            obj[ name ] = {
                                NAME: arr[ 1 ]
                            };
                            for ( i = 2; i < arr.length; i++ ) {
                                if ( Array.isArray( arr[ i ] ) ) {
                                    wkt_reorder( arr[ i ], obj[ name ] )
                                } else {
                                    throw wkt_error( "WKT parse error" )
                                }
                            }
                        } else if ( name == "AXIS" || name == "PARAMETER" ) {
                            if ( name in obj === false ) {
                                obj[ name ] = []
                            }
                            obj[ name ].push( arr.slice( 1 ) )
                        } else {
                            obj[ name ] = arr.slice( 1 )
                        }
                        return obj
                    }
                    var WKT_OMIT_DEFAULTS = true;

                    function wkt_to_proj4( str ) {
                        var o = wkt_parse( str );
                        var proj4;
                        if ( o.PROJCS ) {
                            proj4 = wkt_convert_projection( o.PROJCS )
                        } else if ( o.GEOGCS ) {
                            proj4 = "+proj=longlat " + wkt_convert_geogcs( o.GEOGCS )
                        } else if ( o.GEOCCS ) {
                            wkt_error( "geocentric coordinates are not supported" )
                        } else {
                            wkt_error( "missing a supported WKT CS type" )
                        }
                        return proj4
                    }

                    function wkt_convert_projection( obj ) {
                        var projDefn = wkt_get_proj( obj.PROJECTION );
                        var wktName = obj.NAME.replace( / /g, "_" );
                        var unitDefn, i, match, projStr, geogStr, paramStr;
                        unitDefn = wkt_get_unit( obj.UNIT );
                        if ( !projDefn ) {
                            wkt_error( "unknown projection: " + obj.PROJECTION )
                        }
                        if ( !projDefn.proj ) {
                            wkt_error( "projection not implemented: " + obj.PROJECTION )
                        }
                        if ( match = /UPS_(North|South)/i.exec( wktName ) ) {
                            projStr = "+proj=ups";
                            if ( match[ 1 ].toLowerCase() == "south" ) {
                                projStr += " +south"
                            }
                        } else if ( match = /UTM_zone_([1-9]{1,2})(N|S)/i.exec( wktName ) ) {
                            projStr = "+proj=utm +zone=" + match[ 1 ];
                            if ( match[ 2 ] == "S" ) {
                                projStr += " +south"
                            }
                        } else if ( /(Web_Mercator|Pseudo-Mercator)/i.test( wktName ) ) {
                            projStr = "+proj=merc";
                            geogStr = wkt_convert_geogcs( obj.GEOGCS, {
                                aux_sphere: true
                            } )
                        } else {
                            projStr = "+proj=" + projDefn.proj;
                            paramStr = wkt_convert_params( obj.PARAMETER || [], projDefn, unitDefn );
                            if ( paramStr ) projStr += " " + paramStr
                        }
                        if ( !geogStr ) {
                            geogStr = wkt_convert_geogcs( obj.GEOGCS )
                        }
                        if ( projDefn.proj == "vandg" ) {
                            geogStr += " +R_A"
                        }
                        projStr += " " + geogStr;
                        if ( unitDefn.to_meter != 1 ) {
                            projStr += " +to_meter=" + unitDefn.to_meter
                        } else if ( !WKT_OMIT_DEFAULTS ) {
                            projStr += " +units=m"
                        }
                        return projStr + " +no_defs"
                    }

                    function pj_qsfn( sinphi, e, one_es ) {
                        var EPS = 1e-7;
                        var con;
                        if ( e >= EPS ) {
                            con = e * sinphi;
                            return one_es * ( sinphi / ( 1 - con * con ) - .5 / e * log( ( 1 - con ) / ( 1 + con ) ) )
                        } else return sinphi + sinphi
                    }

                    function pj_msfn( sinphi, cosphi, es ) {
                        return cosphi / sqrt( 1 - es * sinphi * sinphi )
                    }
                    pj_add( pj_aea, "aea", "Albers Equal Area", "\n\tConic Sph&Ell\n\tlat_1= lat_2=" );
                    pj_add( pj_leac, "leac", "Lambert Equal Area Conic", "\n\tConic, Sph&Ell\n\tlat_1= south" );

                    function pj_aea( P ) {
                        var phi1 = pj_param( P.params, "rlat_1" );
                        var phi2 = pj_param( P.params, "rlat_2" );
                        pj_aea_init( P, phi1, phi2 )
                    }

                    function pj_leac( P ) {
                        var phi1 = pj_param( P.params, "rlat_1" );
                        var phi2 = pj_param( P.params, "bsouth" ) ? -M_HALFPI : M_HALFPI;
                        pj_aea_init( P, phi1, phi2 )
                    }

                    function pj_aea_init( P, phi1, phi2 ) {
                        var ec, n, c, dd, n2, rho0, rho, en, ellips, cosphi, sinphi, secant, ml2, m2, ml1, m1;
                        P.fwd = e_fwd;
                        P.inv = e_inv;
                        if ( fabs( phi1 + phi2 ) < EPS10 ) e_error( -21 );
                        n = sinphi = sin( phi1 );
                        cosphi = cos( phi1 );
                        secant = fabs( phi1 - phi2 ) >= EPS10;
                        if ( ellips = P.es > 0 ) {
                            en = pj_enfn( P.es );
                            m1 = pj_msfn( sinphi, cosphi, P.es );
                            ml1 = pj_qsfn( sinphi, P.e, P.one_es );
                            if ( secant ) {
                                sinphi = sin( phi2 );
                                cosphi = cos( phi2 );
                                m2 = pj_msfn( sinphi, cosphi, P.es );
                                ml2 = pj_qsfn( sinphi, P.e, P.one_es );
                                n = ( m1 * m1 - m2 * m2 ) / ( ml2 - ml1 )
                            }
                            ec = 1 - .5 * P.one_es * log( ( 1 - P.e ) / ( 1 + P.e ) ) / P.e;
                            c = m1 * m1 + n * ml1;
                            dd = 1 / n;
                            rho0 = dd * sqrt( c - n * pj_qsfn( sin( P.phi0 ), P.e, P.one_es ) )
                        } else {
                            if ( secant ) n = .5 * ( n + sin( phi2 ) );
                            n2 = n + n;
                            c = cosphi * cosphi + n2 * sinphi;
                            dd = 1 / n;
                            rho0 = dd * sqrt( c - n2 * sin( P.phi0 ) )
                        }

                        function e_fwd( lp, xy ) {
                            var lam = lp.lam;
                            var rho;
                            if ( ( rho = c - ( ellips ? n * pj_qsfn( sin( lp.phi ), P.e, P.one_es ) : n2 * sin( lp.phi ) ) ) < 0 ) f_error();
                            rho = dd * sqrt( rho );
                            xy.x = rho * sin( lam *= n );
                            xy.y = rho0 - rho * cos( lam )
                        }

                        function e_inv( xy, lp ) {
                            var TOL7 = 1e-7,
                                x = xy.x,
                                y = rho0 - xy.y,
                                rho = hypot( x, y );
                            if ( rho != 0 ) {
                                if ( n < 0 ) {
                                    rho = -rho;
                                    x = -x;
                                    y = -y
                                }
                                lp.phi = rho / dd;
                                if ( ellips ) {
                                    lp.phi = ( c - lp.phi * lp.phi ) / n;
                                    if ( fabs( ec - fabs( lp.phi ) ) > TOL7 ) {
                                        if ( ( lp.phi = phi1_( lp.phi, P.e, P.one_es ) ) == HUGE_VAL ) i_error()
                                    } else lp.phi = lp.phi < 0 ? -M_HALFPI : M_HALFPI
                                } else if ( fabs( lp.phi = ( c - lp.phi * lp.phi ) / n2 ) <= 1 ) lp.phi = asin( lp.phi );
                                else lp.phi = lp.phi < 0 ? -M_HALFPI : M_HALFPI;
                                lp.lam = atan2( x, y ) / n
                            } else {
                                lp.lam = 0;
                                lp.phi = n > 0 ? M_HALFPI : -M_HALFPI
                            }
                        }

                        function phi1_( qs, Te, Tone_es ) {
                            var N_ITER = 15,
                                EPSILON = 1e-7,
                                TOL = 1e-10;
                            var Phi, sinpi, cospi, con, com, dphi, i;
                            Phi = asin( .5 * qs );
                            if ( Te < EPSILON ) return Phi;
                            i = N_ITER;
                            do {
                                sinpi = sin( Phi );
                                cospi = cos( Phi );
                                con = Te * sinpi;
                                com = 1 - con * con;
                                dphi = .5 * com * com / cospi * ( qs / Tone_es - sinpi / com + .5 / Te * log( ( 1 - con ) / ( 1 + con ) ) );
                                Phi += dphi
                            } while ( fabs( dphi ) > TOL && --i );
                            return i ? Phi : HUGE_VAL
                        }
                    }

                    function pj_enfn( es ) {
                        var C00 = 1,
                            C02 = .25,
                            C04 = .046875,
                            C06 = .01953125,
                            C08 = .01068115234375,
                            C22 = .75,
                            C44 = .46875,
                            C46 = .013020833333333334,
                            C48 = .007120768229166667,
                            C66 = .3645833333333333,
                            C68 = .005696614583333333,
                            C88 = .3076171875;
                        var en = [],
                            t;
                        en[ 0 ] = C00 - es * ( C02 + es * ( C04 + es * ( C06 + es * C08 ) ) );
                        en[ 1 ] = es * ( C22 - es * ( C04 + es * ( C06 + es * C08 ) ) );
                        en[ 2 ] = ( t = es * es ) * ( C44 - es * ( C46 + es * C48 ) );
                        en[ 3 ] = ( t *= es ) * ( C66 - es * C68 );
                        en[ 4 ] = t * es * C88;
                        return en
                    }

                    function pj_mlfn( phi, sphi, cphi, en ) {
                        cphi *= sphi;
                        sphi *= sphi;
                        return en[ 0 ] * phi - cphi * ( en[ 1 ] + sphi * ( en[ 2 ] + sphi * ( en[ 3 ] + sphi * en[ 4 ] ) ) )
                    }

                    function pj_inv_mlfn( arg, es, en ) {
                        var EPS = 1e-11,
                            MAX_ITER = 10,
                            EN_SIZE = 5;
                        var k = 1 / ( 1 - es ),
                            s, t, phi;
                        phi = arg;
                        for ( var i = MAX_ITER; i > 0; --i ) {
                            s = sin( phi );
                            t = 1 - es * s * s;
                            phi -= t = ( pj_mlfn( phi, s, cos( phi ), en ) - arg ) * ( t * sqrt( t ) ) * k;
                            if ( fabs( t ) < EPS ) {
                                return phi
                            }
                        }
                        pj_ctx_set_errno( ctx, -17 );
                        return phi
                    }

                    function aasin( v ) {
                        var ONE_TOL = 1.00000000000001;
                        var av = fabs( v );
                        if ( av >= 1 ) {
                            if ( av > ONE_TOL ) pj_ctx_set_errno( -19 );
                            return v < 0 ? -M_HALFPI : M_HALFPI
                        }
                        return asin( v )
                    }

                    function aacos( v ) {
                        var ONE_TOL = 1.00000000000001;
                        var av = fabs( v );
                        if ( av >= 1 ) {
                            if ( av > ONE_TOL ) pj_ctx_set_errno( -19 );
                            return v < 0 ? M_PI : 0
                        }
                        return acos( v )
                    }

                    function asqrt( v ) {
                        return v <= 0 ? 0 : sqrt( v )
                    }

                    function aatan2( n, d ) {
                        var ATOL = 1e-50;
                        return fabs( n ) < ATOL && fabs( d ) < ATOL ? 0 : atan2( n, d )
                    }
                    "use strict";
                    var GeographicLib = {};
                    GeographicLib.Constants = {};
                    GeographicLib.Math = {};
                    GeographicLib.Accumulator = {};
                    ( function( c ) {
                        c.WGS84 = {
                            a: 6378137,
                            f: 1 / 298.257223563
                        };
                        c.version = {
                            major: 1,
                            minor: 46,
                            patch: 0
                        };
                        c.version_string = "1.46"
                    } )( GeographicLib.Constants );
                    ( function( m ) {
                        m.digits = 53;
                        m.epsilon = Math.pow( .5, m.digits - 1 );
                        m.degree = Math.PI / 180;
                        m.sq = function( x ) {
                            return x * x
                        };
                        m.hypot = function( x, y ) {
                            var a, b;
                            x = Math.abs( x );
                            y = Math.abs( y );
                            a = Math.max( x, y );
                            b = Math.min( x, y ) / ( a ? a : 1 );
                            return a * Math.sqrt( 1 + b * b )
                        };
                        m.cbrt = function( x ) {
                            var y = Math.pow( Math.abs( x ), 1 / 3 );
                            return x < 0 ? -y : y
                        };
                        m.log1p = function( x ) {
                            var y = 1 + x,
                                z = y - 1;
                            return z === 0 ? x : x * Math.log( y ) / z
                        };
                        m.atanh = function( x ) {
                            var y = Math.abs( x );
                            y = m.log1p( 2 * y / ( 1 - y ) ) / 2;
                            return x < 0 ? -y : y
                        };
                        m.copysign = function( x, y ) {
                            return Math.abs( x ) * ( y < 0 || y === 0 && 1 / y < 0 ? -1 : 1 )
                        };
                        m.sum = function( u, v ) {
                            var s = u + v,
                                up = s - v,
                                vpp = s - up,
                                t;
                            up -= u;
                            vpp -= v;
                            t = -( up + vpp );
                            return {
                                s: s,
                                t: t
                            }
                        };
                        m.polyval = function( N, p, s, x ) {
                            var y = N < 0 ? 0 : p[ s++ ];
                            while ( --N >= 0 ) y = y * x + p[ s++ ];
                            return y
                        };
                        m.AngRound = function( x ) {
                            if ( x === 0 ) return x;
                            var z = 1 / 16,
                                y = Math.abs( x );
                            y = y < z ? z - ( z - y ) : y;
                            return x < 0 ? -y : y
                        };
                        m.AngNormalize = function( x ) {
                            x = x % 360;
                            return x < -180 ? x + 360 : x < 180 ? x : x - 360
                        };
                        m.LatFix = function( x ) {
                            return Math.abs( x ) > 90 ? Number.NaN : x
                        };
                        m.AngDiff = function( x, y ) {
                            var r = m.sum( m.AngNormalize( x ), m.AngNormalize( -y ) ),
                                d = -m.AngNormalize( r.s ),
                                t = r.t;
                            return m.sum( d === 180 && t < 0 ? -180 : d, -t )
                        };
                        m.sincosd = function( x ) {
                            var r, q, s, c, sinx, cosx;
                            r = x % 360;
                            q = Math.floor( r / 90 + .5 );
                            r -= 90 * q;
                            r *= this.degree;
                            s = Math.sin( r );
                            c = Math.cos( r );
                            switch ( q & 3 ) {
                                case 0:
                                    sinx = s;
                                    cosx = c;
                                    break;
                                case 1:
                                    sinx = c;
                                    cosx = 0 - s;
                                    break;
                                case 2:
                                    sinx = 0 - s;
                                    cosx = 0 - c;
                                    break;
                                default:
                                    sinx = 0 - c;
                                    cosx = s;
                                    break
                            }
                            return {
                                s: sinx,
                                c: cosx
                            }
                        };
                        m.atan2d = function( y, x ) {
                            var q = 0,
                                t, ang;
                            if ( Math.abs( y ) > Math.abs( x ) ) {
                                t = x;
                                x = y;
                                y = t;
                                q = 2
                            }
                            if ( x < 0 ) {
                                x = -x;
                                ++q
                            }
                            ang = Math.atan2( y, x ) / this.degree;
                            switch ( q ) {
                                case 1:
                                    ang = ( y > 0 ? 180 : -180 ) - ang;
                                    break;
                                case 2:
                                    ang = 90 - ang;
                                    break;
                                case 3:
                                    ang = -90 + ang;
                                    break
                            }
                            return ang
                        }
                    } )( GeographicLib.Math );
                    ( function( a, m ) {
                        a.Accumulator = function( y ) {
                            this.Set( y )
                        };
                        a.Accumulator.prototype.Set = function( y ) {
                            if ( !y ) y = 0;
                            if ( y.constructor === a.Accumulator ) {
                                this._s = y._s;
                                this._t = y._t
                            } else {
                                this._s = y;
                                this._t = 0
                            }
                        };
                        a.Accumulator.prototype.Add = function( y ) {
                            var u = m.sum( y, this._t ),
                                v = m.sum( u.s, this._s );
                            u = u.t;
                            this._s = v.s;
                            this._t = v.t;
                            if ( this._s === 0 ) this._s = u;
                            else this._t += u
                        };
                        a.Accumulator.prototype.Sum = function( y ) {
                            var b;
                            if ( !y ) return this._s;
                            else {
                                b = new a.Accumulator( this );
                                b.Add( y );
                                return b._s
                            }
                        };
                        a.Accumulator.prototype.Negate = function() {
                            this._s *= -1;
                            this._t *= -1
                        }
                    } )( GeographicLib.Accumulator, GeographicLib.Math );
                    GeographicLib.Geodesic = {};
                    GeographicLib.GeodesicLine = {};
                    GeographicLib.PolygonArea = {};
                    ( function( g, l, p, m, c ) {
                        var GEOGRAPHICLIB_GEODESIC_ORDER = 6,
                            nA1_ = GEOGRAPHICLIB_GEODESIC_ORDER,
                            nA2_ = GEOGRAPHICLIB_GEODESIC_ORDER,
                            nA3_ = GEOGRAPHICLIB_GEODESIC_ORDER,
                            nA3x_ = nA3_,
                            nC3x_, nC4x_, maxit1_ = 20,
                            maxit2_ = maxit1_ + m.digits + 10,
                            tol0_ = m.epsilon,
                            tol1_ = 200 * tol0_,
                            tol2_ = Math.sqrt( tol0_ ),
                            tolb_ = tol0_ * tol1_,
                            xthresh_ = 1e3 * tol2_,
                            CAP_NONE = 0,
                            CAP_ALL = 31,
                            CAP_MASK = CAP_ALL,
                            OUT_ALL = 32640,
                            astroid, A1m1f_coeff, C1f_coeff, C1pf_coeff, A2m1f_coeff, C2f_coeff, A3_coeff, C3_coeff, C4_coeff;
                        g.tiny_ = Math.sqrt( Number.MIN_VALUE );
                        g.nC1_ = GEOGRAPHICLIB_GEODESIC_ORDER;
                        g.nC1p_ = GEOGRAPHICLIB_GEODESIC_ORDER;
                        g.nC2_ = GEOGRAPHICLIB_GEODESIC_ORDER;
                        g.nC3_ = GEOGRAPHICLIB_GEODESIC_ORDER;
                        g.nC4_ = GEOGRAPHICLIB_GEODESIC_ORDER;
                        nC3x_ = g.nC3_ * ( g.nC3_ - 1 ) / 2;
                        nC4x_ = g.nC4_ * ( g.nC4_ + 1 ) / 2;
                        g.CAP_C1 = 1 << 0;
                        g.CAP_C1p = 1 << 1;
                        g.CAP_C2 = 1 << 2;
                        g.CAP_C3 = 1 << 3;
                        g.CAP_C4 = 1 << 4;
                        g.NONE = 0;
                        g.ARC = 1 << 6;
                        g.LATITUDE = 1 << 7 | CAP_NONE;
                        g.LONGITUDE = 1 << 8 | g.CAP_C3;
                        g.AZIMUTH = 1 << 9 | CAP_NONE;
                        g.DISTANCE = 1 << 10 | g.CAP_C1;
                        g.STANDARD = g.LATITUDE | g.LONGITUDE | g.AZIMUTH | g.DISTANCE;
                        g.DISTANCE_IN = 1 << 11 | g.CAP_C1 | g.CAP_C1p;
                        g.REDUCEDLENGTH = 1 << 12 | g.CAP_C1 | g.CAP_C2;
                        g.GEODESICSCALE = 1 << 13 | g.CAP_C1 | g.CAP_C2;
                        g.AREA = 1 << 14 | g.CAP_C4;
                        g.ALL = OUT_ALL | CAP_ALL;
                        g.LONG_UNROLL = 1 << 15;
                        g.OUT_MASK = OUT_ALL | g.LONG_UNROLL;
                        g.SinCosSeries = function( sinp, sinx, cosx, c ) {
                            var k = c.length,
                                n = k - ( sinp ? 1 : 0 ),
                                ar = 2 * ( cosx - sinx ) * ( cosx + sinx ),
                                y0 = n & 1 ? c[ --k ] : 0,
                                y1 = 0;
                            n = Math.floor( n / 2 );
                            while ( n-- ) {
                                y1 = ar * y0 - y1 + c[ --k ];
                                y0 = ar * y1 - y0 + c[ --k ]
                            }
                            return sinp ? 2 * sinx * cosx * y0 : cosx * ( y0 - y1 )
                        };
                        astroid = function( x, y ) {
                            var k, p = m.sq( x ),
                                q = m.sq( y ),
                                r = ( p + q - 1 ) / 6,
                                S, r2, r3, disc, u, T3, T, ang, v, uv, w;
                            if ( !( q === 0 && r <= 0 ) ) {
                                S = p * q / 4;
                                r2 = m.sq( r );
                                r3 = r * r2;
                                disc = S * ( S + 2 * r3 );
                                u = r;
                                if ( disc >= 0 ) {
                                    T3 = S + r3;
                                    T3 += T3 < 0 ? -Math.sqrt( disc ) : Math.sqrt( disc );
                                    T = m.cbrt( T3 );
                                    u += T + ( T !== 0 ? r2 / T : 0 )
                                } else {
                                    ang = Math.atan2( Math.sqrt( -disc ), -( S + r3 ) );
                                    u += 2 * r * Math.cos( ang / 3 )
                                }
                                v = Math.sqrt( m.sq( u ) + q );
                                uv = u < 0 ? q / ( v - u ) : u + v;
                                w = ( uv - q ) / ( 2 * v );
                                k = uv / ( Math.sqrt( uv + m.sq( w ) ) + w )
                            } else {
                                k = 0
                            }
                            return k
                        };
                        A1m1f_coeff = [ +1, 4, 64, 0, 256 ];
                        g.A1m1f = function( eps ) {
                            var p = Math.floor( nA1_ / 2 ),
                                t = m.polyval( p, A1m1f_coeff, 0, m.sq( eps ) ) / A1m1f_coeff[ p + 1 ];
                            return ( t + eps ) / ( 1 - eps )
                        };
                        C1f_coeff = [ -1, 6, -16, 32, -9, 64, -128, 2048, +9, -16, 768, +3, -5, 512, -7, 1280, -7, 2048 ];
                        g.C1f = function( eps, c ) {
                            var eps2 = m.sq( eps ),
                                d = eps,
                                o = 0,
                                l, p;
                            for ( l = 1; l <= g.nC1_; ++l ) {
                                p = Math.floor( ( g.nC1_ - l ) / 2 );
                                c[ l ] = d * m.polyval( p, C1f_coeff, o, eps2 ) / C1f_coeff[ o + p + 1 ];
                                o += p + 2;
                                d *= eps
                            }
                        };
                        C1pf_coeff = [ +205, -432, 768, 1536, +4005, -4736, 3840, 12288, -225, 116, 384, -7173, 2695, 7680, +3467, 7680, +38081, 61440 ];
                        g.C1pf = function( eps, c ) {
                            var eps2 = m.sq( eps ),
                                d = eps,
                                o = 0,
                                l, p;
                            for ( l = 1; l <= g.nC1p_; ++l ) {
                                p = Math.floor( ( g.nC1p_ - l ) / 2 );
                                c[ l ] = d * m.polyval( p, C1pf_coeff, o, eps2 ) / C1pf_coeff[ o + p + 1 ];
                                o += p + 2;
                                d *= eps
                            }
                        };
                        A2m1f_coeff = [ -11, -28, -192, 0, 256 ];
                        g.A2m1f = function( eps ) {
                            var p = Math.floor( nA2_ / 2 ),
                                t = m.polyval( p, A2m1f_coeff, 0, m.sq( eps ) ) / A2m1f_coeff[ p + 1 ];
                            return ( t - eps ) / ( 1 + eps )
                        };
                        C2f_coeff = [ +1, 2, 16, 32, +35, 64, 384, 2048, +15, 80, 768, +7, 35, 512, +63, 1280, +77, 2048 ];
                        g.C2f = function( eps, c ) {
                            var eps2 = m.sq( eps ),
                                d = eps,
                                o = 0,
                                l, p;
                            for ( l = 1; l <= g.nC2_; ++l ) {
                                p = Math.floor( ( g.nC2_ - l ) / 2 );
                                c[ l ] = d * m.polyval( p, C2f_coeff, o, eps2 ) / C2f_coeff[ o + p + 1 ];
                                o += p + 2;
                                d *= eps
                            }
                        };
                        g.Geodesic = function( a, f ) {
                            this.a = a;
                            this.f = f;
                            this._f1 = 1 - this.f;
                            this._e2 = this.f * ( 2 - this.f );
                            this._ep2 = this._e2 / m.sq( this._f1 );
                            this._n = this.f / ( 2 - this.f );
                            this._b = this.a * this._f1;
                            this._c2 = ( m.sq( this.a ) + m.sq( this._b ) * ( this._e2 === 0 ? 1 : ( this._e2 > 0 ? m.atanh( Math.sqrt( this._e2 ) ) : Math.atan( Math.sqrt( -this._e2 ) ) ) / Math.sqrt( Math.abs( this._e2 ) ) ) ) / 2;
                            this._etol2 = .1 * tol2_ / Math.sqrt( Math.max( .001, Math.abs( this.f ) ) * Math.min( 1, 1 - this.f / 2 ) / 2 );
                            if ( !( isFinite( this.a ) && this.a > 0 ) ) throw new Error( "Major radius is not positive" );
                            if ( !( isFinite( this._b ) && this._b > 0 ) ) throw new Error( "Minor radius is not positive" );
                            this._A3x = new Array( nA3x_ );
                            this._C3x = new Array( nC3x_ );
                            this._C4x = new Array( nC4x_ );
                            this.A3coeff();
                            this.C3coeff();
                            this.C4coeff()
                        };
                        A3_coeff = [ -3, 128, -2, -3, 64, -1, -3, -1, 16, +3, -1, -2, 8, +1, -1, 2, +1, 1 ];
                        g.Geodesic.prototype.A3coeff = function() {
                            var o = 0,
                                k = 0,
                                j, p;
                            for ( j = nA3_ - 1; j >= 0; --j ) {
                                p = Math.min( nA3_ - j - 1, j );
                                this._A3x[ k++ ] = m.polyval( p, A3_coeff, o, this._n ) / A3_coeff[ o + p + 1 ];
                                o += p + 2
                            }
                        };
                        C3_coeff = [ +3, 128, +2, 5, 128, -1, 3, 3, 64, -1, 0, 1, 8, -1, 1, 4, +5, 256, +1, 3, 128, -3, -2, 3, 64, +1, -3, 2, 32, +7, 512, -10, 9, 384, +5, -9, 5, 192, +7, 512, -14, 7, 512, +21, 2560 ];
                        g.Geodesic.prototype.C3coeff = function() {
                            var o = 0,
                                k = 0,
                                l, j, p;
                            for ( l = 1; l < g.nC3_; ++l ) {
                                for ( j = g.nC3_ - 1; j >= l; --j ) {
                                    p = Math.min( g.nC3_ - j - 1, j );
                                    this._C3x[ k++ ] = m.polyval( p, C3_coeff, o, this._n ) / C3_coeff[ o + p + 1 ];
                                    o += p + 2
                                }
                            }
                        };
                        C4_coeff = [ +97, 15015, +1088, 156, 45045, -224, -4784, 1573, 45045, -10656, 14144, -4576, -858, 45045, +64, 624, -4576, 6864, -3003, 15015, +100, 208, 572, 3432, -12012, 30030, 45045, +1, 9009, -2944, 468, 135135, +5792, 1040, -1287, 135135, +5952, -11648, 9152, -2574, 135135, -64, -624, 4576, -6864, 3003, 135135, +8, 10725, +1856, -936, 225225, -8448, 4992, -1144, 225225, -1440, 4160, -4576, 1716, 225225, -136, 63063, +1024, -208, 105105, +3584, -3328, 1144, 315315, -128, 135135, -2560, 832, 405405, +128, 99099 ];
                        g.Geodesic.prototype.C4coeff = function() {
                            var o = 0,
                                k = 0,
                                l, j, p;
                            for ( l = 0; l < g.nC4_; ++l ) {
                                for ( j = g.nC4_ - 1; j >= l; --j ) {
                                    p = g.nC4_ - j - 1;
                                    this._C4x[ k++ ] = m.polyval( p, C4_coeff, o, this._n ) / C4_coeff[ o + p + 1 ];
                                    o += p + 2
                                }
                            }
                        };
                        g.Geodesic.prototype.A3f = function( eps ) {
                            return m.polyval( nA3x_ - 1, this._A3x, 0, eps )
                        };
                        g.Geodesic.prototype.C3f = function( eps, c ) {
                            var mult = 1,
                                o = 0,
                                l, p;
                            for ( l = 1; l < g.nC3_; ++l ) {
                                p = g.nC3_ - l - 1;
                                mult *= eps;
                                c[ l ] = mult * m.polyval( p, this._C3x, o, eps );
                                o += p + 1
                            }
                        };
                        g.Geodesic.prototype.C4f = function( eps, c ) {
                            var mult = 1,
                                o = 0,
                                l, p;
                            for ( l = 0; l < g.nC4_; ++l ) {
                                p = g.nC4_ - l - 1;
                                c[ l ] = mult * m.polyval( p, this._C4x, o, eps );
                                o += p + 1;
                                mult *= eps
                            }
                        };
                        g.Geodesic.prototype.Lengths = function( eps, sig12, ssig1, csig1, dn1, ssig2, csig2, dn2, cbet1, cbet2, outmask, C1a, C2a ) {
                            outmask &= g.OUT_MASK;
                            var vals = {},
                                m0x = 0,
                                J12 = 0,
                                A1 = 0,
                                A2 = 0,
                                B1, B2, l, csig12, t;
                            if ( outmask & ( g.DISTANCE | g.REDUCEDLENGTH | g.GEODESICSCALE ) ) {
                                A1 = g.A1m1f( eps );
                                g.C1f( eps, C1a );
                                if ( outmask & ( g.REDUCEDLENGTH | g.GEODESICSCALE ) ) {
                                    A2 = g.A2m1f( eps );
                                    g.C2f( eps, C2a );
                                    m0x = A1 - A2;
                                    A2 = 1 + A2
                                }
                                A1 = 1 + A1
                            }
                            if ( outmask & g.DISTANCE ) {
                                B1 = g.SinCosSeries( true, ssig2, csig2, C1a ) - g.SinCosSeries( true, ssig1, csig1, C1a );
                                vals.s12b = A1 * ( sig12 + B1 );
                                if ( outmask & ( g.REDUCEDLENGTH | g.GEODESICSCALE ) ) {
                                    B2 = g.SinCosSeries( true, ssig2, csig2, C2a ) - g.SinCosSeries( true, ssig1, csig1, C2a );
                                    J12 = m0x * sig12 + ( A1 * B1 - A2 * B2 )
                                }
                            } else if ( outmask & ( g.REDUCEDLENGTH | g.GEODESICSCALE ) ) {
                                for ( l = 1; l <= g.nC2_; ++l ) C2a[ l ] = A1 * C1a[ l ] - A2 * C2a[ l ];
                                J12 = m0x * sig12 + ( g.SinCosSeries( true, ssig2, csig2, C2a ) - g.SinCosSeries( true, ssig1, csig1, C2a ) )
                            }
                            if ( outmask & g.REDUCEDLENGTH ) {
                                vals.m0 = m0x;
                                vals.m12b = dn2 * ( csig1 * ssig2 ) - dn1 * ( ssig1 * csig2 ) - csig1 * csig2 * J12
                            }
                            if ( outmask & g.GEODESICSCALE ) {
                                csig12 = csig1 * csig2 + ssig1 * ssig2;
                                t = this._ep2 * ( cbet1 - cbet2 ) * ( cbet1 + cbet2 ) / ( dn1 + dn2 );
                                vals.M12 = csig12 + ( t * ssig2 - csig2 * J12 ) * ssig1 / dn1;
                                vals.M21 = csig12 - ( t * ssig1 - csig1 * J12 ) * ssig2 / dn2
                            }
                            return vals
                        };
                        g.Geodesic.prototype.InverseStart = function( sbet1, cbet1, dn1, sbet2, cbet2, dn2, lam12, slam12, clam12, C1a, C2a ) {
                            var vals = {},
                                sbet12 = sbet2 * cbet1 - cbet2 * sbet1,
                                cbet12 = cbet2 * cbet1 + sbet2 * sbet1,
                                sbet12a, shortline, omg12, sbetm2, somg12, comg12, t, ssig12, csig12, x, y, lamscale, betscale, k2, eps, cbet12a, bet12a, m12b, m0, nvals, k, omg12a, lam12x;
                            vals.sig12 = -1;
                            sbet12a = sbet2 * cbet1;
                            sbet12a += cbet2 * sbet1;
                            shortline = cbet12 >= 0 && sbet12 < .5 && cbet2 * lam12 < .5;
                            if ( shortline ) {
                                sbetm2 = m.sq( sbet1 + sbet2 );
                                sbetm2 /= sbetm2 + m.sq( cbet1 + cbet2 );
                                vals.dnm = Math.sqrt( 1 + this._ep2 * sbetm2 );
                                omg12 = lam12 / ( this._f1 * vals.dnm );
                                somg12 = Math.sin( omg12 );
                                comg12 = Math.cos( omg12 )
                            } else {
                                somg12 = slam12;
                                comg12 = clam12
                            }
                            vals.salp1 = cbet2 * somg12;
                            vals.calp1 = comg12 >= 0 ? sbet12 + cbet2 * sbet1 * m.sq( somg12 ) / ( 1 + comg12 ) : sbet12a - cbet2 * sbet1 * m.sq( somg12 ) / ( 1 - comg12 );
                            ssig12 = m.hypot( vals.salp1, vals.calp1 );
                            csig12 = sbet1 * sbet2 + cbet1 * cbet2 * comg12;
                            if ( shortline && ssig12 < this._etol2 ) {
                                vals.salp2 = cbet1 * somg12;
                                vals.calp2 = sbet12 - cbet1 * sbet2 * ( comg12 >= 0 ? m.sq( somg12 ) / ( 1 + comg12 ) : 1 - comg12 );
                                t = m.hypot( vals.salp2, vals.calp2 );
                                vals.salp2 /= t;
                                vals.calp2 /= t;
                                vals.sig12 = Math.atan2( ssig12, csig12 )
                            } else if ( Math.abs( this._n ) > .1 || csig12 >= 0 || ssig12 >= 6 * Math.abs( this._n ) * Math.PI * m.sq( cbet1 ) ) {} else {
                                lam12x = Math.atan2( -slam12, -clam12 );
                                if ( this.f >= 0 ) {
                                    k2 = m.sq( sbet1 ) * this._ep2;
                                    eps = k2 / ( 2 * ( 1 + Math.sqrt( 1 + k2 ) ) + k2 );
                                    lamscale = this.f * cbet1 * this.A3f( eps ) * Math.PI;
                                    betscale = lamscale * cbet1;
                                    x = lam12x / lamscale;
                                    y = sbet12a / betscale
                                } else {
                                    cbet12a = cbet2 * cbet1 - sbet2 * sbet1;
                                    bet12a = Math.atan2( sbet12a, cbet12a );
                                    nvals = this.Lengths( this._n, Math.PI + bet12a, sbet1, -cbet1, dn1, sbet2, cbet2, dn2, cbet1, cbet2, g.REDUCEDLENGTH, C1a, C2a );
                                    m12b = nvals.m12b;
                                    m0 = nvals.m0;
                                    x = -1 + m12b / ( cbet1 * cbet2 * m0 * Math.PI );
                                    betscale = x < -.01 ? sbet12a / x : -this.f * m.sq( cbet1 ) * Math.PI;
                                    lamscale = betscale / cbet1;
                                    y = lam12 / lamscale
                                }
                                if ( y > -tol1_ && x > -1 - xthresh_ ) {
                                    if ( this.f >= 0 ) {
                                        vals.salp1 = Math.min( 1, -x );
                                        vals.calp1 = -Math.sqrt( 1 - m.sq( vals.salp1 ) )
                                    } else {
                                        vals.calp1 = Math.max( x > -tol1_ ? 0 : -1, x );
                                        vals.salp1 = Math.sqrt( 1 - m.sq( vals.calp1 ) )
                                    }
                                } else {
                                    k = astroid( x, y );
                                    omg12a = lamscale * ( this.f >= 0 ? -x * k / ( 1 + k ) : -y * ( 1 + k ) / k );
                                    somg12 = Math.sin( omg12a );
                                    comg12 = -Math.cos( omg12a );
                                    vals.salp1 = cbet2 * somg12;
                                    vals.calp1 = sbet12a - cbet2 * sbet1 * m.sq( somg12 ) / ( 1 - comg12 )
                                }
                            }
                            if ( !( vals.salp1 <= 0 ) ) {
                                t = m.hypot( vals.salp1, vals.calp1 );
                                vals.salp1 /= t;
                                vals.calp1 /= t
                            } else {
                                vals.salp1 = 1;
                                vals.calp1 = 0
                            }
                            return vals
                        };
                        g.Geodesic.prototype.Lambda12 = function( sbet1, cbet1, dn1, sbet2, cbet2, dn2, salp1, calp1, slam120, clam120, diffp, C1a, C2a, C3a ) {
                            var vals = {},
                                t, salp0, calp0, somg1, comg1, somg2, comg2, B312, eta, k2, nvals;
                            if ( sbet1 === 0 && calp1 === 0 ) calp1 = -g.tiny_;
                            salp0 = salp1 * cbet1;
                            calp0 = m.hypot( calp1, salp1 * sbet1 );
                            vals.ssig1 = sbet1;
                            somg1 = salp0 * sbet1;
                            vals.csig1 = comg1 = calp1 * cbet1;
                            t = m.hypot( vals.ssig1, vals.csig1 );
                            vals.ssig1 /= t;
                            vals.csig1 /= t;
                            vals.salp2 = cbet2 !== cbet1 ? salp0 / cbet2 : salp1;
                            vals.calp2 = cbet2 !== cbet1 || Math.abs( sbet2 ) !== -sbet1 ? Math.sqrt( m.sq( calp1 * cbet1 ) + ( cbet1 < -sbet1 ? ( cbet2 - cbet1 ) * ( cbet1 + cbet2 ) : ( sbet1 - sbet2 ) * ( sbet1 + sbet2 ) ) ) / cbet2 : Math.abs( calp1 );
                            vals.ssig2 = sbet2;
                            somg2 = salp0 * sbet2;
                            vals.csig2 = comg2 = vals.calp2 * cbet2;
                            t = m.hypot( vals.ssig2, vals.csig2 );
                            vals.ssig2 /= t;
                            vals.csig2 /= t;
                            vals.sig12 = Math.atan2( Math.max( 0, vals.csig1 * vals.ssig2 - vals.ssig1 * vals.csig2 ), vals.csig1 * vals.csig2 + vals.ssig1 * vals.ssig2 );
                            vals.somg12 = Math.max( 0, comg1 * somg2 - somg1 * comg2 );
                            vals.comg12 = comg1 * comg2 + somg1 * somg2;
                            eta = Math.atan2( vals.somg12 * clam120 - vals.comg12 * slam120, vals.comg12 * clam120 + vals.somg12 * slam120 );
                            k2 = m.sq( calp0 ) * this._ep2;
                            vals.eps = k2 / ( 2 * ( 1 + Math.sqrt( 1 + k2 ) ) + k2 );
                            this.C3f( vals.eps, C3a );
                            B312 = g.SinCosSeries( true, vals.ssig2, vals.csig2, C3a ) - g.SinCosSeries( true, vals.ssig1, vals.csig1, C3a );
                            vals.lam12 = eta - this.f * this.A3f( vals.eps ) * salp0 * ( vals.sig12 + B312 );
                            if ( diffp ) {
                                if ( vals.calp2 === 0 ) vals.dlam12 = -2 * this._f1 * dn1 / sbet1;
                                else {
                                    nvals = this.Lengths( vals.eps, vals.sig12, vals.ssig1, vals.csig1, dn1, vals.ssig2, vals.csig2, dn2, cbet1, cbet2, g.REDUCEDLENGTH, C1a, C2a );
                                    vals.dlam12 = nvals.m12b;
                                    vals.dlam12 *= this._f1 / ( vals.calp2 * cbet2 )
                                }
                            }
                            return vals
                        };
                        g.Geodesic.prototype.Inverse = function( lat1, lon1, lat2, lon2, outmask ) {
                            var r, vals;
                            if ( !outmask ) outmask = g.STANDARD;
                            if ( outmask === g.LONG_UNROLL ) outmask |= g.STANDARD;
                            outmask &= g.OUT_MASK;
                            r = this.InverseInt( lat1, lon1, lat2, lon2, outmask );
                            vals = r.vals;
                            if ( outmask & g.AZIMUTH ) {
                                vals.azi1 = m.atan2d( r.salp1, r.calp1 );
                                vals.azi2 = m.atan2d( r.salp2, r.calp2 )
                            }
                            return vals
                        };
                        g.Geodesic.prototype.InverseInt = function( lat1, lon1, lat2, lon2, outmask ) {
                            var vals = {},
                                lon12, lon12s, lonsign, t, swapp, latsign, sbet1, cbet1, sbet2, cbet2, s12x, m12x, dn1, dn2, lam12, slam12, clam12, sig12, calp1, salp1, calp2, salp2, C1a, C2a, C3a, meridian, nvals, ssig1, csig1, ssig2, csig2, eps, omg12, dnm, numit, salp1a, calp1a, salp1b, calp1b, tripn, tripb, v, dv, dalp1, sdalp1, cdalp1, nsalp1, lengthmask, salp0, calp0, alp12, k2, A4, C4a, B41, B42, somg12, comg12, domg12, dbet1, dbet2, salp12, calp12;
                            vals.lat1 = lat1 = m.LatFix( lat1 );
                            vals.lat2 = lat2 = m.LatFix( lat2 );
                            lat1 = m.AngRound( lat1 );
                            lat2 = m.AngRound( lat2 );
                            lon12 = m.AngDiff( lon1, lon2 );
                            lon12s = lon12.t;
                            lon12 = lon12.s;
                            if ( outmask & g.LONG_UNROLL ) {
                                vals.lon1 = lon1;
                                vals.lon2 = lon1 + lon12 + lon12s
                            } else {
                                vals.lon1 = m.AngNormalize( lon1 );
                                vals.lon2 = m.AngNormalize( lon2 )
                            }
                            lonsign = lon12 >= 0 ? 1 : -1;
                            lon12 = lonsign * m.AngRound( lon12 );
                            lon12s = m.AngRound( 180 - lon12 - lonsign * lon12s );
                            lam12 = lon12 * m.degree;
                            t = m.sincosd( lon12 > 90 ? lon12s : lon12 );
                            slam12 = t.s;
                            clam12 = ( lon12 > 90 ? -1 : 1 ) * t.c;
                            swapp = Math.abs( lat1 ) < Math.abs( lat2 ) ? -1 : 1;
                            if ( swapp < 0 ) {
                                lonsign *= -1;
                                t = lat1;
                                lat1 = lat2;
                                lat2 = t
                            }
                            latsign = lat1 < 0 ? 1 : -1;
                            lat1 *= latsign;
                            lat2 *= latsign;
                            t = m.sincosd( lat1 );
                            sbet1 = this._f1 * t.s;
                            cbet1 = t.c;
                            t = m.hypot( sbet1, cbet1 );
                            sbet1 /= t;
                            cbet1 /= t;
                            cbet1 = Math.max( g.tiny_, cbet1 );
                            t = m.sincosd( lat2 );
                            sbet2 = this._f1 * t.s;
                            cbet2 = t.c;
                            t = m.hypot( sbet2, cbet2 );
                            sbet2 /= t;
                            cbet2 /= t;
                            cbet2 = Math.max( g.tiny_, cbet2 );
                            if ( cbet1 < -sbet1 ) {
                                if ( cbet2 === cbet1 ) sbet2 = sbet2 < 0 ? sbet1 : -sbet1
                            } else {
                                if ( Math.abs( sbet2 ) === -sbet1 ) cbet2 = cbet1
                            }
                            dn1 = Math.sqrt( 1 + this._ep2 * m.sq( sbet1 ) );
                            dn2 = Math.sqrt( 1 + this._ep2 * m.sq( sbet2 ) );
                            C1a = new Array( g.nC1_ + 1 );
                            C2a = new Array( g.nC2_ + 1 );
                            C3a = new Array( g.nC3_ );
                            meridian = lat1 === -90 || slam12 === 0;
                            if ( meridian ) {
                                calp1 = clam12;
                                salp1 = slam12;
                                calp2 = 1;
                                salp2 = 0;
                                ssig1 = sbet1;
                                csig1 = calp1 * cbet1;
                                ssig2 = sbet2;
                                csig2 = calp2 * cbet2;
                                sig12 = Math.atan2( Math.max( 0, csig1 * ssig2 - ssig1 * csig2 ), csig1 * csig2 + ssig1 * ssig2 );
                                nvals = this.Lengths( this._n, sig12, ssig1, csig1, dn1, ssig2, csig2, dn2, cbet1, cbet2, outmask | g.DISTANCE | g.REDUCEDLENGTH, C1a, C2a );
                                s12x = nvals.s12b;
                                m12x = nvals.m12b;
                                if ( ( outmask & g.GEODESICSCALE ) !== 0 ) {
                                    vals.M12 = nvals.M12;
                                    vals.M21 = nvals.M21
                                }
                                if ( sig12 < 1 || m12x >= 0 ) {
                                    if ( sig12 < 3 * g.tiny_ ) sig12 = m12x = s12x = 0;
                                    m12x *= this._b;
                                    s12x *= this._b;
                                    vals.a12 = sig12 / m.degree
                                } else meridian = false
                            }
                            somg12 = 2;
                            if ( !meridian && sbet1 === 0 && ( this.f <= 0 || lon12s >= this.f * 180 ) ) {
                                calp1 = calp2 = 0;
                                salp1 = salp2 = 1;
                                s12x = this.a * lam12;
                                sig12 = omg12 = lam12 / this._f1;
                                m12x = this._b * Math.sin( sig12 );
                                if ( outmask & g.GEODESICSCALE ) vals.M12 = vals.M21 = Math.cos( sig12 );
                                vals.a12 = lon12 / this._f1
                            } else if ( !meridian ) {
                                nvals = this.InverseStart( sbet1, cbet1, dn1, sbet2, cbet2, dn2, lam12, slam12, clam12, C1a, C2a );
                                sig12 = nvals.sig12;
                                salp1 = nvals.salp1;
                                calp1 = nvals.calp1;
                                if ( sig12 >= 0 ) {
                                    salp2 = nvals.salp2;
                                    calp2 = nvals.calp2;
                                    dnm = nvals.dnm;
                                    s12x = sig12 * this._b * dnm;
                                    m12x = m.sq( dnm ) * this._b * Math.sin( sig12 / dnm );
                                    if ( outmask & g.GEODESICSCALE ) vals.M12 = vals.M21 = Math.cos( sig12 / dnm );
                                    vals.a12 = sig12 / m.degree;
                                    omg12 = lam12 / ( this._f1 * dnm )
                                } else {
                                    numit = 0;
                                    salp1a = g.tiny_;
                                    calp1a = 1;
                                    salp1b = g.tiny_;
                                    calp1b = -1;
                                    for ( tripn = false, tripb = false; numit < maxit2_; ++numit ) {
                                        nvals = this.Lambda12( sbet1, cbet1, dn1, sbet2, cbet2, dn2, salp1, calp1, slam12, clam12, numit < maxit1_, C1a, C2a, C3a );
                                        v = nvals.lam12;
                                        salp2 = nvals.salp2;
                                        calp2 = nvals.calp2;
                                        sig12 = nvals.sig12;
                                        ssig1 = nvals.ssig1;
                                        csig1 = nvals.csig1;
                                        ssig2 = nvals.ssig2;
                                        csig2 = nvals.csig2;
                                        eps = nvals.eps;
                                        somg12 = nvals.somg12;
                                        comg12 = nvals.comg12;
                                        dv = nvals.dlam12;
                                        if ( tripb || !( Math.abs( v ) >= ( tripn ? 8 : 1 ) * tol0_ ) ) break;
                                        if ( v > 0 && ( numit < maxit1_ || calp1 / salp1 > calp1b / salp1b ) ) {
                                            salp1b = salp1;
                                            calp1b = calp1
                                        } else if ( v < 0 && ( numit < maxit1_ || calp1 / salp1 < calp1a / salp1a ) ) {
                                            salp1a = salp1;
                                            calp1a = calp1
                                        }
                                        if ( numit < maxit1_ && dv > 0 ) {
                                            dalp1 = -v / dv;
                                            sdalp1 = Math.sin( dalp1 );
                                            cdalp1 = Math.cos( dalp1 );
                                            nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;
                                            if ( nsalp1 > 0 && Math.abs( dalp1 ) < Math.PI ) {
                                                calp1 = calp1 * cdalp1 - salp1 * sdalp1;
                                                salp1 = nsalp1;
                                                t = m.hypot( salp1, calp1 );
                                                salp1 /= t;
                                                calp1 /= t;
                                                tripn = Math.abs( v ) <= 16 * tol0_;
                                                continue
                                            }
                                        }
                                        salp1 = ( salp1a + salp1b ) / 2;
                                        calp1 = ( calp1a + calp1b ) / 2;
                                        t = m.hypot( salp1, calp1 );
                                        salp1 /= t;
                                        calp1 /= t;
                                        tripn = false;
                                        tripb = Math.abs( salp1a - salp1 ) + ( calp1a - calp1 ) < tolb_ || Math.abs( salp1 - salp1b ) + ( calp1 - calp1b ) < tolb_
                                    }
                                    lengthmask = outmask | ( outmask & ( g.REDUCEDLENGTH | g.GEODESICSCALE ) ? g.DISTANCE : g.NONE );
                                    nvals = this.Lengths( eps, sig12, ssig1, csig1, dn1, ssig2, csig2, dn2, cbet1, cbet2, lengthmask, C1a, C2a );
                                    s12x = nvals.s12b;
                                    m12x = nvals.m12b;
                                    if ( ( outmask & g.GEODESICSCALE ) !== 0 ) {
                                        vals.M12 = nvals.M12;
                                        vals.M21 = nvals.M21
                                    }
                                    m12x *= this._b;
                                    s12x *= this._b;
                                    vals.a12 = sig12 / m.degree
                                }
                            }
                            if ( outmask & g.DISTANCE ) vals.s12 = 0 + s12x;
                            if ( outmask & g.REDUCEDLENGTH ) vals.m12 = 0 + m12x;
                            if ( outmask & g.AREA ) {
                                salp0 = salp1 * cbet1;
                                calp0 = m.hypot( calp1, salp1 * sbet1 );
                                if ( calp0 !== 0 && salp0 !== 0 ) {
                                    ssig1 = sbet1;
                                    csig1 = calp1 * cbet1;
                                    ssig2 = sbet2;
                                    csig2 = calp2 * cbet2;
                                    k2 = m.sq( calp0 ) * this._ep2;
                                    eps = k2 / ( 2 * ( 1 + Math.sqrt( 1 + k2 ) ) + k2 );
                                    A4 = m.sq( this.a ) * calp0 * salp0 * this._e2;
                                    t = m.hypot( ssig1, csig1 );
                                    ssig1 /= t;
                                    csig1 /= t;
                                    t = m.hypot( ssig2, csig2 );
                                    ssig2 /= t;
                                    csig2 /= t;
                                    C4a = new Array( g.nC4_ );
                                    this.C4f( eps, C4a );
                                    B41 = g.SinCosSeries( false, ssig1, csig1, C4a );
                                    B42 = g.SinCosSeries( false, ssig2, csig2, C4a );
                                    vals.S12 = A4 * ( B42 - B41 )
                                } else vals.S12 = 0;
                                if ( !meridian ) {
                                    if ( somg12 > 1 ) {
                                        somg12 = Math.sin( omg12 );
                                        comg12 = Math.cos( omg12 )
                                    } else {
                                        t = m.hypot( somg12, comg12 );
                                        somg12 /= t;
                                        comg12 /= t
                                    }
                                }
                                if ( !meridian && omg12 > -.7071 && sbet2 - sbet1 < 1.75 ) {
                                    domg12 = 1 + comg12;
                                    dbet1 = 1 + cbet1;
                                    dbet2 = 1 + cbet2;
                                    alp12 = 2 * Math.atan2( somg12 * ( sbet1 * dbet2 + sbet2 * dbet1 ), domg12 * ( sbet1 * sbet2 + dbet1 * dbet2 ) )
                                } else {
                                    salp12 = salp2 * calp1 - calp2 * salp1;
                                    calp12 = calp2 * calp1 + salp2 * salp1;
                                    if ( salp12 === 0 && calp12 < 0 ) {
                                        salp12 = g.tiny_ * calp1;
                                        calp12 = -1
                                    }
                                    alp12 = Math.atan2( salp12, calp12 )
                                }
                                vals.S12 += this._c2 * alp12;
                                vals.S12 *= swapp * lonsign * latsign;
                                vals.S12 += 0
                            }
                            if ( swapp < 0 ) {
                                t = salp1;
                                salp1 = salp2;
                                salp2 = t;
                                t = calp1;
                                calp1 = calp2;
                                calp2 = t;
                                if ( outmask & g.GEODESICSCALE ) {
                                    t = vals.M12;
                                    vals.M12 = vals.M21;
                                    vals.M21 = t
                                }
                            }
                            salp1 *= swapp * lonsign;
                            calp1 *= swapp * latsign;
                            salp2 *= swapp * lonsign;
                            calp2 *= swapp * latsign;
                            return {
                                vals: vals,
                                salp1: salp1,
                                calp1: calp1,
                                salp2: salp2,
                                calp2: calp2
                            }
                        };
                        g.Geodesic.prototype.GenDirect = function( lat1, lon1, azi1, arcmode, s12_a12, outmask ) {
                            var line;
                            if ( !outmask ) outmask = g.STANDARD;
                            else if ( outmask === g.LONG_UNROLL ) outmask |= g.STANDARD;
                            if ( !arcmode ) outmask |= g.DISTANCE_IN;
                            line = new l.GeodesicLine( this, lat1, lon1, azi1, outmask );
                            return line.GenPosition( arcmode, s12_a12, outmask )
                        };
                        g.Geodesic.prototype.Direct = function( lat1, lon1, azi1, s12, outmask ) {
                            return this.GenDirect( lat1, lon1, azi1, false, s12, outmask )
                        };
                        g.Geodesic.prototype.ArcDirect = function( lat1, lon1, azi1, a12, outmask ) {
                            return this.GenDirect( lat1, lon1, azi1, true, a12, outmask )
                        };
                        g.Geodesic.prototype.Line = function( lat1, lon1, azi1, caps ) {
                            return new l.GeodesicLine( this, lat1, lon1, azi1, caps )
                        };
                        g.Geodesic.prototype.DirectLine = function( lat1, lon1, azi1, s12, caps ) {
                            return this.GenDirectLine( lat1, lon1, azi1, false, s12, caps )
                        };
                        g.Geodesic.prototype.ArcDirectLine = function( lat1, lon1, azi1, a12, caps ) {
                            return this.GenDirectLine( lat1, lon1, azi1, true, a12, caps )
                        };
                        g.Geodesic.prototype.GenDirectLine = function( lat1, lon1, azi1, arcmode, s12_a12, caps ) {
                            var t;
                            if ( !caps ) caps = g.STANDARD | g.DISTANCE_IN;
                            if ( !arcmode ) caps |= g.DISTANCE_IN;
                            t = new l.GeodesicLine( this, lat1, lon1, azi1, caps );
                            t.GenSetDistance( arcmode, s12_a12 );
                            return t
                        };
                        g.Geodesic.prototype.InverseLine = function( lat1, lon1, lat2, lon2, caps ) {
                            var r, t, azi1;
                            if ( !caps ) caps = g.STANDARD | g.DISTANCE_IN;
                            r = this.InverseInt( lat1, lon1, lat2, lon2, g.ARC );
                            azi1 = m.atan2d( r.salp1, r.calp1 );
                            if ( caps & ( g.OUT_MASK & g.DISTANCE_IN ) ) caps |= g.DISTANCE;
                            t = new l.GeodesicLine( this, lat1, lon1, azi1, caps, r.salp1, r.calp1 );
                            t.SetArc( r.vals.a12 );
                            return t
                        };
                        g.Geodesic.prototype.Polygon = function( polyline ) {
                            return new p.PolygonArea( this, polyline )
                        };
                        g.WGS84 = new g.Geodesic( c.WGS84.a, c.WGS84.f )
                    } )( GeographicLib.Geodesic, GeographicLib.GeodesicLine, GeographicLib.PolygonArea, GeographicLib.Math, GeographicLib.Constants );
                    ( function( g, l, m ) {
                        l.GeodesicLine = function( geod, lat1, lon1, azi1, caps, salp1, calp1 ) {
                            var t, cbet1, sbet1, eps, s, c;
                            if ( !caps ) caps = g.STANDARD | g.DISTANCE_IN;
                            this.a = geod.a;
                            this.f = geod.f;
                            this._b = geod._b;
                            this._c2 = geod._c2;
                            this._f1 = geod._f1;
                            this.caps = caps | g.LATITUDE | g.AZIMUTH | g.LONG_UNROLL;
                            this.lat1 = m.LatFix( lat1 );
                            this.lon1 = lon1;
                            if ( typeof salp1 === "undefined" || typeof calp1 === "undefined" ) {
                                this.azi1 = m.AngNormalize( azi1 );
                                t = m.sincosd( m.AngRound( this.azi1 ) );
                                this.salp1 = t.s;
                                this.calp1 = t.c
                            } else {
                                this.azi1 = azi1;
                                this.salp1 = salp1;
                                this.calp1 = calp1
                            }
                            t = m.sincosd( m.AngRound( this.lat1 ) );
                            sbet1 = this._f1 * t.s;
                            cbet1 = t.c;
                            t = m.hypot( sbet1, cbet1 );
                            sbet1 /= t;
                            cbet1 /= t;
                            cbet1 = Math.max( g.tiny_, cbet1 );
                            this._dn1 = Math.sqrt( 1 + geod._ep2 * m.sq( sbet1 ) );
                            this._salp0 = this.salp1 * cbet1;
                            this._calp0 = m.hypot( this.calp1, this.salp1 * sbet1 );
                            this._ssig1 = sbet1;
                            this._somg1 = this._salp0 * sbet1;
                            this._csig1 = this._comg1 = sbet1 !== 0 || this.calp1 !== 0 ? cbet1 * this.calp1 : 1;
                            t = m.hypot( this._ssig1, this._csig1 );
                            this._ssig1 /= t;
                            this._csig1 /= t;
                            this._k2 = m.sq( this._calp0 ) * geod._ep2;
                            eps = this._k2 / ( 2 * ( 1 + Math.sqrt( 1 + this._k2 ) ) + this._k2 );
                            if ( this.caps & g.CAP_C1 ) {
                                this._A1m1 = g.A1m1f( eps );
                                this._C1a = new Array( g.nC1_ + 1 );
                                g.C1f( eps, this._C1a );
                                this._B11 = g.SinCosSeries( true, this._ssig1, this._csig1, this._C1a );
                                s = Math.sin( this._B11 );
                                c = Math.cos( this._B11 );
                                this._stau1 = this._ssig1 * c + this._csig1 * s;
                                this._ctau1 = this._csig1 * c - this._ssig1 * s
                            }
                            if ( this.caps & g.CAP_C1p ) {
                                this._C1pa = new Array( g.nC1p_ + 1 );
                                g.C1pf( eps, this._C1pa )
                            }
                            if ( this.caps & g.CAP_C2 ) {
                                this._A2m1 = g.A2m1f( eps );
                                this._C2a = new Array( g.nC2_ + 1 );
                                g.C2f( eps, this._C2a );
                                this._B21 = g.SinCosSeries( true, this._ssig1, this._csig1, this._C2a )
                            }
                            if ( this.caps & g.CAP_C3 ) {
                                this._C3a = new Array( g.nC3_ );
                                geod.C3f( eps, this._C3a );
                                this._A3c = -this.f * this._salp0 * geod.A3f( eps );
                                this._B31 = g.SinCosSeries( true, this._ssig1, this._csig1, this._C3a )
                            }
                            if ( this.caps & g.CAP_C4 ) {
                                this._C4a = new Array( g.nC4_ );
                                geod.C4f( eps, this._C4a );
                                this._A4 = m.sq( this.a ) * this._calp0 * this._salp0 * geod._e2;
                                this._B41 = g.SinCosSeries( false, this._ssig1, this._csig1, this._C4a )
                            }
                            this.a13 = this.s13 = Number.NaN
                        };
                        l.GeodesicLine.prototype.GenPosition = function( arcmode, s12_a12, outmask ) {
                            var vals = {},
                                sig12, ssig12, csig12, B12, AB1, ssig2, csig2, tau12, s, c, serr, omg12, lam12, lon12, E, sbet2, cbet2, somg2, comg2, salp2, calp2, dn2, B22, AB2, J12, t, B42, salp12, calp12;
                            if ( !outmask ) outmask = g.STANDARD;
                            else if ( outmask === g.LONG_UNROLL ) outmask |= g.STANDARD;
                            outmask &= this.caps & g.OUT_MASK;
                            vals.lat1 = this.lat1;
                            vals.azi1 = this.azi1;
                            vals.lon1 = outmask & g.LONG_UNROLL ? this.lon1 : m.AngNormalize( this.lon1 );
                            if ( arcmode ) vals.a12 = s12_a12;
                            else vals.s12 = s12_a12;
                            if ( !( arcmode || this.caps & g.DISTANCE_IN & g.OUT_MASK ) ) {
                                vals.a12 = Number.NaN;
                                return vals
                            }
                            B12 = 0;
                            AB1 = 0;
                            if ( arcmode ) {
                                sig12 = s12_a12 * m.degree;
                                t = m.sincosd( s12_a12 );
                                ssig12 = t.s;
                                csig12 = t.c
                            } else {
                                tau12 = s12_a12 / ( this._b * ( 1 + this._A1m1 ) );
                                s = Math.sin( tau12 );
                                c = Math.cos( tau12 );
                                B12 = -g.SinCosSeries( true, this._stau1 * c + this._ctau1 * s, this._ctau1 * c - this._stau1 * s, this._C1pa );
                                sig12 = tau12 - ( B12 - this._B11 );
                                ssig12 = Math.sin( sig12 );
                                csig12 = Math.cos( sig12 );
                                if ( Math.abs( this.f ) > .01 ) {
                                    ssig2 = this._ssig1 * csig12 + this._csig1 * ssig12;
                                    csig2 = this._csig1 * csig12 - this._ssig1 * ssig12;
                                    B12 = g.SinCosSeries( true, ssig2, csig2, this._C1a );
                                    serr = ( 1 + this._A1m1 ) * ( sig12 + ( B12 - this._B11 ) ) - s12_a12 / this._b;
                                    sig12 = sig12 - serr / Math.sqrt( 1 + this._k2 * m.sq( ssig2 ) );
                                    ssig12 = Math.sin( sig12 );
                                    csig12 = Math.cos( sig12 )
                                }
                            }
                            ssig2 = this._ssig1 * csig12 + this._csig1 * ssig12;
                            csig2 = this._csig1 * csig12 - this._ssig1 * ssig12;
                            dn2 = Math.sqrt( 1 + this._k2 * m.sq( ssig2 ) );
                            if ( outmask & ( g.DISTANCE | g.REDUCEDLENGTH | g.GEODESICSCALE ) ) {
                                if ( arcmode || Math.abs( this.f ) > .01 ) B12 = g.SinCosSeries( true, ssig2, csig2, this._C1a );
                                AB1 = ( 1 + this._A1m1 ) * ( B12 - this._B11 )
                            }
                            sbet2 = this._calp0 * ssig2;
                            cbet2 = m.hypot( this._salp0, this._calp0 * csig2 );
                            if ( cbet2 === 0 ) cbet2 = csig2 = g.tiny_;
                            salp2 = this._salp0;
                            calp2 = this._calp0 * csig2;
                            if ( arcmode && outmask & g.DISTANCE ) vals.s12 = this._b * ( ( 1 + this._A1m1 ) * sig12 + AB1 );
                            if ( outmask & g.LONGITUDE ) {
                                somg2 = this._salp0 * ssig2;
                                comg2 = csig2;
                                E = m.copysign( 1, this._salp0 );
                                omg12 = outmask & g.LONG_UNROLL ? E * ( sig12 - ( Math.atan2( ssig2, csig2 ) - Math.atan2( this._ssig1, this._csig1 ) ) + ( Math.atan2( E * somg2, comg2 ) - Math.atan2( E * this._somg1, this._comg1 ) ) ) : Math.atan2( somg2 * this._comg1 - comg2 * this._somg1, comg2 * this._comg1 + somg2 * this._somg1 );
                                lam12 = omg12 + this._A3c * ( sig12 + ( g.SinCosSeries( true, ssig2, csig2, this._C3a ) - this._B31 ) );
                                lon12 = lam12 / m.degree;
                                vals.lon2 = outmask & g.LONG_UNROLL ? this.lon1 + lon12 : m.AngNormalize( m.AngNormalize( this.lon1 ) + m.AngNormalize( lon12 ) )
                            }
                            if ( outmask & g.LATITUDE ) vals.lat2 = m.atan2d( sbet2, this._f1 * cbet2 );
                            if ( outmask & g.AZIMUTH ) vals.azi2 = m.atan2d( salp2, calp2 );
                            if ( outmask & ( g.REDUCEDLENGTH | g.GEODESICSCALE ) ) {
                                B22 = g.SinCosSeries( true, ssig2, csig2, this._C2a );
                                AB2 = ( 1 + this._A2m1 ) * ( B22 - this._B21 );
                                J12 = ( this._A1m1 - this._A2m1 ) * sig12 + ( AB1 - AB2 );
                                if ( outmask & g.REDUCEDLENGTH ) vals.m12 = this._b * ( dn2 * ( this._csig1 * ssig2 ) - this._dn1 * ( this._ssig1 * csig2 ) - this._csig1 * csig2 * J12 );
                                if ( outmask & g.GEODESICSCALE ) {
                                    t = this._k2 * ( ssig2 - this._ssig1 ) * ( ssig2 + this._ssig1 ) / ( this._dn1 + dn2 );
                                    vals.M12 = csig12 + ( t * ssig2 - csig2 * J12 ) * this._ssig1 / this._dn1;
                                    vals.M21 = csig12 - ( t * this._ssig1 - this._csig1 * J12 ) * ssig2 / dn2
                                }
                            }
                            if ( outmask & g.AREA ) {
                                B42 = g.SinCosSeries( false, ssig2, csig2, this._C4a );
                                if ( this._calp0 === 0 || this._salp0 === 0 ) {
                                    salp12 = salp2 * this.calp1 - calp2 * this.salp1;
                                    calp12 = calp2 * this.calp1 + salp2 * this.salp1
                                } else {
                                    salp12 = this._calp0 * this._salp0 * ( csig12 <= 0 ? this._csig1 * ( 1 - csig12 ) + ssig12 * this._ssig1 : ssig12 * ( this._csig1 * ssig12 / ( 1 + csig12 ) + this._ssig1 ) );
                                    calp12 = m.sq( this._salp0 ) + m.sq( this._calp0 ) * this._csig1 * csig2
                                }
                                vals.S12 = this._c2 * Math.atan2( salp12, calp12 ) + this._A4 * ( B42 - this._B41 )
                            }
                            if ( !arcmode ) vals.a12 = sig12 / m.degree;
                            return vals
                        };
                        l.GeodesicLine.prototype.Position = function( s12, outmask ) {
                            return this.GenPosition( false, s12, outmask )
                        };
                        l.GeodesicLine.prototype.ArcPosition = function( a12, outmask ) {
                            return this.GenPosition( true, a12, outmask )
                        };
                        l.GeodesicLine.prototype.GenSetDistance = function( arcmode, s13_a13 ) {
                            if ( arcmode ) this.SetArc( s13_a13 );
                            else this.SetDistance( s13_a13 )
                        };
                        l.GeodesicLine.prototype.SetDistance = function( s13 ) {
                            var r;
                            this.s13 = s13;
                            r = this.GenPosition( false, this.s13, g.ARC );
                            this.a13 = 0 + r.a12
                        };
                        l.GeodesicLine.prototype.SetArc = function( a13 ) {
                            var r;
                            this.a13 = a13;
                            r = this.GenPosition( true, this.a13, g.DISTANCE );
                            this.s13 = 0 + r.s12
                        }
                    } )( GeographicLib.Geodesic, GeographicLib.GeodesicLine, GeographicLib.Math );
                    pj_add( pj_aeqd, "aeqd", "Azimuthal Equidistant", "\n\tAzi, Sph&Ell\n\tlat_0 guam" );

                    function pj_aeqd( P ) {
                        var EPS10 = 1e-10,
                            TOL = 1e-14,
                            N_POLE = 0,
                            S_POLE = 1,
                            EQUIT = 2,
                            OBLIQ = 3;
                        var sinph0, cosph0, M1, N1, Mp, He, G, mode, en, g;
                        P.phi0 = pj_param( P.params, "rlat_0" );
                        if ( fabs( fabs( P.phi0 ) - M_HALFPI ) < EPS10 ) {
                            mode = P.phi0 < 0 ? S_POLE : N_POLE;
                            sinph0 = P.phi0 < 0 ? -1 : 1;
                            cosph0 = 0
                        } else if ( fabs( P.phi0 ) < EPS10 ) {
                            mode = EQUIT;
                            sinph0 = 0;
                            cosph0 = 1
                        } else {
                            mode = OBLIQ;
                            sinph0 = sin( P.phi0 );
                            cosph0 = cos( P.phi0 )
                        }
                        if ( !P.es ) {
                            P.inv = s_inv;
                            P.fwd = s_fwd
                        } else {
                            g = new GeographicLib.Geodesic.Geodesic( P.a, P.es / ( 1 + sqrt( P.one_es ) ) );
                            en = pj_enfn( P.es );
                            if ( pj_param( P.params, "bguam" ) ) {
                                M1 = pj_mlfn( P.phi0, sinph0, cosph0, en );
                                P.inv = e_guam_inv;
                                P.fwd = e_guam_fwd
                            } else {
                                switch ( mode ) {
                                    case N_POLE:
                                        Mp = pj_mlfn( M_HALFPI, 1, 0, en );
                                        break;
                                    case S_POLE:
                                        Mp = pj_mlfn( -M_HALFPI, -1, 0, en );
                                        break;
                                    case EQUIT:
                                    case OBLIQ:
                                        P.inv = e_inv;
                                        P.fwd = e_fwd;
                                        N1 = 1 / sqrt( 1 - P.es * sinph0 * sinph0 );
                                        G = sinph0 * ( He = P.e / sqrt( P.one_es ) );
                                        He *= cosph0;
                                        break
                                }
                                P.inv = e_inv;
                                P.fwd = e_fwd
                            }
                        }

                        function e_fwd( lp, xy ) {
                            var coslam, cosphi, sinphi, rho;
                            var azi1, azi2, s12;
                            var lam1, phi1, lam2, phi2;
                            var vars;
                            coslam = cos( lp.lam );
                            cosphi = cos( lp.phi );
                            sinphi = sin( lp.phi );
                            switch ( mode ) {
                                case N_POLE:
                                    coslam = -coslam;
                                case S_POLE:
                                    xy.x = ( rho = fabs( Mp - pj_mlfn( lp.phi, sinphi, cosphi, en ) ) ) * sin( lp.lam );
                                    xy.y = rho * coslam;
                                    break;
                                case EQUIT:
                                case OBLIQ:
                                    if ( fabs( lp.lam ) < EPS10 && fabs( lp.phi - P.phi0 ) < EPS10 ) {
                                        xy.x = xy.y = 0;
                                        break
                                    }
                                    phi1 = P.phi0 / DEG_TO_RAD;
                                    lam1 = P.lam0 / DEG_TO_RAD;
                                    phi2 = lp.phi / DEG_TO_RAD;
                                    lam2 = ( lp.lam + P.lam0 ) / DEG_TO_RAD;
                                    vars = g.Inverse( phi1, lam1, phi2, lam2, g.AZIMUTH );
                                    azi1 = vars.azi1 * DEG_TO_RAD;
                                    s12 = vars.s12;
                                    xy.x = s12 * sin( azi1 ) / P.a;
                                    xy.y = s12 * cos( azi1 ) / P.a;
                                    break
                            }
                        }

                        function e_inv( xy, lp ) {
                            var c, azi1, azi2, s12, x2, y2, lat1, lon1, lat2, lon2;
                            var vars;
                            if ( ( c = hypot( xy.x, xy.y ) ) < EPS10 ) {
                                lp.phi = P.phi0;
                                lp.lam = 0;
                                return lp
                            }
                            if ( mode == OBLIQ || mode == EQUIT ) {
                                x2 = xy.x * P.a;
                                y2 = xy.y * P.a;
                                lat1 = P.phi0 / DEG_TO_RAD;
                                lon1 = P.lam0 / DEG_TO_RAD;
                                azi1 = atan2( x2, y2 ) / DEG_TO_RAD;
                                s12 = sqrt( x2 * x2 + y2 * y2 );
                                vars = g.Direct( lat1, lon1, azi1, s12, g.STANDARD );
                                lp.phi = vars.lat2 * DEG_TO_RAD;
                                lp.lam = vars.lon2 * DEG_TO_RAD;
                                lp.lam -= P.lam0
                            } else {
                                lp.phi = pj_inv_mlfn( mode == N_POLE ? Mp - c : Mp + c, P.es, en );
                                lp.lam = atan2( xy.x, mode == N_POLE ? -xy.y : xy.y )
                            }
                        }

                        function s_fwd( lp, xy ) {
                            var coslam, cosphi, sinphi;
                            sinphi = sin( lp.phi );
                            cosphi = cos( lp.phi );
                            coslam = cos( lp.lam );
                            switch ( mode ) {
                                case EQUIT:
                                case OBLIQ:
                                    if ( mode == EQUIT ) {
                                        xy.y = cosphi * coslam
                                    } else {
                                        xy.y = sinph0 * sinphi + cosph0 * cosphi * coslam
                                    }
                                    if ( fabs( fabs( xy.y ) - 1 ) < TOL )
                                        if ( xy.y < 0 ) f_error();
                                        else xy.x = xy.y = 0;
                                    else {
                                        xy.y = acos( xy.y );
                                        xy.y /= sin( xy.y );
                                        xy.x = xy.y * cosphi * sin( lp.lam );
                                        xy.y *= mode == EQUIT ? sinphi : cosph0 * sinphi - sinph0 * cosphi * coslam
                                    }
                                    break;
                                case N_POLE:
                                    lp.phi = -lp.phi;
                                    coslam = -coslam;
                                case S_POLE:
                                    if ( fabs( lp.phi - M_HALFPI ) < EPS10 ) f_error();
                                    xy.x = ( xy.y = M_HALFPI + lp.phi ) * sin( lp.lam );
                                    xy.y *= coslam;
                                    break
                            }
                        }

                        function s_inv( xy, lp ) {
                            var x = xy.x,
                                y = xy.y;
                            var cosc, c_rh, sinc;
                            if ( ( c_rh = hypot( x, y ) ) > M_PI ) {
                                if ( c_rh - EPS10 > M_PI ) i_error();
                                c_rh = M_PI
                            } else if ( c_rh < EPS10 ) {
                                lp.phi = P.phi0;
                                lp.lam = 0;
                                return
                            }
                            if ( mode == OBLIQ || mode == EQUIT ) {
                                sinc = sin( c_rh );
                                cosc = cos( c_rh );
                                if ( mode == EQUIT ) {
                                    lp.phi = aasin( y * sinc / c_rh );
                                    x *= sinc;
                                    y = cosc * c_rh
                                } else {
                                    lp.phi = aasin( cosc * sinph0 + y * sinc * cosph0 / c_rh );
                                    y = ( cosc - sinph0 * sin( lp.phi ) ) * c_rh;
                                    x *= sinc * cosph0
                                }
                                lp.lam = y == 0 ? 0 : atan2( x, y )
                            } else if ( mode == N_POLE ) {
                                lp.phi = M_HALFPI - c_rh;
                                lp.lam = atan2( x, -y )
                            } else {
                                lp.phi = c_rh - M_HALFPI;
                                lp.lam = atan2( x, y )
                            }
                        }

                        function e_guam_fwd( lp, xy ) {
                            var cosphi, sinphi, t;
                            cosphi = cos( lp.phi );
                            sinphi = sin( lp.phi );
                            t = 1 / sqrt( 1 - P.es * sinphi * sinphi );
                            xy.x = lp.lam * cosphi * t;
                            xy.y = pj_mlfn( lp.phi, sinphi, cosphi, en ) - M1 + .5 * lp.lam * lp.lam * cosphi * sinphi * t
                        }

                        function e_guam_inv( xy, lp ) {
                            var x2, t, i;
                            x2 = .5 * xy.x * xy.x;
                            lp.phi = P.phi0;
                            for ( i = 0; i < 3; ++i ) {
                                t = P.e * sin( lp.phi );
                                lp.phi = pj_inv_mlfn( M1 + xy.y - x2 * tan( lp.phi ) * ( t = sqrt( 1 - t * t ) ), P.es, en )
                            }
                            lp.lam = xy.x * t / cos( lp.phi )
                        }
                    }
                    pj_add( pj_airy, "airy", "Airy", "\n\tMisc Sph, no inv.\n\tno_cut lat_b=" );

                    function pj_airy( P ) {
                        var EPS = 1e-10,
                            N_POLE = 0,
                            S_POLE = 1,
                            EQUIT = 2,
                            OBLIQ = 3,
                            p_halfphi, sinph0, cosph0, Cb, mode, no_cut, beta;
                        P.es = 0;
                        P.fwd = s_fwd;
                        no_cut = pj_param( P.params, "bno_cut" );
                        beta = .5 * ( M_HALFPI - pj_param( P.params, "rlat_b" ) );
                        if ( fabs( beta ) < EPS ) Cb = -.5;
                        else {
                            Cb = 1 / tan( beta );
                            Cb *= Cb * log( cos( beta ) )
                        }
                        if ( fabs( fabs( P.phi0 ) - M_HALFPI ) < EPS )
                            if ( P.phi0 < 0 ) {
                                p_halfpi = -M_HALFPI;
                                mode = S_POLE
                            } else {
                                p_halfpi = M_HALFPI;
                                mode = N_POLE
                            }
                        else {
                            if ( fabs( P.phi0 ) < EPS ) mode = EQUIT;
                            else {
                                mode = OBLIQ;
                                sinph0 = sin( P.phi0 );
                                cosph0 = cos( P.phi0 )
                            }
                        }

                        function s_fwd( lp, xy ) {
                            var sinlam, coslam, cosphi, sinphi, t, s, Krho, cosz;
                            sinlam = sin( lp.lam );
                            coslam = cos( lp.lam );
                            switch ( mode ) {
                                case EQUIT:
                                case OBLIQ:
                                    sinphi = sin( lp.phi );
                                    cosphi = cos( lp.phi );
                                    cosz = cosphi * coslam;
                                    if ( mode == OBLIQ ) cosz = sinph0 * sinphi + cosph0 * cosz;
                                    if ( !no_cut && cosz < -EPS ) f_error();
                                    if ( fabs( s = 1 - cosz ) > EPS ) {
                                        t = .5 * ( 1 + cosz );
                                        Krho = -log( t ) / s - Cb / t
                                    } else {
                                        Krho = .5 - Cb
                                    }
                                    xy.x = Krho * cosphi * sinlam;
                                    if ( mode == OBLIQ ) xy.y = Krho * ( cosph0 * sinphi - sinph0 * cosphi * coslam );
                                    else xy.y = Krho * sinphi;
                                    break;
                                case S_POLE:
                                case N_POLE:
                                    lp.phi = fabs( p_halfpi - lp.phi );
                                    if ( !no_cut && lp.phi - EPS > M_HALFPI ) f_error();
                                    if ( ( lp.phi *= .5 ) > EPS ) {
                                        t = tan( lp.phi );
                                        Krho = -2 * ( log( cos( lp.phi ) ) / t + t * Cb );
                                        xy.x = Krho * sinlam;
                                        xy.y = Krho * coslam;
                                        if ( mode == N_POLE ) xy.y = -xy.y
                                    } else xy.x = xy.y = 0
                            }
                        }
                    }
                    pj_add( pj_wintri, "wintri", "Winkel Tripel", "\n\tMisc Sph\n\tlat_1" );
                    pj_add( pj_aitoff, "aitoff", "Aitoff", "\n\tMisc Sph" );

                    function pj_wintri( P ) {
                        var Q = P.opaque = {
                            mode: 1
                        };
                        if ( pj_param( P.params, "tlat_1" ) ) {
                            if ( ( Q.cosphi1 = cos( pj_param( P.params, "rlat_1" ) ) ) === 0 ) {
                                e_error( -22 )
                            }
                        } else {
                            Q.cosphi1 = .6366197723675814
                        }
                        pj_aitoff( P )
                    }

                    function pj_aitoff( P ) {
                        var Q = P.opaque || {
                            mode: 0
                        };
                        P.inv = s_inv;
                        P.fwd = s_fwd;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            var c, d;
                            if ( d = acos( cos( lp.phi ) * cos( c = .5 * lp.lam ) ) ) {
                                xy.x = 2 * d * cos( lp.phi ) * sin( c ) * ( xy.y = 1 / sin( d ) );
                                xy.y *= d * sin( lp.phi )
                            } else xy.x = xy.y = 0;
                            if ( Q.mode ) {
                                xy.x = ( xy.x + lp.lam * Q.cosphi1 ) * .5;
                                xy.y = ( xy.y + lp.phi ) * .5
                            }
                        }

                        function s_inv( xy, lp ) {
                            var MAXITER = 10,
                                MAXROUND = 20,
                                EPSILON = 1e-12,
                                round = 0,
                                iter, D, C, f1, f2, f1p, f1l, f2p, f2l, dp, dl, sl, sp, cp, cl, x, y;
                            if ( fabs( xy.x ) < EPSILON && fabs( xy.y ) < EPSILON ) {
                                lp.phi = 0;
                                lp.lam = 0;
                                return
                            }
                            lp.phi = xy.y;
                            lp.lam = xy.x;
                            do {
                                iter = 0;
                                do {
                                    sl = sin( lp.lam * .5 );
                                    cl = cos( lp.lam * .5 );
                                    sp = sin( lp.phi );
                                    cp = cos( lp.phi );
                                    D = cp * cl;
                                    C = 1 - D * D;
                                    D = acos( D ) / pow( C, 1.5 );
                                    f1 = 2 * D * C * cp * sl;
                                    f2 = D * C * sp;
                                    f1p = 2 * ( sl * cl * sp * cp / C - D * sp * sl );
                                    f1l = cp * cp * sl * sl / C + D * cp * cl * sp * sp;
                                    f2p = sp * sp * cl / C + D * sl * sl * cp;
                                    f2l = .5 * ( sp * cp * sl / C - D * sp * cp * cp * sl * cl );
                                    if ( Q.mode ) {
                                        f1 = .5 * ( f1 + lp.lam * Q.cosphi1 );
                                        f2 = .5 * ( f2 + lp.phi );
                                        f1p *= .5;
                                        f1l = .5 * ( f1l + Q.cosphi1 );
                                        f2p = .5 * ( f2p + 1 );
                                        f2l *= .5
                                    }
                                    f1 -= xy.x;
                                    f2 -= xy.y;
                                    dl = ( f2 * f1p - f1 * f2p ) / ( dp = f1p * f2l - f2p * f1l );
                                    dp = ( f1 * f2l - f2 * f1l ) / dp;
                                    while ( dl > M_PI ) dl -= M_PI;
                                    while ( dl < -M_PI ) dl += M_PI;
                                    lp.phi -= dp;
                                    lp.lam -= dl
                                } while ( ( fabs( dp ) > EPSILON || fabs( dl ) > EPSILON ) && iter++ < MAXITER );
                                if ( lp.phi > M_HALFPI ) lp.phi -= 2 * ( lp.phi - M_HALFPI );
                                if ( lp.phi < -M_HALFPI ) lp.phi -= 2 * ( lp.phi + M_HALFPI );
                                if ( fabs( fabs( lp.phi ) - M_HALFPI ) < EPSILON && !Q.mode ) lp.lam = 0;
                                if ( D = acos( cos( lp.phi ) * cos( C = .5 * lp.lam ) ) ) {
                                    x = 2 * D * cos( lp.phi ) * sin( C ) * ( y = 1 / sin( D ) );
                                    y *= D * sin( lp.phi )
                                } else x = y = 0;
                                if ( Q.mode ) {
                                    x = ( x + lp.lam * Q.cosphi1 ) * .5;
                                    y = ( y + lp.phi ) * .5
                                }
                            } while ( ( fabs( xy.x - x ) > EPSILON || fabs( xy.y - y ) > EPSILON ) && round++ < MAXROUND );
                            if ( iter == MAXITER && round == MAXROUND ) {}
                        }
                    }
                    pj_add( pj_boggs, "boggs", "Boggs Eumorphic", "\n\tPCyl., no inv., Sph." );

                    function pj_boggs( P ) {
                        var NITER = 20,
                            EPS = 1e-7,
                            ONETOL = 1.000001,
                            M_SQRT2 = sqrt( 2 ),
                            FXC = 2.00276,
                            FXC2 = 1.11072,
                            FYC = .49931;
                        P.fwd = s_fwd;

                        function s_fwd( lp, xy ) {
                            var theta, th1, c, i;
                            theta = lp.phi;
                            if ( fabs( fabs( lp.phi ) - M_HALFPI ) < EPS ) xy.x = 0;
                            else {
                                c = sin( theta ) * M_PI;
                                for ( i = NITER; i; --i ) {
                                    theta -= th1 = ( theta + sin( theta ) - c ) / ( 1 + cos( theta ) );
                                    if ( fabs( th1 ) < EPS ) break
                                }
                                theta *= .5;
                                xy.x = FXC * lp.lam / ( 1 / cos( lp.phi ) + FXC2 / cos( theta ) )
                            }
                            xy.y = FYC * ( lp.phi + M_SQRT2 * sin( theta ) )
                        }
                    }
                    pj_add( pj_bonne, "bonne", "Bonne (Werner lat_1=90)", "\n\tConic Sph&Ell\n\tlat_1=" );

                    function pj_bonne( P ) {
                        var EPS10 = 1e-10;
                        var phi1, cphi1, am1, m1, en, c;
                        phi1 = pj_param( P.params, "rlat_1" );
                        if ( fabs( phi1 ) < EPS10 ) e_error( -23 );
                        if ( P.es ) {
                            en = pj_enfn( P.es );
                            m1 = pj_mlfn( phi1, am1 = sin( phi1 ), c = cos( phi1 ), en );
                            am1 = c / ( sqrt( 1 - P.es * am1 * am1 ) * am1 );
                            P.inv = e_inv;
                            P.fwd = e_fwd
                        } else {
                            if ( fabs( phi1 ) + EPS10 >= M_HALFPI ) cphi1 = 0;
                            else cphi1 = 1 / tan( phi1 );
                            P.inv = s_inv;
                            P.fwd = s_fwd
                        }

                        function e_fwd( lp, xy ) {
                            var rh, E, c;
                            rh = am1 + m1 - pj_mlfn( lp.phi, E = sin( lp.phi ), c = cos( lp.phi ), en );
                            E = c * lp.lam / ( rh * sqrt( 1 - P.es * E * E ) );
                            xy.x = rh * sin( E );
                            xy.y = am1 - rh * cos( E )
                        }

                        function e_inv( xy, lp ) {
                            var s, rh;
                            rh = hypot( xy.x, xy.y = am1 - xy.y );
                            lp.phi = pj_inv_mlfn( am1 + m1 - rh, P.es, en );
                            if ( ( s = fabs( lp.phi ) ) < M_HALFPI ) {
                                s = sin( lp.phi );
                                lp.lam = rh * atan2( xy.x, xy.y ) * sqrt( 1 - P.es * s * s ) / cos( lp.phi )
                            } else if ( fabs( s - M_HALFPI ) <= EPS10 ) lp.lam = 0;
                            else i_error()
                        }

                        function s_fwd( lp, xy ) {
                            var E, rh;
                            rh = cphi1 + phi1 - lp.phi;
                            if ( fabs( rh ) > EPS10 ) {
                                xy.x = rh * sin( E = lp.lam * cos( lp.phi ) / rh );
                                xy.y = cphi1 - rh * cos( E )
                            } else xy.x = xy.y = 0
                        }

                        function s_inv( xy, lp ) {
                            var rh = hypot( xy.x, xy.y = cphi1 - xy.y );
                            lp.phi = cphi1 + phi1 - rh;
                            if ( fabs( lp.phi ) > M_HALFPI ) i_error();
                            if ( fabs( fabs( lp.phi ) - M_HALFPI ) <= EPS10 ) lp.lam = 0;
                            else lp.lam = rh * atan2( xy.x, xy.y ) / cos( lp.phi )
                        }
                    }
                    pj_add( pj_cass, "cass", "Cassini", "\n\tCyl, Sph&Ell" );

                    function pj_cass( P ) {
                        var C1 = .16666666666666666,
                            C2 = .008333333333333333,
                            C3 = .041666666666666664,
                            C4 = .3333333333333333,
                            C5 = .06666666666666667;
                        var m0, en;
                        if ( P.es ) {
                            en = pj_enfn( P.es );
                            m0 = pj_mlfn( P.phi0, sin( P.phi0 ), cos( P.phi0 ), en );
                            P.fwd = e_fwd;
                            P.inv = e_inv
                        } else {
                            P.fwd = s_fwd;
                            P.inv = s_inv
                        }

                        function e_fwd( lp, xy ) {
                            var n, t, a1, c, a2, tn;
                            xy.y = pj_mlfn( lp.phi, n = sin( lp.phi ), c = cos( lp.phi ), en );
                            n = 1 / sqrt( 1 - P.es * n * n );
                            tn = tan( lp.phi );
                            t = tn * tn;
                            a1 = lp.lam * c;
                            c *= P.es * c / ( 1 - P.es );
                            a2 = a1 * a1;
                            xy.x = n * a1 * ( 1 - a2 * t * ( C1 - ( 8 - t + 8 * c ) * a2 * C2 ) );
                            xy.y -= m0 - n * tn * a2 * ( .5 + ( 5 - t + 6 * c ) * a2 * C3 )
                        }

                        function e_inv( xy, lp ) {
                            var n, t, r, dd, d2, tn, ph1;
                            ph1 = pj_inv_mlfn( m0 + xy.y, P.es, en );
                            tn = tan( ph1 );
                            t = tn * tn;
                            n = sin( ph1 );
                            r = 1 / ( 1 - P.es * n * n );
                            n = sqrt( r );
                            r *= ( 1 - P.es ) * n;
                            dd = xy.x / n;
                            d2 = dd * dd;
                            lp.phi = ph1 - n * tn / r * d2 * ( .5 - ( 1 + 3 * t ) * d2 * C3 );
                            lp.lam = dd * ( 1 + t * d2 * ( -C4 + ( 1 + 3 * t ) * d2 * C5 ) ) / cos( ph1 )
                        }

                        function s_fwd( lp, xy ) {
                            xy.x = asin( cos( lp.phi ) * sin( lp.lam ) );
                            xy.y = atan2( tan( lp.phi ), cos( lp.lam ) ) - P.phi0
                        }

                        function s_inv( xy, lp ) {
                            var dd = xy.y + P.phi0;
                            lp.phi = asin( sin( dd ) * cos( xy.x ) );
                            lp.lam = atan2( tan( xy.x ), cos( dd ) )
                        }
                    }

                    function pj_authset( es ) {
                        var P00 = .3333333333333333,
                            P01 = .17222222222222222,
                            P02 = .10257936507936508,
                            P10 = .06388888888888888,
                            P11 = .0664021164021164,
                            P20 = .01677689594356261,
                            APA = [];
                        var t;
                        APA[ 0 ] = es * P00;
                        t = es * es;
                        APA[ 0 ] += t * P01;
                        APA[ 1 ] = t * P10;
                        t *= es;
                        APA[ 0 ] += t * P02;
                        APA[ 1 ] += t * P11;
                        APA[ 2 ] = t * P20;
                        return APA
                    }

                    function pj_authlat( beta, APA ) {
                        var t = beta + beta;
                        return beta + APA[ 0 ] * sin( t ) + APA[ 1 ] * sin( t + t ) + APA[ 2 ] * sin( t + t + t )
                    }
                    pj_add( pj_cea, "cea", "Equal Area Cylindrical", "\n\tCyl, Sph&Ell\n\tlat_ts=" );

                    function pj_cea( P ) {
                        var t = 0,
                            qp, apa;
                        if ( pj_param( P.params, "tlat_ts" ) ) {
                            P.k0 = cos( t = pj_param( P.params, "rlat_ts" ) );
                            if ( P.k0 < 0 ) {
                                e_error( -24 )
                            }
                        }
                        if ( P.es ) {
                            t = sin( t );
                            P.k0 /= sqrt( 1 - P.es * t * t );
                            P.e = sqrt( P.es );
                            if ( !( apa = pj_authset( P.es ) ) ) e_error_0();
                            qp = pj_qsfn( 1, P.e, P.one_es );
                            P.fwd = e_fwd;
                            P.inv = e_inv
                        } else {
                            P.fwd = s_fwd;
                            P.inv = s_inv
                        }

                        function e_fwd( lp, xy ) {
                            xy.x = P.k0 * lp.lam;
                            xy.y = .5 * pj_qsfn( sin( lp.phi ), P.e, P.one_es ) / P.k0
                        }

                        function e_inv( xy, lp ) {
                            lp.phi = pj_authlat( asin( 2 * xy.y * P.k0 / qp ), apa );
                            lp.lam = xy.x / P.k0
                        }

                        function s_fwd( lp, xy ) {
                            xy.x = P.k0 * lp.lam;
                            xy.y = sin( lp.phi ) / P.k0
                        }

                        function s_inv( xy, lp ) {
                            var x = xy.x,
                                y = xy.y;
                            var t;
                            if ( ( t = fabs( y *= P.k0 ) ) - EPS10 <= 1 ) {
                                if ( t >= 1 ) lp.phi = y < 0 ? -M_HALFPI : M_HALFPI;
                                else lp.phi = asin( y );
                                lp.lam = x / P.k0
                            } else i_error()
                        }
                    }
                    pj_add( pj_chamb, "chamb", "Chamberlin Trimetric", "\n\tMisc Sph, no inv.\n\tlat_1= lon_1= lat_2= lon_2= lat_3= lon_3=" );

                    function pj_chamb( P ) {
                        var THIRD = 1 / 3,
                            TOL = 1e-9,
                            c = [],
                            x0, y0, v, beta_0, beta_1, beta_2, i, j;
                        for ( i = 0; i < 3; ++i ) {
                            c[ i ] = {
                                p: {}
                            };
                            c[ i ].phi = pj_param( P.params, "rlat_" + ( i + 1 ) );
                            c[ i ].lam = pj_param( P.params, "rlon_" + ( i + 1 ) );
                            c[ i ].lam = adjlon( c[ i ].lam - P.lam0 );
                            c[ i ].cosphi = cos( c[ i ].phi );
                            c[ i ].sinphi = sin( c[ i ].phi )
                        }
                        for ( i = 0; i < 3; ++i ) {
                            j = i == 2 ? 0 : i + 1;
                            c[ i ].v = vect( c[ j ].phi - c[ i ].phi, c[ i ].cosphi, c[ i ].sinphi, c[ j ].cosphi, c[ j ].sinphi, c[ j ].lam - c[ i ].lam );
                            if ( !c[ i ].v.r ) e_error( -25 )
                        }
                        beta_0 = lc( c[ 0 ].v.r, c[ 2 ].v.r, c[ 1 ].v.r );
                        beta_1 = lc( c[ 0 ].v.r, c[ 1 ].v.r, c[ 2 ].v.r );
                        beta_2 = M_PI - beta_0;
                        y0 = 2 * ( c[ 0 ].p.y = c[ 1 ].p.y = c[ 2 ].v.r * sin( beta_0 ) );
                        c[ 2 ].p.y = 0;
                        c[ 0 ].p.x = -( c[ 1 ].p.x = .5 * c[ 0 ].v.r );
                        x0 = c[ 2 ].p.x = c[ 0 ].p.x + c[ 2 ].v.r * cos( beta_0 );
                        P.es = 0;
                        P.fwd = s_fwd;

                        function s_fwd( lp, xy ) {
                            var sinphi, cosphi, a, i, j, x, y;
                            var v = [];
                            sinphi = sin( lp.phi );
                            cosphi = cos( lp.phi );
                            for ( i = 0; i < 3; ++i ) {
                                v[ i ] = vect( lp.phi - c[ i ].phi, c[ i ].cosphi, c[ i ].sinphi, cosphi, sinphi, lp.lam - c[ i ].lam );
                                if ( !v[ i ].r ) break;
                                v[ i ].Az = adjlon( v[ i ].Az - c[ i ].v.Az )
                            }
                            if ( i < 3 ) {
                                x = c[ i ].p.x;
                                y = c[ i ].p.y
                            } else {
                                x = x0;
                                y = y0;
                                for ( i = 0; i < 3; ++i ) {
                                    j = i == 2 ? 0 : i + 1;
                                    a = lc( c[ i ].v.r, v[ i ].r, v[ j ].r );
                                    if ( v[ i ].Az < 0 ) a = -a;
                                    if ( !i ) {
                                        x += v[ i ].r * cos( a );
                                        y -= v[ i ].r * sin( a )
                                    } else if ( i == 1 ) {
                                        a = beta_1 - a;
                                        x -= v[ i ].r * cos( a );
                                        y -= v[ i ].r * sin( a )
                                    } else {
                                        a = beta_2 - a;
                                        x += v[ i ].r * cos( a );
                                        y += v[ i ].r * sin( a )
                                    }
                                }
                                x *= THIRD;
                                y *= THIRD
                            }
                            xy.x = x;
                            xy.y = y
                        }

                        function vect( dphi, c1, s1, c2, s2, dlam ) {
                            var v = {};
                            var cdl, dp, dl;
                            cdl = cos( dlam );
                            if ( fabs( dphi ) > 1 || fabs( dlam ) > 1 ) v.r = aacos( cs1 * s2 + c1 * c2 * cdl );
                            else {
                                dp = sin( .5 * dphi );
                                dl = sin( .5 * dlam );
                                v.r = 2 * aasin( sqrt( dp * dp + c1 * c2 * dl * dl ) )
                            }
                            if ( fabs( v.r ) > TOL ) v.Az = atan2( c2 * sin( dlam ), c1 * s2 - s1 * c2 * cdl );
                            else v.r = v.Az = 0;
                            return v
                        }

                        function lc( b, c, a ) {
                            return aacos( .5 * ( b * b + c * c - a * a ) / ( b * c ) )
                        }
                    }
                    pj_add( pj_eck1, "eck1", "Eckert I", "\n\tPCyl Sph" );
                    pj_add( pj_eck2, "eck2", "Eckert II", "\n\tPCyl Sph" );
                    pj_add( pj_eck3, "eck3", "Eckert III", "\n\tPCyl Sph" );
                    pj_add( pj_wag6, "wag6", "Wagner VI", "\n\tPCyl Sph" );
                    pj_add( pj_kav7, "kav7", "Kavraisky VII", "\n\tPCyl Sph" );
                    pj_add( pj_putp1, "putp1", "Putnins P1", "\n\tPCyl Sph" );
                    pj_add( pj_eck4, "eck4", "Eckert IV", "\n\tPCyl Sph" );
                    pj_add( pj_eck5, "eck5", "Eckert V", "\n\tPCyl Sph" );

                    function pj_eck1( P ) {
                        var FC = .9213177319235613,
                            RP = .3183098861837907;
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            xy.x = FC * lp.lam * ( 1 - RP * fabs( lp.phi ) );
                            xy.y = FC * lp.phi
                        }

                        function s_inv( xy, lp ) {
                            lp.phi = xy.y / FC;
                            lp.lam = xy.x / ( FC * ( 1 - RP * fabs( lp.phi ) ) )
                        }
                    }

                    function pj_eck2( P ) {
                        var FXC = .46065886596178063,
                            FYC = 1.4472025091165353,
                            C13 = .3333333333333333,
                            ONEEPS = 1.0000001;
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            xy.x = FXC * lp.lam * ( xy.y = sqrt( 4 - 3 * sin( fabs( lp.phi ) ) ) );
                            xy.y = FYC * ( 2 - xy.y );
                            if ( lp.phi < 0 ) xy.y = -xy.y
                        }

                        function s_inv( xy, lp ) {
                            lp.lam = xy.x / ( FXC * ( lp.phi = 2 - fabs( xy.y ) / FYC ) );
                            lp.phi = ( 4 - lp.phi * lp.phi ) * C13;
                            if ( fabs( lp.phi ) >= 1 ) {
                                if ( fabs( lp.phi ) > ONEEPS ) i_error();
                                else lp.phi = lp.phi < 0 ? -M_HALFPI : M_HALFPI
                            } else lp.phi = asin( lp.phi );
                            if ( xy.y < 0 ) lp.phi = -lp.phi
                        }
                    }

                    function pj_eck3( P ) {
                        var Q = {
                            C_x: .4222382003157712,
                            C_y: .8444764006315424,
                            A: 1,
                            B: .4052847345693511
                        };
                        pj_eck3_init( P, Q )
                    }

                    function pj_kav7( P ) {
                        var Q = {
                            C_x: .8660254037844,
                            C_y: 1,
                            A: 0,
                            B: .3039635509270133
                        };
                        pj_eck3_init( P, Q )
                    }

                    function pj_wag6( P ) {
                        var Q = {
                            C_x: .94745,
                            C_y: .94745,
                            A: 0,
                            B: .3039635509270133
                        };
                        pj_eck3_init( P, Q )
                    }

                    function pj_putp1( P ) {
                        var Q = {
                            C_x: 1.8949,
                            C_y: .94745,
                            A: -.5,
                            B: .3039635509270133
                        };
                        pj_eck3_init( P, Q )
                    }

                    function pj_eck3_init( P, Q ) {
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            xy.y = Q.C_y * lp.phi;
                            xy.x = Q.C_x * lp.lam * ( Q.A + asqrt( 1 - Q.B * lp.phi * lp.phi ) )
                        }

                        function s_inv( xy, lp ) {
                            lp.phi = xy.y / Q.C_y;
                            lp.lam = xy.x / ( Q.C_x * ( Q.A + asqrt( 1 - Q.B * lp.phi * lp.phi ) ) )
                        }
                    }

                    function pj_eck4( P ) {
                        var C_x = .4222382003157712,
                            C_y = 1.3265004281770023,
                            RC_y = .7538633073600218,
                            C_p = 3.5707963267948966,
                            RC_p = .2800495767557787,
                            EPS = 1e-7,
                            NITER = 6;
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            var p, V, s, c, i;
                            p = C_p * sin( lp.phi );
                            V = lp.phi * lp.phi;
                            lp.phi *= .895168 + V * ( .0218849 + V * .00826809 );
                            for ( i = NITER; i; --i ) {
                                c = cos( lp.phi );
                                s = sin( lp.phi );
                                lp.phi -= V = ( lp.phi + s * ( c + 2 ) - p ) / ( 1 + c * ( c + 2 ) - s * s );
                                if ( fabs( V ) < EPS ) break
                            }
                            if ( !i ) {
                                xy.x = C_x * lp.lam;
                                xy.y = lp.phi < 0 ? -C_y : C_y
                            } else {
                                xy.x = C_x * lp.lam * ( 1 + cos( lp.phi ) );
                                xy.y = C_y * sin( lp.phi )
                            }
                        }

                        function s_inv( xy, lp ) {
                            var c;
                            lp.phi = aasin( xy.y / C_y );
                            lp.lam = xy.x / ( C_x * ( 1 + ( c = cos( lp.phi ) ) ) );
                            lp.phi = aasin( ( lp.phi + sin( lp.phi ) * ( c + 2 ) ) / C_p )
                        }
                    }

                    function pj_eck5( P ) {
                        var XF = .4410127717245515,
                            RXF = 2.267508027238226,
                            YF = .882025543449103,
                            RYF = 1.133754013619113;
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            xy.x = XF * ( 1 + cos( lp.phi ) ) * lp.lam;
                            xy.y = YF * lp.phi
                        }

                        function s_inv( xy, lp ) {
                            lp.lam = RXF * xy.x / ( 1 + cos( lp.phi = RYF * xy.y ) )
                        }
                    }
                    pj_add( pj_eqc, "eqc", "Equidistant Cylindrical (Plate Caree)", "\n\tCyl, Sph\n\tlat_ts=[, lat_0=0]" );

                    function pj_eqc( P ) {
                        var rc = cos( pj_param( P.params, "rlat_ts" ) );
                        if ( rc <= 0 ) e_error( -24 );
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            xy.x = rc * lp.lam;
                            xy.y = lp.phi - P.phi0
                        }

                        function s_inv( xy, lp ) {
                            lp.lam = xy.x / rc;
                            lp.phi = xy.y + P.phi0
                        }
                    }
                    pj_add( pj_eqdc, "eqdc", "Equidistant Conic", "\n\tConic, Sph&Ell\n\tlat_1= lat_2=" );

                    function pj_eqdc( P ) {
                        var phi1, phi2, n, rho, rho0, c, en, ellips, cosphi, sinphi, secant;
                        var ml1, m1;
                        phi1 = pj_param( P.params, "rlat_1" );
                        phi2 = pj_param( P.params, "rlat_2" );
                        if ( fabs( phi1 + phi2 ) < EPS10 ) e_error( -21 );
                        if ( !( en = pj_enfn( P.es ) ) ) e_error_0();
                        n = sinphi = sin( phi1 );
                        cosphi = cos( phi1 );
                        secant = fabs( phi1 - phi2 ) >= EPS10;
                        if ( ellips = P.es > 0 ) {
                            m1 = pj_msfn( sinphi, cosphi, P.es );
                            ml1 = pj_mlfn( phi1, sinphi, cosphi, en );
                            if ( secant ) {
                                sinphi = sin( phi2 );
                                cosphi = cos( phi2 );
                                n = ( m1 - pj_msfn( sinphi, cosphi, P.es ) ) / ( pj_mlfn( phi2, sinphi, cosphi, en ) - ml1 )
                            }
                            c = ml1 + m1 / n;
                            rho0 = c - pj_mlfn( P.phi0, sin( P.phi0 ), cos( P.phi0 ), en )
                        } else {
                            if ( secant ) n = ( cosphi - cos( phi2 ) ) / ( phi2 - phi1 );
                            c = phi1 + cos( phi1 ) / n;
                            rho0 = c - P.phi0
                        }
                        P.fwd = e_fwd;
                        P.inv = e_inv;

                        function e_fwd( lp, xy ) {
                            rho = c - ( ellips ? pj_mlfn( lp.phi, sin( lp.phi ), cos( lp.phi ), en ) : lp.phi );
                            xy.x = rho * sin( lp.lam *= n );
                            xy.y = rho0 - rho * cos( lp.lam )
                        }

                        function e_inv( xy, lp ) {
                            if ( ( rho = hypot( xy.x, xy.y = rho0 - xy.y ) ) != 0 ) {
                                if ( n < 0 ) {
                                    rho = -rho;
                                    xy.x = -xy.x;
                                    xy.y = -xy.y
                                }
                                lp.phi = c - rho;
                                if ( ellips ) lp.phi = pj_inv_mlfn( lp.phi, P.es, en );
                                lp.lam = atan2( xy.x, xy.y ) / n
                            } else {
                                lp.lam = 0;
                                lp.phi = n > 0 ? M_HALFPI : -M_HALFPI
                            }
                        }
                    }
                    pj_add( pj_etmerc, "etmerc", "Extended Transverse Mercator", "\n\tCyl, Sph\n\tlat_ts=(0)\nlat_0=(0)" );
                    pj_add( pj_utm, "utm", "Universal Transverse Mercator (UTM)", "\n\tCyl, Sph\n\tzone= south" );

                    function pj_utm( P ) {
                        var zone;
                        if ( !P.es ) e_error( -34 );
                        P.y0 = pj_param( P.params, "bsouth" ) ? 1e7 : 0;
                        P.x0 = 5e5;
                        if ( pj_param( P.params, "tzone" ) ) {
                            if ( ( zone = pj_param( P.params, "izone" ) ) > 0 && zone <= 60 ) --zone;
                            else e_error( -35 )
                        } else {
                            zone = floor( ( adjlon( P.lam0 ) + M_PI ) * 30 / M_PI );
                            if ( zone < 0 ) zone = 0;
                            else if ( zone >= 60 ) zone = 59
                        }
                        P.lam0 = ( zone + .5 ) * M_PI / 30 - M_PI;
                        P.k0 = .9996;
                        P.phi0 = 0;
                        pj_etmerc( P )
                    }

                    function pj_etmerc( P ) {
                        var cgb = [],
                            cbg = [],
                            utg = [],
                            gtu = [],
                            Qn, Zb, f, n, np, Z;
                        if ( P.es <= 0 ) e_error( -34 );
                        f = P.es / ( 1 + sqrt( 1 - P.es ) );
                        np = n = f / ( 2 - f );
                        cgb[ 0 ] = n * ( 2 + n * ( -2 / 3 + n * ( -2 + n * ( 116 / 45 + n * ( 26 / 45 + n * ( -2854 / 675 ) ) ) ) ) );
                        cbg[ 0 ] = n * ( -2 + n * ( 2 / 3 + n * ( 4 / 3 + n * ( -82 / 45 + n * ( 32 / 45 + n * ( 4642 / 4725 ) ) ) ) ) );
                        np *= n;
                        cgb[ 1 ] = np * ( 7 / 3 + n * ( -8 / 5 + n * ( -227 / 45 + n * ( 2704 / 315 + n * ( 2323 / 945 ) ) ) ) );
                        cbg[ 1 ] = np * ( 5 / 3 + n * ( -16 / 15 + n * ( -13 / 9 + n * ( 904 / 315 + n * ( -1522 / 945 ) ) ) ) );
                        np *= n;
                        cgb[ 2 ] = np * ( 56 / 15 + n * ( -136 / 35 + n * ( -1262 / 105 + n * ( 73814 / 2835 ) ) ) );
                        cbg[ 2 ] = np * ( -26 / 15 + n * ( 34 / 21 + n * ( 8 / 5 + n * ( -12686 / 2835 ) ) ) );
                        np *= n;
                        cgb[ 3 ] = np * ( 4279 / 630 + n * ( -332 / 35 + n * ( -399572 / 14175 ) ) );
                        cbg[ 3 ] = np * ( 1237 / 630 + n * ( -12 / 5 + n * ( -24832 / 14175 ) ) );
                        np *= n;
                        cgb[ 4 ] = np * ( 4174 / 315 + n * ( -144838 / 6237 ) );
                        cbg[ 4 ] = np * ( -734 / 315 + n * ( 109598 / 31185 ) );
                        np *= n;
                        cgb[ 5 ] = np * ( 601676 / 22275 );
                        cbg[ 5 ] = np * ( 444337 / 155925 );
                        np = n * n;
                        Qn = P.k0 / ( 1 + n ) * ( 1 + np * ( 1 / 4 + np * ( 1 / 64 + np / 256 ) ) );
                        utg[ 0 ] = n * ( -.5 + n * ( 2 / 3 + n * ( -37 / 96 + n * ( 1 / 360 + n * ( 81 / 512 + n * ( -96199 / 604800 ) ) ) ) ) );
                        gtu[ 0 ] = n * ( .5 + n * ( -2 / 3 + n * ( 5 / 16 + n * ( 41 / 180 + n * ( -127 / 288 + n * ( 7891 / 37800 ) ) ) ) ) );
                        utg[ 1 ] = np * ( -1 / 48 + n * ( -1 / 15 + n * ( 437 / 1440 + n * ( -46 / 105 + n * ( 1118711 / 3870720 ) ) ) ) );
                        gtu[ 1 ] = np * ( 13 / 48 + n * ( -3 / 5 + n * ( 557 / 1440 + n * ( 281 / 630 + n * ( -1983433 / 1935360 ) ) ) ) );
                        np *= n;
                        utg[ 2 ] = np * ( -17 / 480 + n * ( 37 / 840 + n * ( 209 / 4480 + n * ( -5569 / 90720 ) ) ) );
                        gtu[ 2 ] = np * ( 61 / 240 + n * ( -103 / 140 + n * ( 15061 / 26880 + n * ( 167603 / 181440 ) ) ) );
                        np *= n;
                        utg[ 3 ] = np * ( -4397 / 161280 + n * ( 11 / 504 + n * ( 830251 / 7257600 ) ) );
                        gtu[ 3 ] = np * ( 49561 / 161280 + n * ( -179 / 168 + n * ( 6601661 / 7257600 ) ) );
                        np *= n;
                        utg[ 4 ] = np * ( -4583 / 161280 + n * ( 108847 / 3991680 ) );
                        gtu[ 4 ] = np * ( 34729 / 80640 + n * ( -3418889 / 1995840 ) );
                        np *= n;
                        utg[ 5 ] = np * ( -20648693 / 638668800 );
                        gtu[ 5 ] = np * ( 212378941 / 319334400 );
                        Z = gatg( cbg, P.phi0 );
                        Zb = -Qn * ( Z + clens( gtu, 2 * Z ) );
                        P.fwd = e_fwd;
                        P.inv = e_inv;

                        function e_fwd( lp, xy ) {
                            var sin_Cn, cos_Cn, cos_Ce, sin_Ce, tmp;
                            var Cn = lp.phi,
                                Ce = lp.lam;
                            Cn = gatg( cbg, Cn );
                            sin_Cn = sin( Cn );
                            cos_Cn = cos( Cn );
                            sin_Ce = sin( Ce );
                            cos_Ce = cos( Ce );
                            Cn = atan2( sin_Cn, cos_Ce * cos_Cn );
                            Ce = atan2( sin_Ce * cos_Cn, hypot( sin_Cn, cos_Cn * cos_Ce ) );
                            Ce = asinhy( tan( Ce ) );
                            tmp = clenS( gtu, 2 * Cn, 2 * Ce );
                            Cn += tmp[ 0 ];
                            Ce += tmp[ 1 ];
                            if ( fabs( Ce ) <= 2.623395162778 ) {
                                xy.y = Qn * Cn + Zb;
                                xy.x = Qn * Ce
                            } else {
                                xy.x = xy.y = HUGE_VAL
                            }
                        }

                        function e_inv( xy, lp ) {
                            var sin_Cn, cos_Cn, cos_Ce, sin_Ce, tmp;
                            var Cn = xy.y,
                                Ce = xy.x;
                            Cn = ( Cn - Zb ) / Qn;
                            Ce = Ce / Qn;
                            if ( fabs( Ce ) <= 2.623395162778 ) {
                                tmp = clenS( utg, 2 * Cn, 2 * Ce );
                                Cn += tmp[ 0 ];
                                Ce += tmp[ 1 ];
                                Ce = atan( sinh( Ce ) );
                                sin_Cn = sin( Cn );
                                cos_Cn = cos( Cn );
                                sin_Ce = sin( Ce );
                                cos_Ce = cos( Ce );
                                Ce = atan2( sin_Ce, cos_Ce * cos_Cn );
                                Cn = atan2( sin_Cn * cos_Ce, hypot( sin_Ce, cos_Ce * cos_Cn ) );
                                lp.phi = gatg( cgb, Cn );
                                lp.lam = Ce
                            } else {
                                lp.phi = lp.lam = HUGE_VAL
                            }
                        }

                        function log1py( x ) {
                            var y = 1 + x,
                                z = y - 1;
                            return z === 0 ? x : x * log( y ) / z
                        }

                        function asinhy( x ) {
                            var y = fabs( x );
                            y = log1py( y * ( 1 + y / ( hypot( 1, y ) + 1 ) ) );
                            return x < 0 ? -y : y
                        }

                        function gatg( pp, B ) {
                            var cos_2B = 2 * cos( 2 * B ),
                                i = pp.length - 1,
                                h1 = pp[ i ],
                                h2 = 0,
                                h;
                            while ( --i >= 0 ) {
                                h = -h2 + cos_2B * h1 + pp[ i ];
                                h2 = h1;
                                h1 = h
                            }
                            return B + h * sin( 2 * B )
                        }

                        function clens( pp, arg_r ) {
                            var r = 2 * cos( arg_r ),
                                i = pp.length - 1,
                                hr1 = pp[ i ],
                                hr2 = 0,
                                hr;
                            while ( --i >= 0 ) {
                                hr = -hr2 + r * hr1 + pp[ i ];
                                hr2 = hr1;
                                hr1 = hr
                            }
                            return sin( arg_r ) * hr
                        }

                        function clenS( pp, arg_r, arg_i ) {
                            var sin_arg_r = sin( arg_r ),
                                cos_arg_r = cos( arg_r ),
                                sinh_arg_i = sinh( arg_i ),
                                cosh_arg_i = cosh( arg_i ),
                                r = 2 * cos_arg_r * cosh_arg_i,
                                i = -2 * sin_arg_r * sinh_arg_i,
                                j = pp.length - 1,
                                hr = pp[ j ],
                                hi1 = 0,
                                hr1 = 0,
                                hi = 0,
                                hr2, hi2;
                            while ( --j >= 0 ) {
                                hr2 = hr1;
                                hi2 = hi1;
                                hr1 = hr;
                                hi1 = hi;
                                hr = -hr2 + r * hr1 - i * hi1 + pp[ j ];
                                hi = -hi2 + i * hr1 + r * hi1
                            }
                            r = sin_arg_r * cosh_arg_i;
                            i = cos_arg_r * sinh_arg_i;
                            return [ r * hr - i * hi, r * hi + i * hr ]
                        }
                    }
                    pj_add( pj_gall, "gall", "Gall (Gall Stereographic)", "\n\tCyl, Sph" );

                    function pj_gall( P ) {
                        var YF = 1.7071067811865475,
                            XF = .7071067811865476,
                            RYF = .585786437626905,
                            RXF = 1.4142135623730951;
                        P.fwd = s_fwd;
                        P.inv = s_inv;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            xy.x = XF * lp.lam;
                            xy.y = YF * tan( .5 * lp.phi )
                        }

                        function s_inv( xy, lp ) {
                            lp.lam = RXF * xy.x;
                            lp.phi = 2 * atan( xy.y * RYF )
                        }
                    }
                    pj_add( pj_geocent, "geocent", "Geocentric", "\n\t" );

                    function pj_geocent( P ) {
                        P.is_geocent = true;
                        P.x0 = 0;
                        P.y0 = 0;
                        P.fwd = function( lp, xy ) {
                            xy.x = lp.lam;
                            xy.y = lp.phi
                        };
                        P.inv = function( xy, lp ) {
                            lp.phi = xy.y;
                            lp.lam = xy.x
                        }
                    }
                    pj_add( pj_gilbert, "gilbert", "Gilbert Two World Perspective", "\n\tPCyl., Sph., NoInv.\n\tlat_1=" );

                    function pj_gilbert( P ) {
                        var lat1 = pj_param( P.params, "tlat_1" ) ? pj_param( P.params, "rlat_1" ) : 0,
                            phi1 = phiprime( lat1 ),
                            sp1 = sin( phi1 ),
                            cp1 = cos( phi1 );
                        P.fwd = s_fwd;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            var lam = lp.lam * .5,
                                phi = phiprime( lp.phi ),
                                sp = sin( phi ),
                                cp = cos( phi ),
                                cl = cos( lam );
                            if ( sp1 * sp + cp1 * cp * cl >= 0 ) {
                                xy.x = cp * sin( lam );
                                xy.y = cp1 * sp - sp1 * cp * cl
                            } else {
                                f_error()
                            }
                        }

                        function phiprime( phi ) {
                            return aasin( tan( .5 * phi ) )
                        }
                    }
                    pj_add( pj_gn_sinu, "gn_sinu", "General Sinusoidal Series", "\n\tPCyl, Sph.\n\tm= n=" );
                    pj_add( pj_sinu, "sinu", "Sinusoidal (Sanson-Flamsteed)", "\n\tPCyl, Sph&Ell" );
                    pj_add( pj_eck6, "eck6", "Eckert VI", "\n\tPCyl, Sph.\n\tm= n=" );
                    pj_add( pj_mbtfps, "mbtfps", "McBryde-Thomas Flat-Polar Sinusoidal", "\n\tPCyl, Sph." );

                    function pj_gn_sinu( P ) {
                        if ( pj_param( P.params, "tn" ), pj_param( P.params, "tm" ) ) {
                            pj_sinu_init( P, pj_param( P.params, "dm" ), pj_param( P.params, "dn" ) )
                        } else {
                            e_error( -99 )
                        }
                    }

                    function pj_sinu( P ) {
                        var en;
                        if ( P.es ) {
                            en = pj_enfn( P.es );
                            P.fwd = e_fwd;
                            P.inv = e_inv
                        } else {
                            pj_sinu_init( P, 0, 1 )
                        }

                        function e_fwd( lp, xy ) {
                            var s, c;
                            xy.y = pj_mlfn( lp.phi, s = sin( lp.phi ), c = cos( lp.phi ), en );
                            xy.x = lp.lam * c / sqrt( 1 - P.es * s * s )
                        }

                        function e_inv( xy, lp ) {
                            var s = fabs( lp.phi = pj_inv_mlfn( xy.y, P.es, en ) );
                            if ( s < M_HALFPI ) {
                                s = sin( lp.phi );
                                lp.lam = xy.x * sqrt( 1 - P.es * s * s ) / cos( lp.phi )
                            } else if ( s - EPS10 < M_HALFPI ) {
                                lp.lam = 0
                            } else {
                                i_error()
                            }
                        }
                    }

                    function pj_eck6( P ) {
                        pj_sinu_init( P, 1, 2.5707963267948966 )
                    }

                    function pj_mbtfps( P ) {
                        pj_sinu_init( P, .5, 1.7853981633974483 )
                    }

                    function pj_sinu_init( P, m, n ) {
                        var MAX_ITER = 8,
                            LOOP_TOL = 1e-7,
                            C_x, C_y;
                        C_x = ( C_y = sqrt( ( m + 1 ) / n ) ) / ( m + 1 );
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            var k, V, i;
                            if ( !m ) lp.phi = n != 1 ? aasin( n * sin( lp.phi ) ) : lp.phi;
                            else {
                                k = n * sin( lp.phi );
                                for ( i = MAX_ITER; i; --i ) {
                                    lp.phi -= V = ( m * lp.phi + sin( lp.phi ) - k ) / ( m + cos( lp.phi ) );
                                    if ( fabs( V ) < LOOP_TOL ) break
                                }
                                if ( !i ) f_error()
                            }
                            xy.x = C_x * lp.lam * ( m + cos( lp.phi ) );
                            xy.y = C_y * lp.phi
                        }

                        function s_inv( xy, lp ) {
                            xy.y /= C_y;
                            lp.phi = m ? aasin( ( m * xy.y + sin( xy.y ) ) / n ) : n != 1 ? aasin( sin( xy.y ) / n ) : xy.y;
                            lp.lam = xy.x / ( C_x * ( m + cos( xy.y ) ) )
                        }
                    }
                    pj_add( pj_gnom, "gnom", "Gnomonic", "\n\tAzi, Sph." );

                    function pj_gnom( P ) {
                        var EPS10 = 1e-10,
                            N_POLE = 0,
                            S_POLE = 1,
                            EQUIT = 2,
                            OBLIQ = 3;
                        var sinphi0, cosph0, mode;
                        if ( fabs( fabs( P.phi0 ) - M_HALFPI ) < EPS10 ) {
                            mode = P.phi0 < 0 ? S_POLE : N_POLE
                        } else if ( fabs( P.phi0 ) < EPS10 ) {
                            mode = EQUIT
                        } else {
                            mode = OBLIQ;
                            sinph0 = sin( P.phi0 );
                            cosph0 = cos( P.phi0 )
                        }
                        P.inv = s_inv;
                        P.fwd = s_fwd;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            var coslam, cosphi, sinphi;
                            sinphi = sin( lp.phi );
                            cosphi = cos( lp.phi );
                            coslam = cos( lp.lam );
                            switch ( mode ) {
                                case EQUIT:
                                    xy.y = cosphi * coslam;
                                    break;
                                case OBLIQ:
                                    xy.y = sinph0 * sinphi + cosph0 * cosphi * coslam;
                                    break;
                                case S_POLE:
                                    xy.y = -sinphi;
                                    break;
                                case N_POLE:
                                    xy.y = sinphi;
                                    break
                            }
                            if ( xy.y <= EPS10 ) f_error();
                            xy.x = ( xy.y = 1 / xy.y ) * cosphi * sin( lp.lam );
                            switch ( mode ) {
                                case EQUIT:
                                    xy.y *= sinphi;
                                    break;
                                case OBLIQ:
                                    xy.y *= cosph0 * sinphi - sinph0 * cosphi * coslam;
                                    break;
                                case N_POLE:
                                    coslam = -coslam;
                                case S_POLE:
                                    xy.y *= cosphi * coslam;
                                    break
                            }
                        }

                        function s_inv( xy, lp ) {
                            var x = xy.x,
                                y = xy.y;
                            var rh, cosz, sinz;
                            rh = hypot( x, y );
                            sinz = sin( lp.phi = atan( rh ) );
                            cosz = sqrt( 1 - sinz * sinz );
                            if ( fabs( rh ) <= EPS10 ) {
                                lp.phi = P.phi0;
                                lp.lam = 0
                            } else {
                                switch ( mode ) {
                                    case OBLIQ:
                                        lp.phi = cosz * sinph0 + y * sinz * cosph0 / rh;
                                        if ( fabs( lp.phi ) >= 1 ) lp.phi = lp.phi > 0 ? M_HALFPI : -M_HALFPI;
                                        else lp.phi = asin( lp.phi );
                                        y = ( cosz - sinph0 * sin( lp.phi ) ) * rh;
                                        x *= sinz * cosph0;
                                        break;
                                    case EQUIT:
                                        lp.phi = y * sinz / rh;
                                        if ( fabs( lp.phi ) >= 1 ) lp.phi = lp.phi > 0 ? M_HALFPI : -M_HALFPI;
                                        else lp.phi = asin( lp.phi );
                                        y = cosz * rh;
                                        x *= sinz;
                                        break;
                                    case S_POLE:
                                        lp.phi -= M_HALFPI;
                                        break;
                                    case N_POLE:
                                        lp.phi = M_HALFPI - lp.phi;
                                        y = -y;
                                        break
                                }
                                lp.lam = atan2( x, y )
                            }
                        }
                    }
                    pj_add( pj_laea, "laea", "Lambert Azimuthal Equal Area", "\n\tAzi, Sph&Ell" );

                    function pj_laea( P ) {
                        var EPS10 = 1e-10,
                            NITER = 20,
                            CONV = 1e-10,
                            N_POLE = 0,
                            S_POLE = 1,
                            EQUIT = 2,
                            OBLIQ = 3;
                        var sinb1, cosb1, xmf, ymf, mmf, qp, dd, rq, apa, mode, t, sinphi;
                        t = fabs( P.phi0 );
                        if ( fabs( t - M_HALFPI ) < EPS10 ) mode = P.phi0 < 0 ? S_POLE : N_POLE;
                        else if ( fabs( t ) < EPS10 ) mode = EQUIT;
                        else mode = OBLIQ;
                        if ( P.es ) {
                            P.e = sqrt( P.es );
                            qp = pj_qsfn( 1, P.e, P.one_es );
                            mmf = .5 / ( 1 - P.es );
                            apa = pj_authset( P.es );
                            switch ( mode ) {
                                case N_POLE:
                                case S_POLE:
                                    dd = 1;
                                    break;
                                case EQUIT:
                                    dd = 1 / ( rq = sqrt( .5 * qp ) );
                                    xmf = 1;
                                    ymf = .5 * qp;
                                    break;
                                case OBLIQ:
                                    rq = sqrt( .5 * qp );
                                    sinphi = sin( P.phi0 );
                                    sinb1 = pj_qsfn( sinphi, P.e, P.one_es ) / qp;
                                    cosb1 = sqrt( 1 - sinb1 * sinb1 );
                                    dd = cos( P.phi0 ) / ( sqrt( 1 - P.es * sinphi * sinphi ) * rq * cosb1 );
                                    ymf = ( xmf = rq ) / dd;
                                    xmf *= dd;
                                    break
                            }
                            P.inv = e_inv;
                            P.fwd = e_fwd
                        } else {
                            if ( mode == OBLIQ ) {
                                sinb1 = sin( P.phi0 );
                                cosb1 = cos( P.phi0 )
                            }
                            P.inv = s_inv;
                            P.fwd = s_fwd
                        }

                        function e_fwd( lp, xy ) {
                            var coslam, sinlam, sinphi, q, sinb = 0,
                                cosb = 0,
                                b = 0;
                            coslam = cos( lp.lam );
                            sinlam = sin( lp.lam );
                            sinphi = sin( lp.phi );
                            q = pj_qsfn( sinphi, P.e, P.one_es );
                            if ( mode == OBLIQ || mode == EQUIT ) {
                                sinb = q / qp;
                                cosb = sqrt( 1 - sinb * sinb )
                            }
                            switch ( mode ) {
                                case OBLIQ:
                                    b = 1 + sinb1 * sinb + cosb1 * cosb * coslam;
                                    break;
                                case EQUIT:
                                    b = 1 + cosb * coslam;
                                    break;
                                case N_POLE:
                                    b = M_HALFPI + lp.phi;
                                    q = qp - q;
                                    break;
                                case S_POLE:
                                    b = lp.phi - M_HALFPI;
                                    q = qp + q;
                                    break
                            }
                            if ( fabs( b ) < EPS10 ) f_error();
                            switch ( mode ) {
                                case OBLIQ:
                                case EQUIT:
                                    if ( mode == OBLIQ ) {
                                        b = sqrt( 2 / b );
                                        xy.y = ymf * b * ( cosb1 * sinb - sinb1 * cosb * coslam )
                                    } else {
                                        b = sqrt( 2 / ( 1 + cosb * coslam ) );
                                        xy.y = b * sinb * ymf
                                    }
                                    xy.x = xmf * b * cosb * sinlam;
                                    break;
                                case N_POLE:
                                case S_POLE:
                                    if ( q >= 0 ) {
                                        b = sqrt( q );
                                        xy.x = b * sinlam;
                                        xy.y = coslam * ( mode == S_POLE ? b : -b )
                                    } else xy.x = xy.y = 0;
                                    break
                            }
                        }

                        function e_inv( xy, lp ) {
                            var cCe, sCe, q, rho, ab = 0;
                            switch ( mode ) {
                                case EQUIT:
                                case OBLIQ:
                                    xy.x /= dd;
                                    xy.y *= dd;
                                    rho = hypot( xy.x, xy.y );
                                    if ( rho < EPS10 ) {
                                        lp.lam = 0;
                                        lp.phi = P.phi0;
                                        return lp
                                    }
                                    sCe = 2 * asin( .5 * rho / rq );
                                    cCe = cos( sCe );
                                    sCe = sin( sCe );
                                    xy.x *= sCe;
                                    if ( mode == OBLIQ ) {
                                        ab = cCe * sinb1 + xy.y * sCe * cosb1 / rho;
                                        xy.y = rho * cosb1 * cCe - xy.y * sinb1 * sCe
                                    } else {
                                        ab = xy.y * sCe / rho;
                                        xy.y = rho * cCe
                                    }
                                    break;
                                case N_POLE:
                                    xy.y = -xy.y;
                                case S_POLE:
                                    q = xy.x * xy.x + xy.y * xy.y;
                                    if ( !q ) {
                                        lp.lam = 0;
                                        lp.phi = P.phi0;
                                        return lp
                                    }
                                    ab = 1 - q / qp;
                                    if ( mode == S_POLE ) ab = -ab;
                                    break
                            }
                            lp.lam = atan2( xy.x, xy.y );
                            lp.phi = pj_authlat( asin( ab ), apa );
                            return lp
                        }

                        function s_fwd( lp, xy ) {
                            var coslam, cosphi, sinphi;
                            sinphi = sin( lp.phi );
                            cosphi = cos( lp.phi );
                            coslam = cos( lp.lam );
                            switch ( mode ) {
                                case EQUIT:
                                case OBLIQ:
                                    if ( mode == EQUIT ) {
                                        xy.y = 1 + cosphi * coslam
                                    } else {
                                        xy.y = 1 + sinb1 * sinphi + cosb1 * cosphi * coslam
                                    }
                                    if ( xy.y <= EPS10 ) f_error();
                                    xy.y = sqrt( 2 / xy.y );
                                    xy.x = xy.y * cosphi * sin( lp.lam );
                                    xy.y *= mode == EQUIT ? sinphi : cosb1 * sinphi - sinb1 * cosphi * coslam;
                                    break;
                                case N_POLE:
                                    coslam = -coslam;
                                case S_POLE:
                                    if ( fabs( lp.phi + P.phi0 ) < EPS10 ) f_error();
                                    xy.y = M_FORTPI - lp.phi * .5;
                                    xy.y = 2 * ( mode == S_POLE ? cos( xy.y ) : sin( xy.y ) );
                                    xy.x = xy.y * sin( lp.lam );
                                    xy.y *= coslam;
                                    break
                            }
                        }

                        function s_inv( xy, lp ) {
                            var cosz = 0,
                                rh, sinz = 0;
                            rh = hypot( xy.x, xy.y );
                            if ( ( lp.phi = rh * .5 ) > 1 ) i_error();
                            lp.phi = 2 * asin( lp.phi );
                            if ( mode == OBLIQ || mode == EQUIT ) {
                                sinz = sin( lp.phi );
                                cosz = cos( lp.phi )
                            }
                            switch ( mode ) {
                                case EQUIT:
                                    lp.phi = fabs( rh ) <= EPS10 ? 0 : asin( xy.y * sinz / rh );
                                    xy.x *= sinz;
                                    xy.y = cosz * rh;
                                    break;
                                case OBLIQ:
                                    lp.phi = fabs( rh ) <= EPS10 ? P.phi0 : asin( cosz * sinb1 + xy.y * sinz * cosb1 / rh );
                                    xy.x *= sinz * cosb1;
                                    xy.y = ( cosz - sin( lp.phi ) * sinb1 ) * rh;
                                    break;
                                case N_POLE:
                                    xy.y = -xy.y;
                                    lp.phi = M_HALFPI - lp.phi;
                                    break;
                                case S_POLE:
                                    lp.phi -= M_HALFPI;
                                    break
                            }
                            lp.lam = xy.y == 0 && ( mode == EQUIT || mode == OBLIQ ) ? 0 : atan2( xy.x, xy.y )
                        }
                    }
                    pj_add( pj_lonlat, "lonlat", "Lat/long (Geodetic)", "\n\t" );
                    pj_add( pj_lonlat, "longlat", "Lat/long (Geodetic alias)", "\n\t" );
                    pj_add( pj_latlon, "latlon", "Lat/long (Geodetic alias)", "\n\t" );
                    pj_add( pj_latlon, "latlong", "Lat/long (Geodetic alias)", "\n\t" );

                    function pj_lonlat( P ) {
                        pj_lonlat_init( P, false )
                    }

                    function pj_latlon( P ) {
                        pj_lonlat_init( P, true )
                    }

                    function pj_lonlat_init( P, swapped ) {
                        P.x0 = 0;
                        P.y0 = 0;
                        P.is_latlong = 1;
                        if ( swapped ) {
                            P.inv = fwd;
                            P.fwd = inv
                        } else {
                            P.inv = inv;
                            P.fwd = fwd
                        }

                        function fwd( lp, xy ) {
                            xy.x = lp.lam / P.a;
                            xy.y = lp.phi / P.a
                        }

                        function inv( xy, lp ) {
                            lp.lam = xy.x * P.a;
                            lp.phi = xy.y * P.a
                        }
                    }

                    function pj_tsfn( phi, sinphi, e ) {
                        sinphi *= e;
                        return tan( .5 * ( M_HALFPI - phi ) ) / pow( ( 1 - sinphi ) / ( 1 + sinphi ), .5 * e )
                    }
                    pj_add( pj_lcc, "lcc", "Lambert Conformal Conic", "\n\tConic, Sph&Ell\n\tlat_1= and lat_2= or lat_0=" );

                    function pj_lcc( P ) {
                        var EPS10 = 1e-10;
                        var cosphi, sinphi, secant;
                        var phi1, phi2, n, rho0, c, ellips, ml1, m1;
                        P.inv = e_inv;
                        P.fwd = e_fwd;
                        phi1 = pj_param( P.params, "rlat_1" );
                        if ( pj_param( P.params, "tlat_2" ) ) phi2 = pj_param( P.params, "rlat_2" );
                        else {
                            phi2 = phi1;
                            if ( !pj_param( P.params, "tlat_0" ) ) P.phi0 = phi1
                        }
                        if ( fabs( phi1 + phi2 ) < EPS10 ) e_error( -21 );
                        n = sinphi = sin( phi1 );
                        cosphi = cos( phi1 );
                        secant = fabs( phi1 - phi2 ) >= EPS10;
                        if ( ellips = P.es != 0 ) {
                            P.e = sqrt( P.es );
                            m1 = pj_msfn( sinphi, cosphi, P.es );
                            ml1 = pj_tsfn( phi1, sinphi, P.e );
                            if ( secant ) {
                                sinphi = sin( phi2 );
                                n = log( m1 / pj_msfn( sinphi, cos( phi2 ), P.es ) );
                                n /= log( ml1 / pj_tsfn( phi2, sinphi, P.e ) )
                            }
                            c = rho0 = m1 * pow( ml1, -n ) / n;
                            rho0 *= fabs( fabs( P.phi0 ) - M_HALFPI ) < EPS10 ? 0 : pow( pj_tsfn( P.phi0, sin( P.phi0 ), P.e ), n )
                        } else {
                            if ( secant ) n = log( cosphi / cos( phi2 ) ) / log( tan( M_FORTPI + .5 * phi2 ) / tan( M_FORTPI + .5 * phi1 ) );
                            c = cosphi * pow( tan( M_FORTPI + .5 * phi1 ), n ) / n;
                            rho0 = fabs( fabs( P.phi0 ) - M_HALFPI ) < EPS10 ? 0 : c * pow( tan( M_FORTPI + .5 * P.phi0 ), -n )
                        }

                        function e_fwd( lp, xy ) {
                            var lam = lp.lam;
                            var rho;
                            if ( fabs( fabs( lp.phi ) - M_HALFPI ) < EPS10 ) {
                                if ( lp.phi * n <= 0 ) f_error();
                                rho = 0
                            } else {
                                rho = c * ( ellips ? pow( pj_tsfn( lp.phi, sin( lp.phi ), P.e ), n ) : pow( tan( M_FORTPI + .5 * lp.phi ), -n ) )
                            }
                            lam *= n;
                            xy.x = P.k0 * ( rho * sin( lam ) );
                            xy.y = P.k0 * ( rho0 - rho * cos( lam ) )
                        }

                        function e_inv( xy, lp ) {
                            var x = xy.x,
                                y = xy.y;
                            var rho;
                            x /= P.k0;
                            y /= P.k0;
                            y = rho0 - y;
                            rho = hypot( x, y );
                            if ( rho != 0 ) {
                                if ( n < 0 ) {
                                    rho = -rho;
                                    x = -x;
                                    y = -y
                                }
                                if ( ellips ) {
                                    lp.phi = pj_phi2( pow( rho / c, 1 / n ), P.e );
                                    if ( lp.phi == HUGE_VAL ) i_error()
                                } else lp.phi = 2 * atan( pow( c / rho, 1 / n ) ) - M_HALFPI;
                                lp.lam = atan2( x, y ) / n
                            } else {
                                lp.lam = 0;
                                lp.phi = n > 0 ? M_HALFPI : -M_HALFPI
                            }
                        }
                    }
                    pj_add( pj_loxim, "loxim", "Loximuthal", "\n\tPCyl Sph" );

                    function pj_loxim( P ) {
                        var EPS = 1e-8;
                        var phi1, cosphi1, tanphi1;
                        phi1 = pj_param( P.params, "rlat_1" );
                        cosphi1 = cos( phi1 );
                        tanphi1 = tan( M_FORTPI + .5 * phi1 );
                        if ( cosphi1 < EPS ) e_error( -22 );
                        P.fwd = s_fwd;
                        P.inv = s_inv;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            xy.y = lp.phi - phi1;
                            if ( fabs( xy.y ) < EPS ) xy.x = lp.lam * cosphi1;
                            else {
                                xy.x = M_FORTPI + .5 * lp.phi;
                                if ( fabs( xy.x ) < EPS || fabs( fabs( xy.x ) - M_HALFPI ) < EPS ) xy.x = 0;
                                else xy.x = lp.lam * xy.y / log( tan( xy.x ) / tanphi1 )
                            }
                        }

                        function s_inv( xy, lp ) {
                            lp.phi = xy.y + phi1;
                            if ( fabs( xy.y ) < EPS ) {
                                lp.lam = xy.x / cosphi1
                            } else {
                                lp.lam = M_FORTPI + .5 * lp.phi;
                                if ( fabs( lp.lam ) < EPS || fabs( fabs( lp.lam ) - M_HALFPI ) < EPS ) lp.lam = 0;
                                else lp.lam = xy.x * log( tan( lp.lam ) / tanphi1 ) / xy.y
                            }
                        }
                    }

                    function pj_phi2( ts, e ) {
                        var N_ITER = 15,
                            TOL = 1e-10,
                            eccnth = .5 * e,
                            Phi = M_HALFPI - 2 * Math.atan( ts ),
                            i = N_ITER,
                            con, dphi;
                        do {
                            con = e * Math.sin( Phi );
                            dphi = M_HALFPI - 2 * Math.atan( ts * Math.pow( ( 1 - con ) / ( 1 + con ), eccnth ) ) - Phi;
                            Phi += dphi
                        } while ( Math.abs( dphi ) > TOL && --i );
                        if ( i <= 0 ) {
                            pj_ctx_set_errno( -18 )
                        }
                        return Phi
                    }
                    pj_add( pj_merc, "merc", "Mercator", "\n\tCyl, Sph&Ell\n\tlat_ts=" );

                    function pj_merc( P ) {
                        var EPS10 = 1e-10;
                        var phits = 0;
                        var is_phits = pj_param( P.params, "tlat_ts" );
                        if ( is_phits ) {
                            phits = pj_param( P.params, "rlat_ts" );
                            if ( phits >= M_HALFPI ) {
                                e_error( -24 )
                            }
                        }
                        if ( P.es ) {
                            if ( is_phits ) {
                                P.k0 = pj_msfn( Math.sin( phits ), Math.cos( phits ), P.es )
                            }
                            P.inv = e_inv;
                            P.fwd = e_fwd
                        } else {
                            P.inv = s_inv;
                            P.fwd = s_fwd
                        }

                        function e_fwd( lp, xy ) {
                            if ( fabs( fabs( lp.phi ) - M_HALFPI ) <= EPS10 ) {
                                f_error()
                            }
                            xy.x = P.k0 * lp.lam;
                            xy.y = -P.k0 * log( pj_tsfn( lp.phi, sin( lp.phi ), P.e ) )
                        }

                        function e_inv( xy, lp ) {
                            lp.phi = pj_phi2( Math.exp( -xy.y / P.k0 ), P.e );
                            if ( lp.phi === HUGE_VAL ) {
                                i_error()
                            }
                            lp.lam = xy.x / P.k0
                        }

                        function s_fwd( lp, xy ) {
                            if ( Math.abs( Math.abs( lp.phi ) - M_HALFPI ) <= EPS10 ) {
                                f_error()
                            }
                            xy.x = P.k0 * lp.lam;
                            xy.y = P.k0 * Math.log( Math.tan( M_FORTPI + .5 * lp.phi ) )
                        }

                        function s_inv( xy, lp ) {
                            lp.phi = M_HALFPI - 2 * Math.atan( Math.exp( -xy.y / P.k0 ) );
                            lp.lam = xy.x / P.k0
                        }
                    }
                    pj_add( pj_mill, "mill", "Miller Cylindrical", "\n\tCyl, Sph" );

                    function pj_mill( P ) {
                        P.fwd = s_fwd;
                        P.inv = s_inv;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            xy.x = lp.lam;
                            xy.y = log( tan( M_FORTPI + lp.phi * .4 ) ) * 1.25
                        }

                        function s_inv( xy, lp ) {
                            lp.lam = xy.x;
                            lp.phi = 2.5 * ( atan( exp( .8 * xy.y ) ) - M_FORTPI )
                        }
                    }
                    pj_add( pj_moll, "moll", "Mollweide", "\n\tPCyl Sph" );
                    pj_add( pj_wag4, "wag4", "Wagner IV", "\n\tPCyl Sph" );
                    pj_add( pj_wag5, "wag5", "Wagner V", "\n\tPCyl Sph" );

                    function pj_moll( P ) {
                        pj_moll_init( P, pj_moll_init_Q( P, M_HALFPI ) )
                    }

                    function pj_wag4( P ) {
                        pj_moll_init( P, pj_moll_init_Q( P, M_PI / 3 ) )
                    }

                    function pj_wag5( P ) {
                        var Q = {
                            C_x: .90977,
                            C_y: 1.65014,
                            C_p: 3.00896
                        };
                        pj_moll_init( P, Q )
                    }

                    function pj_moll_init_Q( P, p ) {
                        var sp = sin( p ),
                            p2 = p + p,
                            r = sqrt( M_TWOPI * sp / ( p2 + sin( p2 ) ) );
                        return {
                            C_x: 2 * r / M_PI,
                            C_y: r / sp,
                            C_p: p2 + sin( p2 )
                        }
                    }

                    function pj_moll_init( P, Q ) {
                        var MAX_ITER = 10,
                            LOOP_TOL = 1e-7;
                        P.fwd = s_fwd;
                        P.inv = s_inv;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            var k, V, i;
                            k = Q.C_p * sin( lp.phi );
                            for ( i = MAX_ITER; i; --i ) {
                                lp.phi -= V = ( lp.phi + sin( lp.phi ) - k ) / ( 1 + cos( lp.phi ) );
                                if ( fabs( V ) < LOOP_TOL ) break
                            }
                            if ( !i ) lp.phi = lp.phi < 0 ? -M_HALFPI : M_HALFPI;
                            else lp.phi *= .5;
                            xy.x = Q.C_x * lp.lam * cos( lp.phi );
                            xy.y = Q.C_y * sin( lp.phi )
                        }

                        function s_inv( xy, lp ) {
                            lp.phi = aasin( xy.y / Q.C_y );
                            lp.lam = xy.x / ( Q.C_x * cos( lp.phi ) );
                            if ( fabs( lp.lam ) - M_PI < EPS10 ) {
                                lp.phi += lp.phi;
                                lp.phi = aasin( ( lp.phi + sin( lp.phi ) ) / Q.C_p )
                            } else {
                                lp.lam = lp.phi = HUGE_VAL
                            }
                        }
                    }
                    pj_add( pj_natearth, "natearth", "Natural Earth", "\n\tPCyl., Sph." );
                    pj_add( pj_natearth2, "natearth2", "Natural Earth 2", "\n\tPCyl., Sph." );

                    function pj_natearth( P ) {
                        var A0 = .8707,
                            A1 = -.131979,
                            A2 = -.013791,
                            A3 = .003971,
                            A4 = -.001529,
                            B0 = 1.007226,
                            B1 = .015085,
                            B2 = -.044475,
                            B3 = .028874,
                            B4 = -.005916,
                            C0 = B0,
                            C1 = 3 * B1,
                            C2 = 7 * B2,
                            C3 = 9 * B3,
                            C4 = 11 * B4,
                            EPS = 1e-11,
                            MAX_Y = .8707 * .52 * M_PI;
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            var phi2, phi4;
                            phi2 = lp.phi * lp.phi;
                            phi4 = phi2 * phi2;
                            xy.x = lp.lam * ( A0 + phi2 * ( A1 + phi2 * ( A2 + phi4 * phi2 * ( A3 + phi2 * A4 ) ) ) );
                            xy.y = lp.phi * ( B0 + phi2 * ( B1 + phi4 * ( B2 + B3 * phi2 + B4 * phi4 ) ) )
                        }

                        function s_inv( xy, lp ) {
                            var x = xy.x,
                                y = xy.y;
                            var yc, tol, y2, y4, f, fder;
                            if ( y > MAX_Y ) {
                                y = MAX_Y
                            } else if ( y < -MAX_Y ) {
                                y = -MAX_Y
                            }
                            yc = y;
                            for ( ;; ) {
                                y2 = yc * yc;
                                y4 = y2 * y2;
                                f = yc * ( B0 + y2 * ( B1 + y4 * ( B2 + B3 * y2 + B4 * y4 ) ) ) - y;
                                fder = C0 + y2 * ( C1 + y4 * ( C2 + C3 * y2 + C4 * y4 ) );
                                yc -= tol = f / fder;
                                if ( fabs( tol ) < EPS ) {
                                    break
                                }
                            }
                            lp.phi = yc;
                            y2 = yc * yc;
                            lp.lam = x / ( A0 + y2 * ( A1 + y2 * ( A2 + y2 * y2 * y2 * ( A3 + y2 * A4 ) ) ) )
                        }
                    }

                    function pj_natearth2( P ) {
                        var A0 = .84719,
                            A1 = -.13063,
                            A2 = -.04515,
                            A3 = .05494,
                            A4 = -.02326,
                            A5 = .00331,
                            B0 = 1.01183,
                            B1 = -.02625,
                            B2 = .01926,
                            B3 = -.00396,
                            C0 = B0,
                            C1 = 9 * B1,
                            C2 = 11 * B2,
                            C3 = 13 * B3,
                            EPS = 1e-11,
                            MAX_Y = .84719 * .535117535153096 * M_PI;
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            var phi2, phi4, phi6;
                            phi2 = lp.phi * lp.phi;
                            phi4 = phi2 * phi2;
                            phi6 = phi2 * phi4;
                            xy.x = lp.lam * ( A0 + A1 * phi2 + phi6 * phi6 * ( A2 + A3 * phi2 + A4 * phi4 + A5 * phi6 ) );
                            xy.y = lp.phi * ( B0 + phi4 * phi4 * ( B1 + B2 * phi2 + B3 * phi4 ) )
                        }

                        function s_inv( xy, lp ) {
                            var x = xy.x,
                                y = xy.y;
                            var yc, tol, y2, y4, y6, f, fder;
                            if ( y > MAX_Y ) {
                                y = MAX_Y
                            } else if ( y < -MAX_Y ) {
                                y = -MAX_Y
                            }
                            yc = y;
                            for ( ;; ) {
                                y2 = yc * yc;
                                y4 = y2 * y2;
                                f = yc * ( B0 + y4 * y4 * ( B1 + B2 * y2 + B3 * y4 ) ) - y;
                                fder = C0 + y4 * y4 * ( C1 + C2 * y2 + C3 * y4 );
                                yc -= tol = f / fder;
                                if ( fabs( tol ) < EPS ) {
                                    break
                                }
                            }
                            lp.phi = yc;
                            y2 = yc * yc;
                            y4 = y2 * y2;
                            y6 = y2 * y4;
                            lp.lam = x / ( A0 + A1 * y2 + y6 * y6 * ( A2 + A3 * y2 + A4 * y4 + A5 * y6 ) )
                        }
                    }
                    pj_add( pj_nell_h, "nell_h", "Nell-Hammer", "\n\tPCyl., Sph." );

                    function pj_nell_h( P ) {
                        var NITER = 9,
                            EPS = 1e-7;
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            xy.x = .5 * lp.lam * ( 1 + cos( lp.phi ) );
                            xy.y = 2 * ( lp.phi - tan( .5 * lp.phi ) )
                        }

                        function s_inv( xy, lp ) {
                            var V, c, p, i;
                            p = .5 * xy.y;
                            for ( i = NITER; i > 0; --i ) {
                                c = cos( .5 * lp.phi );
                                lp.phi -= V = ( lp.phi - tan( lp.phi / 2 ) - p ) / ( 1 - .5 / ( c * c ) );
                                if ( fabs( V ) < EPS ) break
                            }
                            if ( !i ) {
                                lp.phi = p < 0 ? -M_HALFPI : M_HALFPI;
                                lp.lam = 2 * xy.x
                            } else lp.lam = 2 * xy.x / ( 1 + cos( lp.phi ) )
                        }
                    }
                    pj_add( pj_nsper, "nsper", "Near-sided perspective", "\n\tAzi, Sph\n\th=" );
                    pj_add( pj_tpers, "tpers", "Tilted perspective", "\n\tAzi, Sph\n\ttilt= azi= h=" );

                    function pj_nsper( P ) {
                        pj_tpers_init( P, pj_param( P.params, "dh" ) )
                    }

                    function pj_tpers( P ) {
                        var tilt = pj_param( P.params, "dtilt" ) * DEG_TO_RAD;
                        var azi = pj_param( P.params, "dazi" ) * DEG_TO_RAD;
                        var height = pj_param( P.params, "dh" );
                        pj_tpers_init( P, height, tilt, azi )
                    }

                    function pj_tpers_init( P, height, tiltAngle, azimuth ) {
                        var N_POLE = 0,
                            S_POLE = 1,
                            EIT = 2,
                            OBLI = 3,
                            tilt = !isNaN( tiltAngle ) && !isNaN( azimuth ),
                            mode, sinph0, cosph0, p, rp, pn1, pfact, h, cg, sg, sw, cw;
                        if ( height <= 0 ) e_error( -30 );
                        if ( tilt ) {
                            cg = cos( azimuth );
                            sg = sin( azimuth );
                            cw = cos( tiltAngle );
                            sw = sin( tiltAngle )
                        }
                        if ( fabs( fabs( P.phi0 ) - M_HALFPI ) < EPS10 ) mode = P.phi0 < 0 ? S_POLE : N_POLE;
                        else if ( fabs( P.phi0 ) < EPS10 ) mode = EIT;
                        else {
                            mode = OBLI;
                            sinph0 = sin( P.phi0 );
                            cosph0 = cos( P.phi0 )
                        }
                        pn1 = height / P.a;
                        p = 1 + pn1;
                        rp = 1 / p;
                        h = 1 / pn1;
                        pfact = ( p + 1 ) * h;
                        P.fwd = s_fwd;
                        P.inv = s_inv;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            var coslam, cosphi, sinphi;
                            var yt, ba;
                            sinphi = sin( lp.phi );
                            cosphi = cos( lp.phi );
                            coslam = cos( lp.lam );
                            switch ( mode ) {
                                case OBLI:
                                    xy.y = sinph0 * sinphi + cosph0 * cosphi * coslam;
                                    break;
                                case EIT:
                                    xy.y = cosphi * coslam;
                                    break;
                                case S_POLE:
                                    xy.y = -sinphi;
                                    break;
                                case N_POLE:
                                    xy.y = sinphi;
                                    break
                            }
                            if ( xy.y < rp ) f_error();
                            xy.y = pn1 / ( p - xy.y );
                            xy.x = xy.y * cosphi * sin( lp.lam );
                            switch ( mode ) {
                                case OBLI:
                                    xy.y *= cosph0 * sinphi - sinph0 * cosphi * coslam;
                                    break;
                                case EIT:
                                    xy.y *= sinphi;
                                    break;
                                case N_POLE:
                                    coslam = -coslam;
                                case S_POLE:
                                    xy.y *= cosphi * coslam;
                                    break
                            }
                            if ( tilt ) {
                                yt = xy.y * cg + xy.x * sg;
                                ba = 1 / ( yt * sw * h + cw );
                                xy.x = ( xy.x * cg - xy.y * sg ) * cw * ba;
                                xy.y = yt * ba
                            }
                        }

                        function s_inv( xy, lp ) {
                            var rh, cosz, sinz;
                            var bm, bq, yt;
                            if ( tilt ) {
                                yt = 1 / ( pn1 - xy.y * sw );
                                bm = pn1 * xy.x * yt;
                                bq = pn1 * xy.y * cw * yt;
                                xy.x = bm * cg + bq * sg;
                                xy.y = bq * cg - bm * sg
                            }
                            rh = hypot( xy.x, xy.y );
                            if ( ( sinz = 1 - rh * rh * pfact ) < 0 ) i_error();
                            sinz = ( p - sqrt( sinz ) ) / ( pn1 / rh + rh / pn1 );
                            cosz = sqrt( 1 - sinz * sinz );
                            if ( fabs( rh ) <= EPS10 ) {
                                lp.lam = 0;
                                lp.phi = P.phi0
                            } else {
                                switch ( mode ) {
                                    case OBLI:
                                        lp.phi = asin( cosz * sinph0 + xy.y * sinz * cosph0 / rh );
                                        xy.y = ( cosz - sinph0 * sin( lp.phi ) ) * rh;
                                        xy.x *= sinz * cosph0;
                                        break;
                                    case EIT:
                                        lp.phi = asin( xy.y * sinz / rh );
                                        xy.y = cosz * rh;
                                        xy.x *= sinz;
                                        break;
                                    case N_POLE:
                                        lp.phi = asin( cosz );
                                        xy.y = -xy.y;
                                        break;
                                    case S_POLE:
                                        lp.phi = -asin( cosz );
                                        break
                                }
                                lp.lam = atan2( xy.x, xy.y )
                            }
                        }
                    }
                    pj_add( pj_ocea, "ocea", "Oblique Cylindrical Equal Area", "\n\tCyl, Sph lonc= alpha= or\n\tlat_1= lat_2= lon_1= lon_2=" );

                    function pj_ocea( P ) {
                        var phi_0 = 0,
                            phi_1, phi_2, lam_1, lam_2, lonz, alpha, rok, rtk, sinphi, cosphi, singam, cosgam;
                        rok = P.a / P.k0;
                        rtk = P.a * P.k0;
                        if ( pj_param( P.params, "talpha" ) ) {
                            alpha = pj_param( P.params, "ralpha" );
                            lonz = pj_param( P.params, "rlonc" );
                            singam = atan( -cos( alpha ) / ( -sin( phi_0 ) * sin( alpha ) ) ) + lonz;
                            sinphi = asin( cos( phi_0 ) * sin( alpha ) )
                        } else {
                            phi_1 = pj_param( P.params, "rlat_1" );
                            phi_2 = pj_param( P.params, "rlat_2" );
                            lam_1 = pj_param( P.params, "rlon_1" );
                            lam_2 = pj_param( P.params, "rlon_2" );
                            singam = atan2( cos( phi_1 ) * sin( phi_2 ) * cos( lam_1 ) - sin( phi_1 ) * cos( phi_2 ) * cos( lam_2 ), sin( phi_1 ) * cos( phi_2 ) * sin( lam_2 ) - cos( phi_1 ) * sin( phi_2 ) * sin( lam_1 ) );
                            sinphi = atan( -cos( singam - lam_1 ) / tan( phi_1 ) )
                        }
                        P.lam0 = singam + M_HALFPI;
                        cosphi = cos( sinphi );
                        sinphi = sin( sinphi );
                        cosgam = cos( singam );
                        singam = sin( singam );
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            var t;
                            xy.y = sin( lp.lam );
                            t = cos( lp.lam );
                            xy.x = atan( ( tan( lp.phi ) * cosphi + sinphi * xy.y ) / t );
                            if ( t < 0 ) xy.x += M_PI;
                            xy.x *= rtk;
                            xy.y = rok * ( sinphi * sin( lp.phi ) - cosphi * cos( lp.phi ) * xy.y )
                        }

                        function s_inv( xy, lp ) {
                            var t, s;
                            xy.y /= rok;
                            xy.x /= rtk;
                            t = sqrt( 1 - xy.y * xy.y );
                            lp.phi = asin( xy.y * sinphi + t * cosphi * ( s = sin( xy.x ) ) );
                            lp.lam = atan2( t * sinphi * s - xy.y * cosphi, t * cos( xy.x ) )
                        }
                    }
                    pj_add( pj_omerc, "omerc", "Oblique Mercator", "\n\tCyl, Sph&Ell no_rot" + "\n\talpha= [gamma=] [no_off] lonc= or\n\t lon_1= lat_1= lon_2= lat_2=" );

                    function pj_omerc( P ) {
                        var TOL = 1e-7;
                        var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,
                            gamma0, lamc = 0,
                            lam1 = 0,
                            lam2 = 0,
                            phi1 = 0,
                            phi2 = 0,
                            alpha_c = 0;
                        var alp, gam, no_off = 0;
                        var A, B, E, AB, ArB, BrA, rB, singam, cosgam, sinrot, cosrot;
                        var v_pole_n, v_pole_s, u_0;
                        var no_rot;
                        no_rot = pj_param( P.params, "tno_rot" );
                        if ( ( alp = pj_param( P.params, "talpha" ) ) != 0 ) alpha_c = pj_param( P.params, "ralpha" );
                        if ( ( gam = pj_param( P.params, "tgamma" ) ) != 0 ) gamma = pj_param( P.params, "rgamma" );
                        if ( alp || gam ) {
                            lamc = pj_param( P.params, "rlonc" );
                            no_off = pj_param( P.params, "tno_off" ) || pj_param( P.params, "tno_uoff" );
                            if ( no_off ) {
                                pj_param( P.params, "sno_uoff" );
                                pj_param( P.params, "sno_off" )
                            }
                        } else {
                            lam1 = pj_param( P.params, "rlon_1" );
                            phi1 = pj_param( P.params, "rlat_1" );
                            lam2 = pj_param( P.params, "rlon_2" );
                            phi2 = pj_param( P.params, "rlat_2" );
                            if ( fabs( phi1 - phi2 ) <= TOL || ( con = fabs( phi1 ) ) <= TOL || fabs( con - M_HALFPI ) <= TOL || fabs( fabs( P.phi0 ) - M_HALFPI ) <= TOL || fabs( fabs( phi2 ) - M_HALFPI ) <= TOL ) e_error( -33 )
                        }
                        com = sqrt( P.one_es );
                        if ( fabs( P.phi0 ) > EPS10 ) {
                            sinph0 = sin( P.phi0 );
                            cosph0 = cos( P.phi0 );
                            con = 1 - P.es * sinph0 * sinph0;
                            B = cosph0 * cosph0;
                            B = sqrt( 1 + P.es * B * B / P.one_es );
                            A = B * P.k0 * com / con;
                            D = B * com / ( cosph0 * sqrt( con ) );
                            if ( ( F = D * D - 1 ) <= 0 ) F = 0;
                            else {
                                F = sqrt( F );
                                if ( P.phi0 < 0 ) F = -F
                            }
                            E = F += D;
                            E *= pow( pj_tsfn( P.phi0, sinph0, P.e ), B )
                        } else {
                            B = 1 / com;
                            A = P.k0;
                            E = D = F = 1
                        }
                        if ( alp || gam ) {
                            if ( alp ) {
                                gamma0 = asin( sin( alpha_c ) / D );
                                if ( !gam ) gamma = alpha_c
                            } else alpha_c = asin( D * sin( gamma0 = gamma ) );
                            if ( ( con = fabs( alpha_c ) ) <= TOL || fabs( con - M_PI ) <= TOL || fabs( fabs( P.phi0 ) - M_HALFPI ) <= TOL ) e_error( -32 );
                            P.lam0 = lamc - asin( .5 * ( F - 1 / F ) * tan( gamma0 ) ) / B
                        } else {
                            H = pow( pj_tsfn( phi1, sin( phi1 ), P.e ), B );
                            L = pow( pj_tsfn( phi2, sin( phi2 ), P.e ), B );
                            F = E / H;
                            p = ( L - H ) / ( L + H );
                            J = E * E;
                            J = ( J - L * H ) / ( J + L * H );
                            if ( ( con = lam1 - lam2 ) < -M_PI ) lam2 -= M_TWOPI;
                            else if ( con > M_PI ) lam2 += M_TWOPI;
                            P.lam0 = adjlon( .5 * ( lam1 + lam2 ) - atan( J * tan( .5 * B * ( lam1 - lam2 ) ) / p ) / B );
                            gamma0 = atan( 2 * sin( B * adjlon( lam1 - P.lam0 ) ) / ( F - 1 / F ) );
                            gamma = alpha_c = asin( D * sin( gamma0 ) )
                        }
                        singam = sin( gamma0 );
                        cosgam = cos( gamma0 );
                        sinrot = sin( gamma );
                        cosrot = cos( gamma );
                        BrA = 1 / ( ArB = A * ( rB = 1 / B ) );
                        AB = A * B;
                        if ( no_off ) u_0 = 0;
                        else {
                            u_0 = fabs( ArB * atan2( sqrt( D * D - 1 ), cos( alpha_c ) ) );
                            if ( P.phi0 < 0 ) u_0 = -u_0
                        }
                        F = .5 * gamma0;
                        v_pole_n = ArB * log( tan( M_FORTPI - F ) );
                        v_pole_s = ArB * log( tan( M_FORTPI + F ) );
                        P.fwd = e_fwd;
                        P.inv = e_inv;

                        function e_fwd( lp, xy ) {
                            var S, T, U, V, W, temp, u, v;
                            if ( fabs( fabs( lp.phi ) - M_HALFPI ) > EPS10 ) {
                                W = E / pow( pj_tsfn( lp.phi, sin( lp.phi ), P.e ), B );
                                temp = 1 / W;
                                S = .5 * ( W - temp );
                                T = .5 * ( W + temp );
                                V = sin( B * lp.lam );
                                U = ( S * singam - V * cosgam ) / T;
                                if ( fabs( fabs( U ) - 1 ) < EPS10 ) f_error();
                                v = .5 * ArB * log( ( 1 - U ) / ( 1 + U ) );
                                temp = cos( B * lp.lam );
                                if ( fabs( temp ) < TOL ) {
                                    u = A * lp.lam
                                } else {
                                    u = ArB * atan2( S * cosgam + V * singam, temp )
                                }
                            } else {
                                v = lp.phi > 0 ? v_pole_n : v_pole_s;
                                u = ArB * lp.phi
                            }
                            if ( no_rot ) {
                                xy.x = u;
                                xy.y = v
                            } else {
                                u -= u_0;
                                xy.x = v * cosrot + u * sinrot;
                                xy.y = u * cosrot - v * sinrot
                            }
                        }

                        function e_inv( xy, lp ) {
                            var u, v, Qp, Sp, Tp, Vp, Up;
                            if ( no_rot ) {
                                v = xy.y;
                                u = xy.x
                            } else {
                                v = xy.x * cosrot - xy.y * sinrot;
                                u = xy.y * cosrot + xy.x * sinrot + u_0
                            }
                            Qp = exp( -BrA * v );
                            Sp = .5 * ( Qp - 1 / Qp );
                            Tp = .5 * ( Qp + 1 / Qp );
                            Vp = sin( BrA * u );
                            Up = ( Vp * cosgam + Sp * singam ) / Tp;
                            if ( fabs( fabs( Up ) - 1 ) < EPS10 ) {
                                lp.lam = 0;
                                lp.phi = Up < 0 ? -M_HALFPI : M_HALFPI
                            } else {
                                lp.phi = E / sqrt( ( 1 + Up ) / ( 1 - Up ) );
                                if ( ( lp.phi = pj_phi2( pow( lp.phi, 1 / B ), P.e ) ) == HUGE_VAL ) i_error();
                                lp.lam = -rB * atan2( Sp * cosgam - Vp * singam, cos( BrA * u ) )
                            }
                        }
                    }
                    pj_add( pj_ortho, "ortho", "Orthographic", "\n\tAzi, Sph." );

                    function pj_ortho( P ) {
                        var EPS10 = 1e-10,
                            N_POLE = 0,
                            S_POLE = 1,
                            EQUIT = 2,
                            OBLIQ = 3;
                        var Q = {};
                        if ( fabs( fabs( P.phi0 ) - M_HALFPI ) <= EPS10 ) Q.mode = P.phi0 < 0 ? S_POLE : N_POLE;
                        else if ( fabs( P.phi0 ) > EPS10 ) {
                            Q.mode = OBLIQ;
                            Q.sinph0 = sin( P.phi0 );
                            Q.cosph0 = cos( P.phi0 )
                        } else Q.mode = EQUIT;
                        P.fwd = s_fwd;
                        P.inv = s_inv;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            var coslam, cosphi, sinphi;
                            cosphi = cos( lp.phi );
                            coslam = cos( lp.lam );
                            switch ( Q.mode ) {
                                case EQUIT:
                                    if ( cosphi * coslam < -EPS10 ) f_error();
                                    xy.y = sin( lp.phi );
                                    break;
                                case OBLIQ:
                                    if ( Q.sinph0 * ( sinphi = sin( lp.phi ) ) + Q.cosph0 * cosphi * coslam < -EPS10 ) f_error();
                                    xy.y = Q.cosph0 * sinphi - Q.sinph0 * cosphi * coslam;
                                    break;
                                case N_POLE:
                                    coslam = -coslam;
                                case S_POLE:
                                    if ( fabs( lp.phi - P.phi0 ) - EPS10 > M_HALFPI ) f_error();
                                    xy.y = cosphi * coslam;
                                    break
                            }
                            xy.x = cosphi * sin( lp.lam )
                        }

                        function s_inv( xy, lp ) {
                            var rh, cosc, sinc;
                            if ( ( sinc = rh = hypot( xy.x, xy.y ) ) > 1 ) {
                                if ( sinc - 1 > EPS10 ) i_error();
                                sinc = 1
                            }
                            cosc = sqrt( 1 - sinc * sinc );
                            if ( fabs( rh ) <= EPS10 ) {
                                lp.phi = P.phi0;
                                lp.lam = 0
                            } else {
                                switch ( Q.mode ) {
                                    case N_POLE:
                                        xy.y = -xy.y;
                                        lp.phi = acos( sinc );
                                        break;
                                    case S_POLE:
                                        lp.phi = -acos( sinc );
                                        break;
                                    case EQUIT:
                                    case OBLIQ:
                                        if ( Q.mode == EQUIT ) {
                                            lp.phi = xy.y * sinc / rh;
                                            xy.x *= sinc;
                                            xy.y = cosc * rh
                                        } else {
                                            lp.phi = cosc * Q.sinph0 + xy.y * sinc * Q.cosph0 / rh;
                                            xy.y = ( cosc - Q.sinph0 * lp.phi ) * rh;
                                            xy.x *= sinc * Q.cosph0
                                        }
                                        if ( fabs( lp.phi ) >= 1 ) lp.phi = lp.phi < 0 ? -M_HALFPI : M_HALFPI;
                                        else lp.phi = asin( lp.phi );
                                        break
                                }
                                lp.lam = xy.y == 0 && ( Q.mode == OBLIQ || Q.mode == EQUIT ) ? xy.x == 0 ? 0 : xy.x < 0 ? -M_HALFPI : M_HALFPI : atan2( xy.x, xy.y )
                            }
                        }
                    }
                    pj_add( pj_poly, "poly", "Polyconic (American)", "\n\tConic, Sph&Ell" );

                    function pj_poly( P ) {
                        var TOL = 1e-10,
                            CONV = 1e-10,
                            N_ITER = 10,
                            I_ITER = 20,
                            ITOL = 1e-12,
                            ml0, en;
                        if ( P.es ) {
                            en = pj_enfn( P.es );
                            ml0 = pj_mlfn( P.phi0, sin( P.phi0 ), cos( P.phi0 ), en );
                            P.fwd = e_fwd;
                            P.inv = e_inv
                        } else {
                            ml0 = -P.phi0;
                            P.fwd = s_fwd;
                            P.inv = s_inv
                        }

                        function e_fwd( lp, xy ) {
                            var ms, sp, cp;
                            if ( fabs( lp.phi ) <= TOL ) {
                                xy.x = lp.lam;
                                xy.y = -ml0
                            } else {
                                sp = sin( lp.phi );
                                ms = fabs( cp = cos( lp.phi ) ) > TOL ? pj_msfn( sp, cp, P.es ) / sp : 0;
                                xy.x = ms * sin( lp.lam *= sp );
                                xy.y = pj_mlfn( lp.phi, sp, cp, en ) - ml0 + ms * ( 1 - cos( lp.lam ) )
                            }
                        }

                        function e_inv( xy, lp ) {
                            var x = xy.x,
                                y = xy.y;
                            var r, c, sp, cp, s2ph, ml, mlb, mlp, dPhi, i;
                            y += ml0;
                            if ( fabs( y ) <= TOL ) {
                                lp.lam = x;
                                lp.phi = 0
                            } else {
                                r = y * y + x * x;
                                for ( lp.phi = y, i = I_ITER; i > 0; --i ) {
                                    sp = sin( lp.phi );
                                    s2ph = sp * ( cp = cos( lp.phi ) );
                                    if ( fabs( cp ) < ITOL ) i_error();
                                    c = sp * ( mlp = sqrt( 1 - P.es * sp * sp ) ) / cp;
                                    ml = pj_mlfn( lp.phi, sp, cp, en );
                                    mlb = ml * ml + r;
                                    mlp = P.one_es / ( mlp * mlp * mlp );
                                    lp.phi += dPhi = ( ml + ml + c * mlb - 2 * y * ( c * ml + 1 ) ) / ( P.es * s2ph * ( mlb - 2 * y * ml ) / c + 2 * ( y - ml ) * ( c * mlp - 1 / s2ph ) - mlp - mlp );
                                    if ( fabs( dPhi ) <= ITOL ) break
                                }
                                if ( !i ) {
                                    i_error()
                                }
                                c = sin( lp.phi );
                                lp.lam = asin( x * tan( lp.phi ) * sqrt( 1 - P.es * c * c ) ) / sin( lp.phi )
                            }
                        }

                        function s_fwd( lp, xy ) {
                            var cot, E;
                            if ( fabs( lp.phi ) <= TOL ) {
                                xy.x = lp.lam;
                                xy.y = ml0
                            } else {
                                cot = 1 / tan( lp.phi );
                                xy.x = sin( E = lp.lam * sin( lp.phi ) ) * cot;
                                xy.y = lp.phi - P.phi0 + cot * ( 1 - cos( E ) )
                            }
                        }

                        function s_inv( xy, lp ) {
                            var B, dphi, tp, i;
                            if ( fabs( xy.y = P.phi0 + xy.y ) <= TOL ) {
                                lp.lam = xy.x;
                                lp.phi = 0
                            } else {
                                lp.phi = xy.y;
                                B = xy.x * xy.x + xy.y * xy.y;
                                i = N_ITER;
                                do {
                                    tp = tan( lp.phi );
                                    lp.phi -= dphi = ( xy.y * ( lp.phi * tp + 1 ) - lp.phi - .5 * ( lp.phi * lp.phi + B ) * tp ) / ( ( lp.phi - xy.y ) / tp - 1 )
                                } while ( fabs( dphi ) > CONV && --i );
                                if ( !i ) i_error();
                                lp.lam = asin( xy.x * tan( lp.phi ) ) / sin( lp.phi )
                            }
                        }
                    }
                    pj_add( pj_robin, "robin", "Robinson", "\n\tPCyl., Sph." );

                    function pj_robin( P ) {
                        var X = to_float( [ [ 1, 2.2199e-17, -715515e-10, 31103e-10 ], [ .9986, -482243e-9, -24897e-9, -13309e-10 ], [ .9954, -83103e-8, -448605e-10, -9.86701e-7 ], [ .99, -.00135364, -59661e-9, 36777e-10 ], [ .9822, -.00167442, -449547e-11, -572411e-11 ], [ .973, -.00214868, -903571e-10, 1.8736e-8 ], [ .96, -.00305085, -900761e-10, 164917e-11 ], [ .9427, -.00382792, -653386e-10, -26154e-10 ], [ .9216, -.00467746, -10457e-8, 481243e-11 ], [ .8962, -.00536223, -323831e-10, -543432e-11 ], [ .8679, -.00609363, -113898e-9, 332484e-11 ], [ .835, -.00698325, -640253e-10, 9.34959e-7 ], [ .7986, -.00755338, -500009e-10, 9.35324e-7 ], [ .7597, -.00798324, -35971e-9, -227626e-11 ], [ .7186, -.00851367, -701149e-10, -86303e-10 ], [ .6732, -.00986209, -199569e-9, 191974e-10 ], [ .6213, -.010418, 883923e-10, 624051e-11 ], [ .5722, -.00906601, 182e-6, 624051e-11 ], [ .5322, -.00677797, 275608e-9, 624051e-11 ] ] );
                        var Y = to_float( [ [ -5.20417e-18, .0124, 1.21431e-18, -8.45284e-11 ], [ .062, .0124, -1.26793e-9, 4.22642e-10 ], [ .124, .0124, 5.07171e-9, -1.60604e-9 ], [ .186, .0123999, -1.90189e-8, 6.00152e-9 ], [ .248, .0124002, 7.10039e-8, -2.24e-8 ], [ .31, .0123992, -2.64997e-7, 8.35986e-8 ], [ .372, .0124029, 9.88983e-7, -3.11994e-7 ], [ .434, .0123893, -369093e-11, -4.35621e-7 ], [ .4958, .0123198, -102252e-10, -3.45523e-7 ], [ .5571, .0121916, -154081e-10, -5.82288e-7 ], [ .6176, .0119938, -241424e-10, -5.25327e-7 ], [ .6769, .011713, -320223e-10, -5.16405e-7 ], [ .7346, .0113541, -397684e-10, -6.09052e-7 ], [ .7903, .0109107, -489042e-10, -104739e-11 ], [ .8435, .0103431, -64615e-9, -1.40374e-9 ], [ .8936, .00969686, -64636e-9, -8547e-9 ], [ .9394, .00840947, -192841e-9, -42106e-10 ], [ .9761, .00616527, -256e-6, -42106e-10 ], [ 1, .00328947, -319159e-9, -42106e-10 ] ] );
                        var FXC = .8487,
                            FYC = 1.3523,
                            C1 = 11.459155902616464,
                            RC1 = .08726646259971647,
                            NODES = 18,
                            ONEEPS = 1.000001,
                            EPS = 1e-8;
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            var i, dphi;
                            i = floor( ( dphi = fabs( lp.phi ) ) * C1 );
                            if ( i >= NODES ) i = NODES - 1;
                            dphi = RAD_TO_DEG * ( dphi - RC1 * i );
                            xy.x = V( X[ i ], dphi ) * FXC * lp.lam;
                            xy.y = V( Y[ i ], dphi ) * FYC;
                            if ( lp.phi < 0 ) xy.y = -xy.y
                        }

                        function s_inv( xy, lp ) {
                            var t, t1, T, i;
                            lp.lam = xy.x / FXC;
                            lp.phi = fabs( xy.y / FYC );
                            if ( lp.phi >= 1 ) {
                                if ( lp.phi > ONEEPS ) i_error();
                                else {
                                    lp.phi = xy.y < 0 ? -M_HALFPI : M_HALFPI;
                                    lp.lam /= X[ NODES ][ 0 ]
                                }
                            } else {
                                for ( i = floor( lp.phi * NODES );; ) {
                                    if ( Y[ i ][ 0 ] > lp.phi ) --i;
                                    else if ( Y[ i + 1 ][ 0 ] <= lp.phi ) ++i;
                                    else break
                                }
                                T = new Float32Array( Y[ i ] );
                                t = 5 * ( lp.phi - T[ 0 ] ) / ( Y[ i + 1 ][ 0 ] - T[ 0 ] );
                                T[ 0 ] -= lp.phi;
                                for ( ;; ) {
                                    t -= t1 = V( T, t ) / DV( T, t );
                                    if ( fabs( t1 ) < EPS ) break
                                }
                                lp.phi = ( 5 * i + t ) * DEG_TO_RAD;
                                if ( xy.y < 0 ) lp.phi = -lp.phi;
                                lp.lam /= V( X[ i ], t )
                            }
                        }

                        function V( C, z ) {
                            return C[ 0 ] + z * ( C[ 1 ] + z * ( C[ 2 ] + z * C[ 3 ] ) )
                        }

                        function DV( C, z ) {
                            return C[ 1 ] + z * ( C[ 2 ] + C[ 2 ] + z * 3 * C[ 3 ] )
                        }

                        function to_float( rows ) {
                            return rows.map( function( row ) {
                                return new Float32Array( row )
                            } )
                        }
                    }
                    pj_add( pj_stere, "stere", "Stereographic", "\n\tAzi, Sph&Ell\n\tlat_ts=" );
                    pj_add( pj_ups, "ups", "Universal Polar Stereographic", "\n\tAzi, Sph&Ell\n\tsouth" );

                    function pj_ups( P ) {
                        P.phi0 = pj_param( P.params, "bsouth" ) ? -M_HALFPI : M_HALFPI;
                        P.k0 = .994;
                        P.x0 = 2e6;
                        P.y0 = 2e6;
                        P.lam0 = 0;
                        if ( !P.es ) e_error( -34 );
                        pj_stere_init( P, M_HALFPI )
                    }

                    function pj_stere( P ) {
                        var phits = pj_param( P.params, "tlat_ts" ) ? pj_param( P.params, "rlat_ts" ) : M_HALFPI;
                        pj_stere_init( P, phits )
                    }

                    function pj_stere_init( P, phits ) {
                        var EPS10 = 1e-10,
                            TOL = 1e-8,
                            NITER = 8,
                            CONV = 1e-10,
                            S_POLE = 0,
                            N_POLE = 1,
                            OBLIQ = 2,
                            EQUIT = 3;
                        var X, t, sinph0, cosph0;
                        var sinX1, cosX1, akm1, mode;
                        if ( fabs( ( t = fabs( P.phi0 ) ) - M_HALFPI ) < EPS10 ) mode = P.phi0 < 0 ? S_POLE : N_POLE;
                        else mode = t > EPS10 ? OBLIQ : EQUIT;
                        phits = fabs( phits );
                        if ( P.es ) {
                            switch ( mode ) {
                                case N_POLE:
                                case S_POLE:
                                    if ( fabs( phits - M_HALFPI ) < EPS10 ) akm1 = 2 * P.k0 / sqrt( pow( 1 + P.e, 1 + P.e ) * pow( 1 - P.e, 1 - P.e ) );
                                    else {
                                        akm1 = cos( phits ) / pj_tsfn( phits, t = sin( phits ), P.e );
                                        t *= P.e;
                                        akm1 /= sqrt( 1 - t * t )
                                    }
                                    break;
                                case EQUIT:
                                case OBLIQ:
                                    t = sin( P.phi0 );
                                    X = 2 * atan( ssfn( P.phi0, t, P.e ) ) - M_HALFPI;
                                    t *= P.e;
                                    akm1 = 2 * P.k0 * cos( P.phi0 ) / sqrt( 1 - t * t );
                                    sinX1 = sin( X );
                                    cosX1 = cos( X );
                                    break
                            }
                            P.fwd = e_fwd;
                            P.inv = e_inv
                        } else {
                            switch ( mode ) {
                                case OBLIQ:
                                    sinph0 = sin( P.phi0 );
                                    cosph0 = cos( P.phi0 );
                                case EQUIT:
                                    akm1 = 2 * P.k0;
                                    break;
                                case S_POLE:
                                case N_POLE:
                                    akm1 = fabs( phits - M_HALFPI ) >= EPS10 ? cos( phits ) / tan( M_FORTPI - .5 * phits ) : 2 * P.k0;
                                    break
                            }
                            P.fwd = s_fwd;
                            P.inv = s_inv
                        }

                        function e_fwd( lp, xy ) {
                            var coslam, sinlam, sinX = 0,
                                cosX = 0,
                                X, A, sinphi;
                            coslam = cos( lp.lam );
                            sinlam = sin( lp.lam );
                            sinphi = sin( lp.phi );
                            if ( mode == OBLIQ || mode == EQUIT ) {
                                sinX = sin( X = 2 * atan( ssfn( lp.phi, sinphi, P.e ) ) - M_HALFPI );
                                cosX = cos( X )
                            }
                            switch ( mode ) {
                                case OBLIQ:
                                    A = akm1 / ( cosX1 * ( 1 + sinX1 * sinX + cosX1 * cosX * coslam ) );
                                    xy.y = A * ( cosX1 * sinX - sinX1 * cosX * coslam );
                                    xy.x = A * cosX;
                                    break;
                                case EQUIT:
                                    A = 2 * akm1 / ( 1 + cosX * coslam );
                                    xy.y = A * sinX;
                                    xy.x = A * cosX;
                                    break;
                                case S_POLE:
                                    lp.phi = -lp.phi;
                                    coslam = -coslam;
                                    sinphi = -sinphi;
                                case N_POLE:
                                    xy.x = akm1 * pj_tsfn( lp.phi, sinphi, P.e );
                                    xy.y = -xy.x * coslam;
                                    break
                            }
                            xy.x = xy.x * sinlam
                        }

                        function s_fwd( lp, xy ) {
                            var phi = lp.phi,
                                sinphi = sin( phi ),
                                cosphi = cos( phi ),
                                coslam = cos( lp.lam ),
                                sinlam = sin( lp.lam );
                            switch ( mode ) {
                                case EQUIT:
                                case OBLIQ:
                                    if ( mode == EQUIT ) {
                                        xy.y = 1 + cosphi * coslam
                                    } else {
                                        xy.y = 1 + sinph0 * sinphi + cosph0 * cosphi * coslam
                                    }
                                    if ( xy.y <= EPS10 ) f_error();
                                    xy.x = ( xy.y = akm1 / xy.y ) * cosphi * sinlam;
                                    xy.y *= mode == EQUIT ? sinphi : cosph0 * sinphi - sinph0 * cosphi * coslam;
                                    break;
                                case N_POLE:
                                    coslam = -coslam;
                                    phi = -phi;
                                case S_POLE:
                                    if ( fabs( phi - M_HALFPI ) < TOL ) f_error();
                                    xy.x = sinlam * ( xy.y = akm1 * tan( M_FORTPI + .5 * phi ) );
                                    xy.y *= coslam;
                                    break
                            }
                        }

                        function e_inv( xy, lp ) {
                            var phi = lp.phi,
                                tp = 0,
                                phi_l = 0,
                                halfe = 0,
                                halfpi = 0,
                                cosphi, sinphi, rho, i;
                            rho = hypot( xy.x, xy.y );
                            switch ( mode ) {
                                case OBLIQ:
                                case EQUIT:
                                    cosphi = cos( tp = 2 * atan2( rho * cosX1, akm1 ) );
                                    sinphi = sin( tp );
                                    if ( rho == 0 ) phi_l = asin( cosphi * sinX1 );
                                    else phi_l = asin( cosphi * sinX1 + xy.y * sinphi * cosX1 / rho );
                                    tp = tan( .5 * ( M_HALFPI + phi_l ) );
                                    xy.x *= sinphi;
                                    xy.y = rho * cosX1 * cosphi - xy.y * sinX1 * sinphi;
                                    halfpi = M_HALFPI;
                                    halfe = .5 * P.e;
                                    break;
                                case N_POLE:
                                    xy.y = -xy.y;
                                case S_POLE:
                                    phi_l = M_HALFPI - 2 * atan( tp = -rho / akm1 );
                                    halfpi = -M_HALFPI;
                                    halfe = -.5 * P.e;
                                    break
                            }
                            for ( i = 0; i < NITER; i++, phi_l = lp.phi ) {
                                sinphi = P.e * sin( phi_l );
                                lp.phi = 2 * atan( tp * pow( ( 1 + sinphi ) / ( 1 - sinphi ), halfe ) ) - halfpi;
                                if ( fabs( phi_l - lp.phi ) < CONV ) {
                                    if ( mode == S_POLE ) lp.phi = -lp.phi;
                                    lp.lam = xy.x == 0 && xy.y == 0 ? 0 : atan2( xy.x, xy.y );
                                    return
                                }
                            }
                            i_error()
                        }

                        function s_inv( xy, lp ) {
                            var c, rh, sinc, cosc;
                            sinc = sin( c = 2 * atan( ( rh = hypot( xy.x, xy.y ) ) / akm1 ) );
                            cosc = cos( c );
                            lp.lam = 0;
                            switch ( mode ) {
                                case EQUIT:
                                    if ( fabs( rh ) <= EPS10 ) lp.phi = 0;
                                    else lp.phi = asin( xy.y * sinc / rh );
                                    if ( cosc != 0 || xy.x != 0 ) lp.lam = atan2( xy.x * sinc, cosc * rh );
                                    break;
                                case OBLIQ:
                                    if ( fabs( rh ) <= EPS10 ) lp.phi = P.phi0;
                                    else lp.phi = asin( cosc * sinph0 + xy.y * sinc * cosph0 / rh );
                                    if ( ( c = cosc - sinph0 * sin( lp.phi ) ) != 0 || xy.x != 0 ) lp.lam = atan2( xy.x * sinc * cosph0, c * rh );
                                    break;
                                case N_POLE:
                                    xy.y = -xy.y;
                                case S_POLE:
                                    if ( fabs( rh ) <= EPS10 ) lp.phi = P.phi0;
                                    else lp.phi = asin( mode == S_POLE ? -cosc : cosc );
                                    lp.lam = xy.x == 0 && xy.y == 0 ? 0 : atan2( xy.x, xy.y );
                                    break
                            }
                        }

                        function ssfn( phit, sinphi, eccen ) {
                            sinphi *= eccen;
                            return tan( .5 * ( M_HALFPI + phit ) ) * pow( ( 1 - sinphi ) / ( 1 + sinphi ), .5 * eccen )
                        }
                    }

                    function srat( esinp, exp ) {
                        return pow( ( 1 - esinp ) / ( 1 + esinp ), exp )
                    }

                    function pj_gauss_ini( e, phi0 ) {
                        var es = e * e,
                            sphi = sin( phi0 ),
                            cphi = cos( phi0 ),
                            rc = sqrt( 1 - es ) / ( 1 - es * sphi * sphi ),
                            C = sqrt( 1 + es * cphi * cphi * cphi * cphi / ( 1 - es ) ),
                            chi = asin( sphi / C ),
                            ratexp = .5 * C * e,
                            K = tan( .5 * chi + M_FORTPI ) / ( pow( tan( .5 * phi0 + M_FORTPI ), C ) * srat( e * sphi, ratexp ) );
                        return {
                            e: e,
                            K: K,
                            C: C,
                            chi: chi,
                            ratexp: ratexp,
                            rc: rc
                        }
                    }

                    function pj_gauss( elp, en ) {
                        return {
                            phi: 2 * atan( en.K * pow( tan( .5 * elp.phi + M_FORTPI ), en.C ) * srat( en.e * sin( elp.phi ), en.ratexp ) ) - M_HALFPI,
                            lam: en.C * elp.lam
                        }
                    }

                    function pj_inv_gauss( lp, en ) {
                        var MAX_ITER = 20,
                            DEL_TOL = 1e-14,
                            phi1 = lp.phi,
                            num = pow( tan( .5 * lp.phi + M_FORTPI ) / en.K, 1 / en.C ),
                            i, phi;
                        lp.lam /= en.C;
                        for ( i = MAX_ITER; i > 0; --i ) {
                            phi = 2 * atan( num * srat( en.e * sin( lp.phi ), -.5 * en.e ) ) - M_HALFPI;
                            if ( fabs( phi - lp.phi ) < DEL_TOL ) break;
                            lp.phi = phi
                        }
                        if ( !i ) pj_ctx_set_errno( -17 )
                    }
                    pj_add( pj_sterea, "sterea", "Oblique Stereographic Alternative", "\n\tAzimuthal, Sph&Ell" );

                    function pj_sterea( P ) {
                        var en = pj_gauss_ini( P.e, P.phi0 ),
                            phic0 = en.chi,
                            R = en.rc,
                            R2 = 2 * R,
                            sinc0 = sin( phic0 ),
                            cosc0 = cos( phic0 );
                        P.fwd = e_fwd;
                        P.inv = e_inv;

                        function e_fwd( lp, xy ) {
                            var cosc, sinc, cosl, k;
                            lp = pj_gauss( lp, en );
                            sinc = sin( lp.phi );
                            cosc = cos( lp.phi );
                            cosl = cos( lp.lam );
                            k = P.k0 * R2 / ( 1 + sinc0 * sinc + cosc0 * cosc * cosl );
                            xy.x = k * cosc * sin( lp.lam );
                            xy.y = k * ( cosc0 * sinc - sinc0 * cosc * cosl )
                        }

                        function e_inv( xy, lp ) {
                            var x = xy.x / P.k0,
                                y = xy.y / P.k0,
                                rho, c, sinc, cosc;
                            if ( rho = hypot( x, y ) ) {
                                c = 2 * atan2( rho, R2 );
                                sinc = sin( c );
                                cosc = cos( c );
                                lp.phi = asin( cosc * sinc0 + y * sinc * cosc0 / rho );
                                lp.lam = atan2( x * sinc, rho * cosc0 * cosc - y * sinc0 * sinc )
                            } else {
                                lp.phi = phic0;
                                lp.lam = 0
                            }
                            pj_inv_gauss( lp, en )
                        }
                    }
                    pj_add( pj_tcea, "tcea", "Transverse Cylindrical Equal Area", "\n\tCyl, Sph" );

                    function pj_tcea( P ) {
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            xy.x = cos( lp.phi ) * sin( lp.lam ) / P.k0;
                            xy.y = P.k0 * ( atan2( tan( lp.phi ), cos( lp.lam ) ) - P.phi0 )
                        }

                        function s_inv( xy, lp ) {
                            var t;
                            xy.y = xy.y / P.k0 + P.phi0;
                            xy.x *= P.k0;
                            t = sqrt( 1 - xy.x * xy.x );
                            lp.phi = asin( t * sin( xy.y ) );
                            lp.lam = atan2( xy.x, t * cos( xy.y ) )
                        }
                    }
                    pj_add( pj_times, "times", "Times", "\n\tCyl, Sph" );

                    function pj_times( P ) {
                        P.es = 0;
                        P.fwd = function( lp, xy ) {
                            var t = tan( lp.phi / 2 );
                            var s = sin( M_FORTPI * t );
                            xy.x = lp.lam * ( .74482 - .34588 * s * s );
                            xy.y = 1.70711 * t
                        };
                        P.inv = function( xy, lp ) {
                            var t = xy.y / 1.70711;
                            var s = sin( M_FORTPI * t );
                            lp.lam = xy.x / ( .74482 - .34588 * s * s );
                            lp.phi = 2 * atan( t )
                        }
                    }
                    pj_add( pj_tmerc, "tmerc", "Transverse Mercator", "\n\tCyl, Sph&Ell" );

                    function pj_tmerc( P ) {
                        var EPS10 = 1e-10,
                            FC1 = 1,
                            FC2 = .5,
                            FC3 = .16666666666666666,
                            FC4 = .08333333333333333,
                            FC5 = .05,
                            FC6 = .03333333333333333,
                            FC7 = .023809523809523808,
                            FC8 = .017857142857142856;
                        var esp, ml0, en;
                        if ( P.es ) {
                            if ( !( en = pj_enfn( P.es ) ) ) e_error_0();
                            ml0 = pj_mlfn( P.phi0, sin( P.phi0 ), cos( P.phi0 ), en );
                            esp = P.es / ( 1 - P.es );
                            P.fwd = e_fwd;
                            P.inv = e_inv
                        } else {
                            esp = P.k0;
                            ml0 = .5 * esp;
                            P.fwd = s_fwd;
                            P.inv = s_inv
                        }

                        function e_fwd( lp, xy ) {
                            var sinphi, cosphi, t, al, als, n;
                            if ( lp.lam < -M_HALFPI || lp.lam > M_HALFPI ) {
                                pj_ctx_set_errno( -14 );
                                return
                            }
                            sinphi = sin( lp.phi );
                            cosphi = cos( lp.phi );
                            t = fabs( cosphi ) > EPS10 ? sinphi / cosphi : 0;
                            t *= t;
                            al = cosphi * lp.lam;
                            als = al * al;
                            al /= sqrt( 1 - P.es * sinphi * sinphi );
                            n = esp * cosphi * cosphi;
                            xy.x = P.k0 * al * ( FC1 + FC3 * als * ( 1 - t + n + FC5 * als * ( 5 + t * ( t - 18 ) + n * ( 14 - 58 * t ) + FC7 * als * ( 61 + t * ( t * ( 179 - t ) - 479 ) ) ) ) );
                            xy.y = P.k0 * ( pj_mlfn( lp.phi, sinphi, cosphi, en ) - ml0 + sinphi * al * lp.lam * FC2 * ( 1 + FC4 * als * ( 5 - t + n * ( 9 + 4 * n ) + FC6 * als * ( 61 + t * ( t - 58 ) + n * ( 270 - 330 * t ) + FC8 * als * ( 1385 + t * ( t * ( 543 - t ) - 3111 ) ) ) ) ) )
                        }

                        function s_fwd( lp, xy ) {
                            var b, cosphi;
                            if ( lp.lam < -M_HALFPI || lp.lam > M_HALFPI ) {
                                pj_ctx_set_errno( -14 );
                                return
                            }
                            cosphi = cos( lp.phi );
                            b = cosphi * sin( lp.lam );
                            if ( fabs( fabs( b ) - 1 ) <= EPS10 ) f_error();
                            xy.x = ml0 * log( ( 1 + b ) / ( 1 - b ) );
                            xy.y = cosphi * cos( lp.lam ) / sqrt( 1 - b * b );
                            b = fabs( xy.y );
                            if ( b >= 1 ) {
                                if ( b - 1 > EPS10 ) {
                                    f_error()
                                } else {
                                    xy.y = 0
                                }
                            } else xy.y = acos( xy.y );
                            if ( lp.phi < 0 ) xy.y = -xy.y;
                            xy.y = esp * ( xy.y - P.phi0 )
                        }

                        function e_inv( xy, lp ) {
                            var n, con, cosphi, d, ds, sinphi, t;
                            lp.phi = pj_inv_mlfn( ml0 + xy.y / P.k0, P.es, en );
                            if ( fabs( lp.phi ) >= M_HALFPI ) {
                                lp.phi = xy.y < 0 ? -M_HALFPI : M_HALFPI;
                                lp.lam = 0
                            } else {
                                sinphi = sin( lp.phi );
                                cosphi = cos( lp.phi );
                                t = fabs( cosphi ) > 1e-10 ? sinphi / cosphi : 0;
                                n = esp * cosphi * cosphi;
                                d = xy.x * sqrt( con = 1 - P.es * sinphi * sinphi ) / P.k0;
                                con *= t;
                                t *= t;
                                ds = d * d;
                                lp.phi -= con * ds / ( 1 - P.es ) * FC2 * ( 1 - ds * FC4 * ( 5 + t * ( 3 - 9 * n ) + n * ( 1 - 4 * n ) - ds * FC6 * ( 61 + t * ( 90 - 252 * n + 45 * t ) + 46 * n - ds * FC8 * ( 1385 + t * ( 3633 + t * ( 4095 + 1574 * t ) ) ) ) ) );
                                lp.lam = d * ( FC1 - ds * FC3 * ( 1 + 2 * t + n - ds * FC5 * ( 5 + t * ( 28 + 24 * t + 8 * n ) + 6 * n - ds * FC7 * ( 61 + t * ( 662 + t * ( 1320 + 720 * t ) ) ) ) ) ) / cosphi
                            }
                        }

                        function s_inv( xy, lp ) {
                            var h = exp( xy.x / esp );
                            var g = .5 * ( h - 1 / h );
                            h = cos( P.phi0 + xy.y / esp );
                            lp.phi = asin( sqrt( ( 1 - h * h ) / ( 1 + g * g ) ) );
                            if ( xy.y < 0 ) lp.phi = -lp.phi;
                            lp.lam = g || h ? atan2( g, h ) : 0
                        }
                    }
                    pj_add( pj_tpeqd, "tpeqd", "Two Point Equidistant", "\n\tMisc Sph\n\tlat_1= lon_1= lat_2= lon_2=" );

                    function pj_tpeqd( P ) {
                        var cp1, sp1, cp2, sp2, ccs, cs, sc, r2z0, z02, dlam2;
                        var hz0, thz0, rhshz0, ca, sa, lamp, lamc;
                        var lam_1, lam_2, phi_1, phi_2, A12, pp;
                        phi_1 = pj_param( P.params, "rlat_1" );
                        lam_1 = pj_param( P.params, "rlon_1" );
                        phi_2 = pj_param( P.params, "rlat_2" );
                        lam_2 = pj_param( P.params, "rlon_2" );
                        if ( phi_1 == phi_2 && lam_1 == lam_2 ) e_error( -25 );
                        P.lam0 = adjlon( .5 * ( lam_1 + lam_2 ) );
                        dlam2 = adjlon( lam_2 - lam_1 );
                        cp1 = cos( phi_1 );
                        cp2 = cos( phi_2 );
                        sp1 = sin( phi_1 );
                        sp2 = sin( phi_2 );
                        cs = cp1 * sp2;
                        sc = sp1 * cp2;
                        ccs = cp1 * cp2 * sin( dlam2 );
                        z02 = aacos( sp1 * sp2 + cp1 * cp2 * cos( dlam2 ) );
                        hz0 = .5 * z02;
                        A12 = atan2( cp2 * sin( dlam2 ), cp1 * sp2 - sp1 * cp2 * cos( dlam2 ) );
                        ca = cos( pp = aasin( cp1 * sin( A12 ) ) );
                        sa = sin( pp );
                        lamp = adjlon( atan2( cp1 * cos( A12 ), sp1 ) - hz0 );
                        dlam2 *= .5;
                        lamc = M_HALFPI - atan2( sin( A12 ) * sp1, cos( A12 ) ) - dlam2;
                        thz0 = tan( hz0 );
                        rhshz0 = .5 / sin( hz0 );
                        r2z0 = .5 / z02;
                        z02 *= z02;
                        P.fwd = s_fwd;
                        P.inv = s_inv;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            var t, z1, z2, dl1, dl2, sp, cp;
                            sp = sin( lp.phi );
                            cp = cos( lp.phi );
                            z1 = aacos( sp1 * sp + cp1 * cp * cos( dl1 = lp.lam + dlam2 ) );
                            z2 = aacos( sp2 * sp + cp2 * cp * cos( dl2 = lp.lam - dlam2 ) );
                            z1 *= z1;
                            z2 *= z2;
                            xy.x = r2z0 * ( t = z1 - z2 );
                            t = z02 - t;
                            xy.y = r2z0 * asqrt( 4 * z02 * z2 - t * t );
                            if ( ccs * sp - cp * ( cs * sin( dl1 ) - sc * sin( dl2 ) ) < 0 ) xy.y = -xy.y
                        }

                        function s_inv( xy, lp ) {
                            var cz1, cz2, s, d, cp, sp;
                            cz1 = cos( hypot( xy.y, xy.x + hz0 ) );
                            cz2 = cos( hypot( xy.y, xy.x - hz0 ) );
                            s = cz1 + cz2;
                            d = cz1 - cz2;
                            lp.lam = -atan2( d, s * thz0 );
                            lp.phi = aacos( hypot( thz0 * s, d ) * rhshz0 );
                            if ( xy.y < 0 ) lp.phi = -lp.phi;
                            sp = sin( lp.phi );
                            cp = cos( lp.phi );
                            lp.phi = aasin( sa * sp + ca * cp * ( s = cos( lp.lam -= lamp ) ) );
                            lp.lam = atan2( cp * sin( lp.lam ), sa * cp * s - ca * sp ) + lamc
                        }
                    }
                    pj_add( pj_urmfps, "urmfps", "Urmaev Flat-Polar Sinusoidal", "\n\tPCyl, Sph.\n\tn=" );
                    pj_add( pj_wag1, "wag1", "Wagner I (Kavraisky VI)", "\n\tPCyl, Sph." );

                    function pj_wag1( P ) {
                        pj_urmfps_init( P, .8660254037844386 )
                    }

                    function pj_urmfps( P ) {
                        var n = pj_param( P.params, "dn" );
                        if ( n <= 0 || n > 1 ) e_error( -40 );
                        pj_urmfps_init( P, n )
                    }

                    function pj_urmfps_init( P, n ) {
                        var C_x = .8773826753,
                            C_y = 1.139753528477 / n;
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            var phi = aasin( n * sin( lp.phi ) );
                            xy.x = C_x * lp.lam * cos( phi );
                            xy.y = C_y * phi
                        }

                        function s_inv( xy, lp ) {
                            xy.y /= C_y;
                            lp.phi = aasin( sin( xy.y ) / n );
                            lp.lam = xy.x / ( C_x * cos( xy.y ) )
                        }
                    }
                    pj_add( pj_vandg, "vandg", "van der Grinten (I)", "\n\tMisc Sph" );
                    pj_add( pj_vandg2, "vandg2", "van der Grinten II", "\n\tMisc Sph, no inv." );
                    pj_add( pj_vandg3, "vandg3", "van der Grinten III", "\n\tMisc Sph, no inv." );
                    pj_add( pj_vandg4, "vandg4", "van der Grinten IV", "\n\tMisc Sph, no inv." );

                    function pj_vandg( P ) {
                        var TOL = 1e-10,
                            THIRD = .3333333333333333,
                            TWO_THRD = .6666666666666666,
                            C2_27 = .07407407407407407,
                            PI4_3 = 4.188790204786391,
                            PISQ = 9.869604401089358,
                            TPISQ = 19.739208802178716,
                            HPISQ = 4.934802200544679;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            var al, al2, g, g2, p2;
                            p2 = fabs( lp.phi / M_HALFPI );
                            if ( p2 - TOL > 1 ) f_error();
                            if ( p2 > 1 ) p2 = 1;
                            if ( fabs( lp.phi ) <= TOL ) {
                                xy.x = lp.lam;
                                xy.y = 0
                            } else if ( fabs( lp.lam ) <= TOL || fabs( p2 - 1 ) < TOL ) {
                                xy.x = 0;
                                xy.y = M_PI * tan( .5 * asin( p2 ) );
                                if ( lp.phi < 0 ) xy.y = -xy.y
                            } else {
                                al = .5 * fabs( M_PI / lp.lam - lp.lam / M_PI );
                                al2 = al * al;
                                g = sqrt( 1 - p2 * p2 );
                                g = g / ( p2 + g - 1 );
                                g2 = g * g;
                                p2 = g * ( 2 / p2 - 1 );
                                p2 = p2 * p2;
                                xy.x = g - p2;
                                g = p2 + al2;
                                xy.x = M_PI * ( al * xy.x + sqrt( al2 * xy.x * xy.x - g * ( g2 - p2 ) ) ) / g;
                                if ( lp.lam < 0 ) xy.x = -xy.x;
                                xy.y = fabs( xy.x / M_PI );
                                xy.y = 1 - xy.y * ( xy.y + 2 * al );
                                if ( xy.y < -TOL ) f_error();
                                if ( xy.y < 0 ) xy.y = 0;
                                else xy.y = sqrt( xy.y ) * ( lp.phi < 0 ? -M_PI : M_PI )
                            }
                        }

                        function s_inv( xy, lp ) {
                            var t, c0, c1, c2, c3, al, r2, r, m, d, ay, x2, y2;
                            x2 = xy.x * xy.x;
                            if ( ( ay = fabs( xy.y ) ) < TOL ) {
                                lp.phi = 0;
                                t = x2 * x2 + TPISQ * ( x2 + HPISQ );
                                lp.lam = fabs( xy.x ) <= TOL ? 0 : .5 * ( x2 - PISQ + sqrt( t ) ) / xy.x;
                                return lp
                            }
                            y2 = xy.y * xy.y;
                            r = x2 + y2;
                            r2 = r * r;
                            c1 = -M_PI * ay * ( r + PISQ );
                            c3 = r2 + M_TWOPI * ( ay * r + M_PI * ( y2 + M_PI * ( ay + M_HALFPI ) ) );
                            c2 = c1 + PISQ * ( r - 3 * y2 );
                            c0 = M_PI * ay;
                            c2 /= c3;
                            al = c1 / c3 - THIRD * c2 * c2;
                            m = 2 * sqrt( -THIRD * al );
                            d = C2_27 * c2 * c2 * c2 + ( c0 * c0 - THIRD * c2 * c1 ) / c3;
                            if ( ( t = fabs( d = 3 * d / ( al * m ) ) ) - TOL <= 1 ) {
                                d = t > 1 ? d > 0 ? 0 : M_PI : acos( d );
                                lp.phi = M_PI * ( m * cos( d * THIRD + PI4_3 ) - THIRD * c2 );
                                if ( xy.y < 0 ) lp.phi = -lp.phi;
                                t = r2 + TPISQ * ( x2 - y2 + HPISQ );
                                lp.lam = fabs( xy.x ) <= TOL ? 0 : .5 * ( r - PISQ + ( t <= 0 ? 0 : sqrt( t ) ) ) / xy.x
                            } else i_error()
                        }
                    }

                    function pj_vandg2( P ) {
                        pj_vandg2_init( P, false )
                    }

                    function pj_vandg3( P ) {
                        pj_vandg2_init( P, true )
                    }

                    function pj_vandg2_init( P, vdg3 ) {
                        var TOL = 1e-10;
                        P.fwd = s_fwd;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            var x1, at, bt, ct;
                            bt = fabs( M_TWO_D_PI * lp.phi );
                            if ( ( ct = 1 - bt * bt ) < 0 ) ct = 0;
                            else ct = sqrt( ct );
                            if ( fabs( lp.lam ) < TOL ) {
                                xy.x = 0;
                                xy.y = M_PI * ( lp.phi < 0 ? -bt : bt ) / ( 1 + ct )
                            } else {
                                at = .5 * fabs( M_PI / lp.lam - lp.lam / M_PI );
                                if ( vdg3 ) {
                                    x1 = bt / ( 1 + ct );
                                    xy.x = M_PI * ( sqrt( at * at + 1 - x1 * x1 ) - at );
                                    xy.y = M_PI * x1
                                } else {
                                    x1 = ( ct * sqrt( 1 + at * at ) - at * ct * ct ) / ( 1 + at * at * bt * bt );
                                    xy.x = M_PI * x1;
                                    xy.y = M_PI * sqrt( 1 - x1 * ( x1 + 2 * at ) + TOL )
                                }
                                if ( lp.lam < 0 ) xy.x = -xy.x;
                                if ( lp.phi < 0 ) xy.y = -xy.y
                            }
                        }
                    }

                    function pj_vandg4( P ) {
                        P.es = 0;
                        P.fwd = function( lp, xy ) {
                            var TOL = 1e-10;
                            var x1, t, bt, ct, ft, bt2, ct2, dt, dt2;
                            if ( fabs( lp.phi ) < TOL ) {
                                xy.x = lp.lam;
                                xy.y = 0
                            } else if ( fabs( lp.lam ) < TOL || fabs( fabs( lp.phi ) - M_HALFPI ) < TOL ) {
                                xy.x = 0;
                                xy.y = lp.phi
                            } else {
                                bt = fabs( M_TWO_D_PI * lp.phi );
                                bt2 = bt * bt;
                                ct = .5 * ( bt * ( 8 - bt * ( 2 + bt2 ) ) - 5 ) / ( bt2 * ( bt - 1 ) );
                                ct2 = ct * ct;
                                dt = M_TWO_D_PI * lp.lam;
                                dt = dt + 1 / dt;
                                dt = sqrt( dt * dt - 4 );
                                if ( fabs( lp.lam ) - M_HALFPI < 0 ) dt = -dt;
                                dt2 = dt * dt;
                                x1 = bt + ct;
                                x1 *= x1;
                                t = bt + 3 * ct;
                                ft = x1 * ( bt2 + ct2 * dt2 - 1 ) + ( 1 - bt2 ) * ( bt2 * ( t * t + 4 * ct2 ) + ct2 * ( 12 * bt * ct + 4 * ct2 ) );
                                x1 = ( dt * ( x1 + ct2 - 1 ) + 2 * sqrt( ft ) ) / ( 4 * x1 + dt2 );
                                xy.x = M_HALFPI * x1;
                                xy.y = M_HALFPI * sqrt( 1 + dt * fabs( x1 ) - x1 * x1 );
                                if ( lp.lam < 0 ) xy.x = -xy.x;
                                if ( lp.phi < 0 ) xy.y = -xy.y
                            }
                        }
                    }
                    pj_add( pj_wag2, "wag2", "Wagner II", "\n\tPCyl., Sph." );
                    pj_add( pj_wag3, "wag3", "Wagner III", "\n\tPCyl., Sph.\n\tlat_ts=" );
                    pj_add( pj_wag7, "wag7", "Wagner VII", "\n\tMisc Sph, no inv." );

                    function pj_wag2( P ) {
                        var C_x = .92483,
                            C_y = 1.38725,
                            C_p1 = .88022,
                            C_p2 = .8855;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            lp.phi = aasin( C_p1 * sin( C_p2 * lp.phi ) );
                            xy.x = C_x * lp.lam * cos( lp.phi );
                            xy.y = C_y * lp.phi
                        }

                        function s_inv( xy, lp ) {
                            lp.phi = xy.y / C_y;
                            lp.lam = xy.x / ( C_x * cos( lp.phi ) );
                            lp.phi = aasin( sin( lp.phi ) / C_p1 ) / C_p2
                        }
                    }

                    function pj_wag3( P ) {
                        var TWOTHIRD = .6666666666666666,
                            ts = pj_param( P.params, "rlat_ts" ),
                            C_x = cos( ts ) / cos( 2 * ts / 3 );
                        P.es = 0;
                        P.fwd = s_fwd;
                        P.inv = s_inv;

                        function s_fwd( lp, xy ) {
                            xy.x = C_x * lp.lam * cos( TWOTHIRD * lp.phi );
                            xy.y = lp.phi
                        }

                        function s_inv( xy, lp ) {
                            lp.phi = xy.y;
                            lp.lam = xy.x / ( C_x * cos( TWOTHIRD * lp.phi ) )
                        }
                    }

                    function pj_wag7( P ) {
                        P.es = 0;
                        P.fwd = function( lp, xy ) {
                            var theta, ct, D;
                            theta = asin( xy.y = .9063077870366499 * sin( lp.phi ) );
                            xy.x = 2.66723 * ( ct = cos( theta ) ) * sin( lp.lam /= 3 );
                            xy.y *= 1.24104 * ( D = 1 / sqrt( .5 * ( 1 + ct * cos( lp.lam ) ) ) );
                            xy.x *= D
                        }
                    }
                    pj_add( pj_wink1, "wink1", "Winkel I", "\n\tPCyl., Sph.\n\tlat_ts=" );
                    pj_add( pj_wink2, "wink2", "Winkel II", "\n\tPCyl., Sph., no inv.\n\tlat_1=" );

                    function pj_wink1( P ) {
                        var cosphi1 = cos( pj_param( P.params, "rlat_ts" ) );
                        P.fwd = s_fwd;
                        P.inv = s_inv;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            xy.x = .5 * lp.lam * ( cosphi1 + cos( lp.phi ) );
                            xy.y = lp.phi
                        }

                        function s_inv( xy, lp ) {
                            lp.phi = xy.y;
                            lp.lam = 2 * xy.x / ( cosphi1 + cos( lp.phi ) )
                        }
                    }

                    function pj_wink2( P ) {
                        var cosphi1 = cos( pj_param( P.params, "rlat_1" ) );
                        var MAX_ITER = 10,
                            LOOP_TOL = 1e-7;
                        P.fwd = s_fwd;
                        P.inv = null;
                        P.es = 0;

                        function s_fwd( lp, xy ) {
                            var k, V, i, phi = lp.phi;
                            xy.y = phi * M_TWO_D_PI;
                            k = M_PI * sin( phi );
                            phi *= 1.8;
                            for ( i = MAX_ITER; i; --i ) {
                                phi -= V = ( phi + sin( phi ) - k ) / ( 1 + cos( phi ) );
                                if ( fabs( V ) < LOOP_TOL ) break
                            }
                            if ( !i ) phi = phi < 0 ? -M_HALFPI : M_HALFPI;
                            else phi *= .5;
                            xy.x = .5 * lp.lam * ( cos( phi ) + cosphi1 );
                            xy.y = M_FORTPI * ( sin( phi ) + xy.y )
                        }
                    }
                    var api = proj4js;
                    api.pj_init = pj_init;
                    api.pj_fwd = pj_fwd;
                    api.pj_fwd_deg = pj_fwd_deg;
                    api.pj_inv = pj_inv;
                    api.pj_inv_deg = pj_inv_deg;
                    api.pj_transform = pj_transform;
                    api.pj_transform_point = pj_transform_point;
                    api.internal = {
                        dmstod: dmstod,
                        dmstor: dmstor,
                        get_rtodms: get_rtodms,
                        get_dtodms: get_dtodms,
                        get_proj_defn: get_proj_defn,
                        pj_latlong_from_proj: pj_latlong_from_proj,
                        pj_get_params: pj_get_params,
                        pj_datums: pj_datums,
                        pj_list: pj_list,
                        pj_ellps: pj_ellps,
                        pj_units: pj_units,
                        pj_read_opts: pj_read_opts,
                        find_datum: find_datum,
                        DEG_TO_RAD: DEG_TO_RAD,
                        RAD_TO_DEG: RAD_TO_DEG,
                        wkt_parse: wkt_parse,
                        wkt_to_proj4: wkt_to_proj4
                    };
                    if ( typeof define == "function" && define.amd ) {
                        define( "mproj", api )
                    } else if ( typeof exports == "object" ) {
                        module.exports = api
                    } else {
                        this.mproj = api
                    }
                } )()
            } ).call( this, "/node_modules/mproj/dist" )
        }, {
            fs: 3,
            path: 36
        } ],
        36: [ function( require, module, exports ) {
            ( function( process ) {
                function normalizeArray( parts, allowAboveRoot ) {
                    var up = 0;
                    for ( var i = parts.length - 1; i >= 0; i-- ) {
                        var last = parts[ i ];
                        if ( last === "." ) {
                            parts.splice( i, 1 )
                        } else if ( last === ".." ) {
                            parts.splice( i, 1 );
                            up++
                        } else if ( up ) {
                            parts.splice( i, 1 );
                            up--
                        }
                    }
                    if ( allowAboveRoot ) {
                        for ( ; up--; up ) {
                            parts.unshift( ".." )
                        }
                    }
                    return parts
                }
                var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
                var splitPath = function( filename ) {
                    return splitPathRe.exec( filename ).slice( 1 )
                };
                exports.resolve = function() {
                    var resolvedPath = "",
                        resolvedAbsolute = false;
                    for ( var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i-- ) {
                        var path = i >= 0 ? arguments[ i ] : process.cwd();
                        if ( typeof path !== "string" ) {
                            throw new TypeError( "Arguments to path.resolve must be strings" )
                        } else if ( !path ) {
                            continue
                        }
                        resolvedPath = path + "/" + resolvedPath;
                        resolvedAbsolute = path.charAt( 0 ) === "/"
                    }
                    resolvedPath = normalizeArray( filter( resolvedPath.split( "/" ), function( p ) {
                        return !!p
                    } ), !resolvedAbsolute ).join( "/" );
                    return ( resolvedAbsolute ? "/" : "" ) + resolvedPath || "."
                };
                exports.normalize = function( path ) {
                    var isAbsolute = exports.isAbsolute( path ),
                        trailingSlash = substr( path, -1 ) === "/";
                    path = normalizeArray( filter( path.split( "/" ), function( p ) {
                        return !!p
                    } ), !isAbsolute ).join( "/" );
                    if ( !path && !isAbsolute ) {
                        path = "."
                    }
                    if ( path && trailingSlash ) {
                        path += "/"
                    }
                    return ( isAbsolute ? "/" : "" ) + path
                };
                exports.isAbsolute = function( path ) {
                    return path.charAt( 0 ) === "/"
                };
                exports.join = function() {
                    var paths = Array.prototype.slice.call( arguments, 0 );
                    return exports.normalize( filter( paths, function( p, index ) {
                        if ( typeof p !== "string" ) {
                            throw new TypeError( "Arguments to path.join must be strings" )
                        }
                        return p
                    } ).join( "/" ) )
                };
                exports.relative = function( from, to ) {
                    from = exports.resolve( from ).substr( 1 );
                    to = exports.resolve( to ).substr( 1 );

                    function trim( arr ) {
                        var start = 0;
                        for ( ; start < arr.length; start++ ) {
                            if ( arr[ start ] !== "" ) break
                        }
                        var end = arr.length - 1;
                        for ( ; end >= 0; end-- ) {
                            if ( arr[ end ] !== "" ) break
                        }
                        if ( start > end ) return [];
                        return arr.slice( start, end - start + 1 )
                    }
                    var fromParts = trim( from.split( "/" ) );
                    var toParts = trim( to.split( "/" ) );
                    var length = Math.min( fromParts.length, toParts.length );
                    var samePartsLength = length;
                    for ( var i = 0; i < length; i++ ) {
                        if ( fromParts[ i ] !== toParts[ i ] ) {
                            samePartsLength = i;
                            break
                        }
                    }
                    var outputParts = [];
                    for ( var i = samePartsLength; i < fromParts.length; i++ ) {
                        outputParts.push( ".." )
                    }
                    outputParts = outputParts.concat( toParts.slice( samePartsLength ) );
                    return outputParts.join( "/" )
                };
                exports.sep = "/";
                exports.delimiter = ":";
                exports.dirname = function( path ) {
                    var result = splitPath( path ),
                        root = result[ 0 ],
                        dir = result[ 1 ];
                    if ( !root && !dir ) {
                        return "."
                    }
                    if ( dir ) {
                        dir = dir.substr( 0, dir.length - 1 )
                    }
                    return root + dir
                };
                exports.basename = function( path, ext ) {
                    var f = splitPath( path )[ 2 ];
                    if ( ext && f.substr( -1 * ext.length ) === ext ) {
                        f = f.substr( 0, f.length - ext.length )
                    }
                    return f
                };
                exports.extname = function( path ) {
                    return splitPath( path )[ 3 ]
                };

                function filter( xs, f ) {
                    if ( xs.filter ) return xs.filter( f );
                    var res = [];
                    for ( var i = 0; i < xs.length; i++ ) {
                        if ( f( xs[ i ], i, xs ) ) res.push( xs[ i ] )
                    }
                    return res
                }
                var substr = "ab".substr( -1 ) === "b" ? function( str, start, len ) {
                    return str.substr( start, len )
                } : function( str, start, len ) {
                    if ( start < 0 ) start = str.length + start;
                    return str.substr( start, len )
                }
            } ).call( this, require( "_process" ) )
        }, {
            _process: 38
        } ],
        37: [ function( require, module, exports ) {
            ( function( process ) {
                "use strict";
                if ( !process.version || process.version.indexOf( "v0." ) === 0 || process.version.indexOf( "v1." ) === 0 && process.version.indexOf( "v1.8." ) !== 0 ) {
                    module.exports = {
                        nextTick: nextTick
                    }
                } else {
                    module.exports = process
                }

                function nextTick( fn, arg1, arg2, arg3 ) {
                    if ( typeof fn !== "function" ) {
                        throw new TypeError( '"callback" argument must be a function' )
                    }
                    var len = arguments.length;
                    var args, i;
                    switch ( len ) {
                        case 0:
                        case 1:
                            return process.nextTick( fn );
                        case 2:
                            return process.nextTick( function afterTickOne() {
                                fn.call( null, arg1 )
                            } );
                        case 3:
                            return process.nextTick( function afterTickTwo() {
                                fn.call( null, arg1, arg2 )
                            } );
                        case 4:
                            return process.nextTick( function afterTickThree() {
                                fn.call( null, arg1, arg2, arg3 )
                            } );
                        default:
                            args = new Array( len - 1 );
                            i = 0;
                            while ( i < args.length ) {
                                args[ i++ ] = arguments[ i ]
                            }
                            return process.nextTick( function afterTick() {
                                fn.apply( null, args )
                            } )
                    }
                }
            } ).call( this, require( "_process" ) )
        }, {
            _process: 38
        } ],
        38: [ function( require, module, exports ) {
            var process = module.exports = {};
            var cachedSetTimeout;
            var cachedClearTimeout;

            function defaultSetTimout() {
                throw new Error( "setTimeout has not been defined" )
            }

            function defaultClearTimeout() {
                throw new Error( "clearTimeout has not been defined" )
            }( function() {
                try {
                    if ( typeof setTimeout === "function" ) {
                        cachedSetTimeout = setTimeout
                    } else {
                        cachedSetTimeout = defaultSetTimout
                    }
                } catch ( e ) {
                    cachedSetTimeout = defaultSetTimout
                }
                try {
                    if ( typeof clearTimeout === "function" ) {
                        cachedClearTimeout = clearTimeout
                    } else {
                        cachedClearTimeout = defaultClearTimeout
                    }
                } catch ( e ) {
                    cachedClearTimeout = defaultClearTimeout
                }
            } )();

            function runTimeout( fun ) {
                if ( cachedSetTimeout === setTimeout ) {
                    return setTimeout( fun, 0 )
                }
                if ( ( cachedSetTimeout === defaultSetTimout || !cachedSetTimeout ) && setTimeout ) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout( fun, 0 )
                }
                try {
                    return cachedSetTimeout( fun, 0 )
                } catch ( e ) {
                    try {
                        return cachedSetTimeout.call( null, fun, 0 )
                    } catch ( e ) {
                        return cachedSetTimeout.call( this, fun, 0 )
                    }
                }
            }

            function runClearTimeout( marker ) {
                if ( cachedClearTimeout === clearTimeout ) {
                    return clearTimeout( marker )
                }
                if ( ( cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout ) && clearTimeout ) {
                    cachedClearTimeout = clearTimeout;
                    return clearTimeout( marker )
                }
                try {
                    return cachedClearTimeout( marker )
                } catch ( e ) {
                    try {
                        return cachedClearTimeout.call( null, marker )
                    } catch ( e ) {
                        return cachedClearTimeout.call( this, marker )
                    }
                }
            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;

            function cleanUpNextTick() {
                if ( !draining || !currentQueue ) {
                    return
                }
                draining = false;
                if ( currentQueue.length ) {
                    queue = currentQueue.concat( queue )
                } else {
                    queueIndex = -1
                }
                if ( queue.length ) {
                    drainQueue()
                }
            }

            function drainQueue() {
                if ( draining ) {
                    return
                }
                var timeout = runTimeout( cleanUpNextTick );
                draining = true;
                var len = queue.length;
                while ( len ) {
                    currentQueue = queue;
                    queue = [];
                    while ( ++queueIndex < len ) {
                        if ( currentQueue ) {
                            currentQueue[ queueIndex ].run()
                        }
                    }
                    queueIndex = -1;
                    len = queue.length
                }
                currentQueue = null;
                draining = false;
                runClearTimeout( timeout )
            }
            process.nextTick = function( fun ) {
                var args = new Array( arguments.length - 1 );
                if ( arguments.length > 1 ) {
                    for ( var i = 1; i < arguments.length; i++ ) {
                        args[ i - 1 ] = arguments[ i ]
                    }
                }
                queue.push( new Item( fun, args ) );
                if ( queue.length === 1 && !draining ) {
                    runTimeout( drainQueue )
                }
            };

            function Item( fun, array ) {
                this.fun = fun;
                this.array = array
            }
            Item.prototype.run = function() {
                this.fun.apply( null, this.array )
            };
            process.title = "browser";
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = "";
            process.versions = {};

            function noop() {}
            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            process.prependListener = noop;
            process.prependOnceListener = noop;
            process.listeners = function( name ) {
                return []
            };
            process.binding = function( name ) {
                throw new Error( "process.binding is not supported" )
            };
            process.cwd = function() {
                return "/"
            };
            process.chdir = function( dir ) {
                throw new Error( "process.chdir is not supported" )
            };
            process.umask = function() {
                return 0
            }
        }, {} ],
        39: [ function( require, module, exports ) {
            module.exports = require( "./lib/_stream_duplex.js" )
        }, {
            "./lib/_stream_duplex.js": 40
        } ],
        40: [ function( require, module, exports ) {
            "use strict";
            var pna = require( "process-nextick-args" );
            var objectKeys = Object.keys || function( obj ) {
                var keys = [];
                for ( var key in obj ) {
                    keys.push( key )
                }
                return keys
            };
            module.exports = Duplex;
            var util = require( "core-util-is" );
            util.inherits = require( "inherits" );
            var Readable = require( "./_stream_readable" );
            var Writable = require( "./_stream_writable" );
            util.inherits( Duplex, Readable );
            var keys = objectKeys( Writable.prototype );
            for ( var v = 0; v < keys.length; v++ ) {
                var method = keys[ v ];
                if ( !Duplex.prototype[ method ] ) Duplex.prototype[ method ] = Writable.prototype[ method ]
            }

            function Duplex( options ) {
                if ( !( this instanceof Duplex ) ) return new Duplex( options );
                Readable.call( this, options );
                Writable.call( this, options );
                if ( options && options.readable === false ) this.readable = false;
                if ( options && options.writable === false ) this.writable = false;
                this.allowHalfOpen = true;
                if ( options && options.allowHalfOpen === false ) this.allowHalfOpen = false;
                this.once( "end", onend )
            }

            function onend() {
                if ( this.allowHalfOpen || this._writableState.ended ) return;
                pna.nextTick( onEndNT, this )
            }

            function onEndNT( self ) {
                self.end()
            }
            Object.defineProperty( Duplex.prototype, "destroyed", {
                get: function() {
                    if ( this._readableState === undefined || this._writableState === undefined ) {
                        return false
                    }
                    return this._readableState.destroyed && this._writableState.destroyed
                },
                set: function( value ) {
                    if ( this._readableState === undefined || this._writableState === undefined ) {
                        return
                    }
                    this._readableState.destroyed = value;
                    this._writableState.destroyed = value
                }
            } );
            Duplex.prototype._destroy = function( err, cb ) {
                this.push( null );
                this.end();
                pna.nextTick( cb, err )
            };

            function forEach( xs, f ) {
                for ( var i = 0, l = xs.length; i < l; i++ ) {
                    f( xs[ i ], i )
                }
            }
        }, {
            "./_stream_readable": 42,
            "./_stream_writable": 44,
            "core-util-is": 5,
            inherits: 30,
            "process-nextick-args": 37
        } ],
        41: [ function( require, module, exports ) {
            "use strict";
            module.exports = PassThrough;
            var Transform = require( "./_stream_transform" );
            var util = require( "core-util-is" );
            util.inherits = require( "inherits" );
            util.inherits( PassThrough, Transform );

            function PassThrough( options ) {
                if ( !( this instanceof PassThrough ) ) return new PassThrough( options );
                Transform.call( this, options )
            }
            PassThrough.prototype._transform = function( chunk, encoding, cb ) {
                cb( null, chunk )
            }
        }, {
            "./_stream_transform": 43,
            "core-util-is": 5,
            inherits: 30
        } ],
        42: [ function( require, module, exports ) {
            ( function( process, global ) {
                "use strict";
                var pna = require( "process-nextick-args" );
                module.exports = Readable;
                var isArray = require( "isarray" );
                var Duplex;
                Readable.ReadableState = ReadableState;
                var EE = require( "events" ).EventEmitter;
                var EElistenerCount = function( emitter, type ) {
                    return emitter.listeners( type ).length
                };
                var Stream = require( "./internal/streams/stream" );
                var Buffer = require( "safe-buffer" ).Buffer;
                var OurUint8Array = global.Uint8Array || function() {};

                function _uint8ArrayToBuffer( chunk ) {
                    return Buffer.from( chunk )
                }

                function _isUint8Array( obj ) {
                    return Buffer.isBuffer( obj ) || obj instanceof OurUint8Array
                }
                var util = require( "core-util-is" );
                util.inherits = require( "inherits" );
                var debugUtil = require( "util" );
                var debug = void 0;
                if ( debugUtil && debugUtil.debuglog ) {
                    debug = debugUtil.debuglog( "stream" )
                } else {
                    debug = function() {}
                }
                var BufferList = require( "./internal/streams/BufferList" );
                var destroyImpl = require( "./internal/streams/destroy" );
                var StringDecoder;
                util.inherits( Readable, Stream );
                var kProxyEvents = [ "error", "close", "destroy", "pause", "resume" ];

                function prependListener( emitter, event, fn ) {
                    if ( typeof emitter.prependListener === "function" ) return emitter.prependListener( event, fn );
                    if ( !emitter._events || !emitter._events[ event ] ) emitter.on( event, fn );
                    else if ( isArray( emitter._events[ event ] ) ) emitter._events[ event ].unshift( fn );
                    else emitter._events[ event ] = [ fn, emitter._events[ event ] ]
                }

                function ReadableState( options, stream ) {
                    Duplex = Duplex || require( "./_stream_duplex" );
                    options = options || {};
                    var isDuplex = stream instanceof Duplex;
                    this.objectMode = !!options.objectMode;
                    if ( isDuplex ) this.objectMode = this.objectMode || !!options.readableObjectMode;
                    var hwm = options.highWaterMark;
                    var readableHwm = options.readableHighWaterMark;
                    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
                    if ( hwm || hwm === 0 ) this.highWaterMark = hwm;
                    else if ( isDuplex && ( readableHwm || readableHwm === 0 ) ) this.highWaterMark = readableHwm;
                    else this.highWaterMark = defaultHwm;
                    this.highWaterMark = Math.floor( this.highWaterMark );
                    this.buffer = new BufferList;
                    this.length = 0;
                    this.pipes = null;
                    this.pipesCount = 0;
                    this.flowing = null;
                    this.ended = false;
                    this.endEmitted = false;
                    this.reading = false;
                    this.sync = true;
                    this.needReadable = false;
                    this.emittedReadable = false;
                    this.readableListening = false;
                    this.resumeScheduled = false;
                    this.destroyed = false;
                    this.defaultEncoding = options.defaultEncoding || "utf8";
                    this.awaitDrain = 0;
                    this.readingMore = false;
                    this.decoder = null;
                    this.encoding = null;
                    if ( options.encoding ) {
                        if ( !StringDecoder ) StringDecoder = require( "string_decoder/" ).StringDecoder;
                        this.decoder = new StringDecoder( options.encoding );
                        this.encoding = options.encoding
                    }
                }

                function Readable( options ) {
                    Duplex = Duplex || require( "./_stream_duplex" );
                    if ( !( this instanceof Readable ) ) return new Readable( options );
                    this._readableState = new ReadableState( options, this );
                    this.readable = true;
                    if ( options ) {
                        if ( typeof options.read === "function" ) this._read = options.read;
                        if ( typeof options.destroy === "function" ) this._destroy = options.destroy
                    }
                    Stream.call( this )
                }
                Object.defineProperty( Readable.prototype, "destroyed", {
                    get: function() {
                        if ( this._readableState === undefined ) {
                            return false
                        }
                        return this._readableState.destroyed
                    },
                    set: function( value ) {
                        if ( !this._readableState ) {
                            return
                        }
                        this._readableState.destroyed = value
                    }
                } );
                Readable.prototype.destroy = destroyImpl.destroy;
                Readable.prototype._undestroy = destroyImpl.undestroy;
                Readable.prototype._destroy = function( err, cb ) {
                    this.push( null );
                    cb( err )
                };
                Readable.prototype.push = function( chunk, encoding ) {
                    var state = this._readableState;
                    var skipChunkCheck;
                    if ( !state.objectMode ) {
                        if ( typeof chunk === "string" ) {
                            encoding = encoding || state.defaultEncoding;
                            if ( encoding !== state.encoding ) {
                                chunk = Buffer.from( chunk, encoding );
                                encoding = ""
                            }
                            skipChunkCheck = true
                        }
                    } else {
                        skipChunkCheck = true
                    }
                    return readableAddChunk( this, chunk, encoding, false, skipChunkCheck )
                };
                Readable.prototype.unshift = function( chunk ) {
                    return readableAddChunk( this, chunk, null, true, false )
                };

                function readableAddChunk( stream, chunk, encoding, addToFront, skipChunkCheck ) {
                    var state = stream._readableState;
                    if ( chunk === null ) {
                        state.reading = false;
                        onEofChunk( stream, state )
                    } else {
                        var er;
                        if ( !skipChunkCheck ) er = chunkInvalid( state, chunk );
                        if ( er ) {
                            stream.emit( "error", er )
                        } else if ( state.objectMode || chunk && chunk.length > 0 ) {
                            if ( typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf( chunk ) !== Buffer.prototype ) {
                                chunk = _uint8ArrayToBuffer( chunk )
                            }
                            if ( addToFront ) {
                                if ( state.endEmitted ) stream.emit( "error", new Error( "stream.unshift() after end event" ) );
                                else addChunk( stream, state, chunk, true )
                            } else if ( state.ended ) {
                                stream.emit( "error", new Error( "stream.push() after EOF" ) )
                            } else {
                                state.reading = false;
                                if ( state.decoder && !encoding ) {
                                    chunk = state.decoder.write( chunk );
                                    if ( state.objectMode || chunk.length !== 0 ) addChunk( stream, state, chunk, false );
                                    else maybeReadMore( stream, state )
                                } else {
                                    addChunk( stream, state, chunk, false )
                                }
                            }
                        } else if ( !addToFront ) {
                            state.reading = false
                        }
                    }
                    return needMoreData( state )
                }

                function addChunk( stream, state, chunk, addToFront ) {
                    if ( state.flowing && state.length === 0 && !state.sync ) {
                        stream.emit( "data", chunk );
                        stream.read( 0 )
                    } else {
                        state.length += state.objectMode ? 1 : chunk.length;
                        if ( addToFront ) state.buffer.unshift( chunk );
                        else state.buffer.push( chunk );
                        if ( state.needReadable ) emitReadable( stream )
                    }
                    maybeReadMore( stream, state )
                }

                function chunkInvalid( state, chunk ) {
                    var er;
                    if ( !_isUint8Array( chunk ) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode ) {
                        er = new TypeError( "Invalid non-string/buffer chunk" )
                    }
                    return er
                }

                function needMoreData( state ) {
                    return !state.ended && ( state.needReadable || state.length < state.highWaterMark || state.length === 0 )
                }
                Readable.prototype.isPaused = function() {
                    return this._readableState.flowing === false
                };
                Readable.prototype.setEncoding = function( enc ) {
                    if ( !StringDecoder ) StringDecoder = require( "string_decoder/" ).StringDecoder;
                    this._readableState.decoder = new StringDecoder( enc );
                    this._readableState.encoding = enc;
                    return this
                };
                var MAX_HWM = 8388608;

                function computeNewHighWaterMark( n ) {
                    if ( n >= MAX_HWM ) {
                        n = MAX_HWM
                    } else {
                        n--;
                        n |= n >>> 1;
                        n |= n >>> 2;
                        n |= n >>> 4;
                        n |= n >>> 8;
                        n |= n >>> 16;
                        n++
                    }
                    return n
                }

                function howMuchToRead( n, state ) {
                    if ( n <= 0 || state.length === 0 && state.ended ) return 0;
                    if ( state.objectMode ) return 1;
                    if ( n !== n ) {
                        if ( state.flowing && state.length ) return state.buffer.head.data.length;
                        else return state.length
                    }
                    if ( n > state.highWaterMark ) state.highWaterMark = computeNewHighWaterMark( n );
                    if ( n <= state.length ) return n;
                    if ( !state.ended ) {
                        state.needReadable = true;
                        return 0
                    }
                    return state.length
                }
                Readable.prototype.read = function( n ) {
                    debug( "read", n );
                    n = parseInt( n, 10 );
                    var state = this._readableState;
                    var nOrig = n;
                    if ( n !== 0 ) state.emittedReadable = false;
                    if ( n === 0 && state.needReadable && ( state.length >= state.highWaterMark || state.ended ) ) {
                        debug( "read: emitReadable", state.length, state.ended );
                        if ( state.length === 0 && state.ended ) endReadable( this );
                        else emitReadable( this );
                        return null
                    }
                    n = howMuchToRead( n, state );
                    if ( n === 0 && state.ended ) {
                        if ( state.length === 0 ) endReadable( this );
                        return null
                    }
                    var doRead = state.needReadable;
                    debug( "need readable", doRead );
                    if ( state.length === 0 || state.length - n < state.highWaterMark ) {
                        doRead = true;
                        debug( "length less than watermark", doRead )
                    }
                    if ( state.ended || state.reading ) {
                        doRead = false;
                        debug( "reading or ended", doRead )
                    } else if ( doRead ) {
                        debug( "do read" );
                        state.reading = true;
                        state.sync = true;
                        if ( state.length === 0 ) state.needReadable = true;
                        this._read( state.highWaterMark );
                        state.sync = false;
                        if ( !state.reading ) n = howMuchToRead( nOrig, state )
                    }
                    var ret;
                    if ( n > 0 ) ret = fromList( n, state );
                    else ret = null;
                    if ( ret === null ) {
                        state.needReadable = true;
                        n = 0
                    } else {
                        state.length -= n
                    }
                    if ( state.length === 0 ) {
                        if ( !state.ended ) state.needReadable = true;
                        if ( nOrig !== n && state.ended ) endReadable( this )
                    }
                    if ( ret !== null ) this.emit( "data", ret );
                    return ret
                };

                function onEofChunk( stream, state ) {
                    if ( state.ended ) return;
                    if ( state.decoder ) {
                        var chunk = state.decoder.end();
                        if ( chunk && chunk.length ) {
                            state.buffer.push( chunk );
                            state.length += state.objectMode ? 1 : chunk.length
                        }
                    }
                    state.ended = true;
                    emitReadable( stream )
                }

                function emitReadable( stream ) {
                    var state = stream._readableState;
                    state.needReadable = false;
                    if ( !state.emittedReadable ) {
                        debug( "emitReadable", state.flowing );
                        state.emittedReadable = true;
                        if ( state.sync ) pna.nextTick( emitReadable_, stream );
                        else emitReadable_( stream )
                    }
                }

                function emitReadable_( stream ) {
                    debug( "emit readable" );
                    stream.emit( "readable" );
                    flow( stream )
                }

                function maybeReadMore( stream, state ) {
                    if ( !state.readingMore ) {
                        state.readingMore = true;
                        pna.nextTick( maybeReadMore_, stream, state )
                    }
                }

                function maybeReadMore_( stream, state ) {
                    var len = state.length;
                    while ( !state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark ) {
                        debug( "maybeReadMore read 0" );
                        stream.read( 0 );
                        if ( len === state.length ) break;
                        else len = state.length
                    }
                    state.readingMore = false
                }
                Readable.prototype._read = function( n ) {
                    this.emit( "error", new Error( "_read() is not implemented" ) )
                };
                Readable.prototype.pipe = function( dest, pipeOpts ) {
                    var src = this;
                    var state = this._readableState;
                    switch ( state.pipesCount ) {
                        case 0:
                            state.pipes = dest;
                            break;
                        case 1:
                            state.pipes = [ state.pipes, dest ];
                            break;
                        default:
                            state.pipes.push( dest );
                            break
                    }
                    state.pipesCount += 1;
                    debug( "pipe count=%d opts=%j", state.pipesCount, pipeOpts );
                    var doEnd = ( !pipeOpts || pipeOpts.end !== false ) && dest !== process.stdout && dest !== process.stderr;
                    var endFn = doEnd ? onend : unpipe;
                    if ( state.endEmitted ) pna.nextTick( endFn );
                    else src.once( "end", endFn );
                    dest.on( "unpipe", onunpipe );

                    function onunpipe( readable, unpipeInfo ) {
                        debug( "onunpipe" );
                        if ( readable === src ) {
                            if ( unpipeInfo && unpipeInfo.hasUnpiped === false ) {
                                unpipeInfo.hasUnpiped = true;
                                cleanup()
                            }
                        }
                    }

                    function onend() {
                        debug( "onend" );
                        dest.end()
                    }
                    var ondrain = pipeOnDrain( src );
                    dest.on( "drain", ondrain );
                    var cleanedUp = false;

                    function cleanup() {
                        debug( "cleanup" );
                        dest.removeListener( "close", onclose );
                        dest.removeListener( "finish", onfinish );
                        dest.removeListener( "drain", ondrain );
                        dest.removeListener( "error", onerror );
                        dest.removeListener( "unpipe", onunpipe );
                        src.removeListener( "end", onend );
                        src.removeListener( "end", unpipe );
                        src.removeListener( "data", ondata );
                        cleanedUp = true;
                        if ( state.awaitDrain && ( !dest._writableState || dest._writableState.needDrain ) ) ondrain()
                    }
                    var increasedAwaitDrain = false;
                    src.on( "data", ondata );

                    function ondata( chunk ) {
                        debug( "ondata" );
                        increasedAwaitDrain = false;
                        var ret = dest.write( chunk );
                        if ( false === ret && !increasedAwaitDrain ) {
                            if ( ( state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf( state.pipes, dest ) !== -1 ) && !cleanedUp ) {
                                debug( "false write response, pause", src._readableState.awaitDrain );
                                src._readableState.awaitDrain++;
                                increasedAwaitDrain = true
                            }
                            src.pause()
                        }
                    }

                    function onerror( er ) {
                        debug( "onerror", er );
                        unpipe();
                        dest.removeListener( "error", onerror );
                        if ( EElistenerCount( dest, "error" ) === 0 ) dest.emit( "error", er )
                    }
                    prependListener( dest, "error", onerror );

                    function onclose() {
                        dest.removeListener( "finish", onfinish );
                        unpipe()
                    }
                    dest.once( "close", onclose );

                    function onfinish() {
                        debug( "onfinish" );
                        dest.removeListener( "close", onclose );
                        unpipe()
                    }
                    dest.once( "finish", onfinish );

                    function unpipe() {
                        debug( "unpipe" );
                        src.unpipe( dest )
                    }
                    dest.emit( "pipe", src );
                    if ( !state.flowing ) {
                        debug( "pipe resume" );
                        src.resume()
                    }
                    return dest
                };

                function pipeOnDrain( src ) {
                    return function() {
                        var state = src._readableState;
                        debug( "pipeOnDrain", state.awaitDrain );
                        if ( state.awaitDrain ) state.awaitDrain--;
                        if ( state.awaitDrain === 0 && EElistenerCount( src, "data" ) ) {
                            state.flowing = true;
                            flow( src )
                        }
                    }
                }
                Readable.prototype.unpipe = function( dest ) {
                    var state = this._readableState;
                    var unpipeInfo = {
                        hasUnpiped: false
                    };
                    if ( state.pipesCount === 0 ) return this;
                    if ( state.pipesCount === 1 ) {
                        if ( dest && dest !== state.pipes ) return this;
                        if ( !dest ) dest = state.pipes;
                        state.pipes = null;
                        state.pipesCount = 0;
                        state.flowing = false;
                        if ( dest ) dest.emit( "unpipe", this, unpipeInfo );
                        return this
                    }
                    if ( !dest ) {
                        var dests = state.pipes;
                        var len = state.pipesCount;
                        state.pipes = null;
                        state.pipesCount = 0;
                        state.flowing = false;
                        for ( var i = 0; i < len; i++ ) {
                            dests[ i ].emit( "unpipe", this, unpipeInfo )
                        }
                        return this
                    }
                    var index = indexOf( state.pipes, dest );
                    if ( index === -1 ) return this;
                    state.pipes.splice( index, 1 );
                    state.pipesCount -= 1;
                    if ( state.pipesCount === 1 ) state.pipes = state.pipes[ 0 ];
                    dest.emit( "unpipe", this, unpipeInfo );
                    return this
                };
                Readable.prototype.on = function( ev, fn ) {
                    var res = Stream.prototype.on.call( this, ev, fn );
                    if ( ev === "data" ) {
                        if ( this._readableState.flowing !== false ) this.resume()
                    } else if ( ev === "readable" ) {
                        var state = this._readableState;
                        if ( !state.endEmitted && !state.readableListening ) {
                            state.readableListening = state.needReadable = true;
                            state.emittedReadable = false;
                            if ( !state.reading ) {
                                pna.nextTick( nReadingNextTick, this )
                            } else if ( state.length ) {
                                emitReadable( this )
                            }
                        }
                    }
                    return res
                };
                Readable.prototype.addListener = Readable.prototype.on;

                function nReadingNextTick( self ) {
                    debug( "readable nexttick read 0" );
                    self.read( 0 )
                }
                Readable.prototype.resume = function() {
                    var state = this._readableState;
                    if ( !state.flowing ) {
                        debug( "resume" );
                        state.flowing = true;
                        resume( this, state )
                    }
                    return this
                };

                function resume( stream, state ) {
                    if ( !state.resumeScheduled ) {
                        state.resumeScheduled = true;
                        pna.nextTick( resume_, stream, state )
                    }
                }

                function resume_( stream, state ) {
                    if ( !state.reading ) {
                        debug( "resume read 0" );
                        stream.read( 0 )
                    }
                    state.resumeScheduled = false;
                    state.awaitDrain = 0;
                    stream.emit( "resume" );
                    flow( stream );
                    if ( state.flowing && !state.reading ) stream.read( 0 )
                }
                Readable.prototype.pause = function() {
                    debug( "call pause flowing=%j", this._readableState.flowing );
                    if ( false !== this._readableState.flowing ) {
                        debug( "pause" );
                        this._readableState.flowing = false;
                        this.emit( "pause" )
                    }
                    return this
                };

                function flow( stream ) {
                    var state = stream._readableState;
                    debug( "flow", state.flowing );
                    while ( state.flowing && stream.read() !== null ) {}
                }
                Readable.prototype.wrap = function( stream ) {
                    var _this = this;
                    var state = this._readableState;
                    var paused = false;
                    stream.on( "end", function() {
                        debug( "wrapped end" );
                        if ( state.decoder && !state.ended ) {
                            var chunk = state.decoder.end();
                            if ( chunk && chunk.length ) _this.push( chunk )
                        }
                        _this.push( null )
                    } );
                    stream.on( "data", function( chunk ) {
                        debug( "wrapped data" );
                        if ( state.decoder ) chunk = state.decoder.write( chunk );
                        if ( state.objectMode && ( chunk === null || chunk === undefined ) ) return;
                        else if ( !state.objectMode && ( !chunk || !chunk.length ) ) return;
                        var ret = _this.push( chunk );
                        if ( !ret ) {
                            paused = true;
                            stream.pause()
                        }
                    } );
                    for ( var i in stream ) {
                        if ( this[ i ] === undefined && typeof stream[ i ] === "function" ) {
                            this[ i ] = function( method ) {
                                return function() {
                                    return stream[ method ].apply( stream, arguments )
                                }
                            }( i )
                        }
                    }
                    for ( var n = 0; n < kProxyEvents.length; n++ ) {
                        stream.on( kProxyEvents[ n ], this.emit.bind( this, kProxyEvents[ n ] ) )
                    }
                    this._read = function( n ) {
                        debug( "wrapped _read", n );
                        if ( paused ) {
                            paused = false;
                            stream.resume()
                        }
                    };
                    return this
                };
                Readable._fromList = fromList;

                function fromList( n, state ) {
                    if ( state.length === 0 ) return null;
                    var ret;
                    if ( state.objectMode ) ret = state.buffer.shift();
                    else if ( !n || n >= state.length ) {
                        if ( state.decoder ) ret = state.buffer.join( "" );
                        else if ( state.buffer.length === 1 ) ret = state.buffer.head.data;
                        else ret = state.buffer.concat( state.length );
                        state.buffer.clear()
                    } else {
                        ret = fromListPartial( n, state.buffer, state.decoder )
                    }
                    return ret
                }

                function fromListPartial( n, list, hasStrings ) {
                    var ret;
                    if ( n < list.head.data.length ) {
                        ret = list.head.data.slice( 0, n );
                        list.head.data = list.head.data.slice( n )
                    } else if ( n === list.head.data.length ) {
                        ret = list.shift()
                    } else {
                        ret = hasStrings ? copyFromBufferString( n, list ) : copyFromBuffer( n, list )
                    }
                    return ret
                }

                function copyFromBufferString( n, list ) {
                    var p = list.head;
                    var c = 1;
                    var ret = p.data;
                    n -= ret.length;
                    while ( p = p.next ) {
                        var str = p.data;
                        var nb = n > str.length ? str.length : n;
                        if ( nb === str.length ) ret += str;
                        else ret += str.slice( 0, n );
                        n -= nb;
                        if ( n === 0 ) {
                            if ( nb === str.length ) {
                                ++c;
                                if ( p.next ) list.head = p.next;
                                else list.head = list.tail = null
                            } else {
                                list.head = p;
                                p.data = str.slice( nb )
                            }
                            break
                        }++c
                    }
                    list.length -= c;
                    return ret
                }

                function copyFromBuffer( n, list ) {
                    var ret = Buffer.allocUnsafe( n );
                    var p = list.head;
                    var c = 1;
                    p.data.copy( ret );
                    n -= p.data.length;
                    while ( p = p.next ) {
                        var buf = p.data;
                        var nb = n > buf.length ? buf.length : n;
                        buf.copy( ret, ret.length - n, 0, nb );
                        n -= nb;
                        if ( n === 0 ) {
                            if ( nb === buf.length ) {
                                ++c;
                                if ( p.next ) list.head = p.next;
                                else list.head = list.tail = null
                            } else {
                                list.head = p;
                                p.data = buf.slice( nb )
                            }
                            break
                        }++c
                    }
                    list.length -= c;
                    return ret
                }

                function endReadable( stream ) {
                    var state = stream._readableState;
                    if ( state.length > 0 ) throw new Error( '"endReadable()" called on non-empty stream' );
                    if ( !state.endEmitted ) {
                        state.ended = true;
                        pna.nextTick( endReadableNT, state, stream )
                    }
                }

                function endReadableNT( state, stream ) {
                    if ( !state.endEmitted && state.length === 0 ) {
                        state.endEmitted = true;
                        stream.readable = false;
                        stream.emit( "end" )
                    }
                }

                function forEach( xs, f ) {
                    for ( var i = 0, l = xs.length; i < l; i++ ) {
                        f( xs[ i ], i )
                    }
                }

                function indexOf( xs, x ) {
                    for ( var i = 0, l = xs.length; i < l; i++ ) {
                        if ( xs[ i ] === x ) return i
                    }
                    return -1
                }
            } ).call( this, require( "_process" ), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {} )
        }, {
            "./_stream_duplex": 40,
            "./internal/streams/BufferList": 45,
            "./internal/streams/destroy": 46,
            "./internal/streams/stream": 47,
            _process: 38,
            "core-util-is": 5,
            events: 7,
            inherits: 30,
            isarray: 32,
            "process-nextick-args": 37,
            "safe-buffer": 60,
            "string_decoder/": 62,
            util: 2
        } ],
        43: [ function( require, module, exports ) {
            "use strict";
            module.exports = Transform;
            var Duplex = require( "./_stream_duplex" );
            var util = require( "core-util-is" );
            util.inherits = require( "inherits" );
            util.inherits( Transform, Duplex );

            function afterTransform( er, data ) {
                var ts = this._transformState;
                ts.transforming = false;
                var cb = ts.writecb;
                if ( !cb ) {
                    return this.emit( "error", new Error( "write callback called multiple times" ) )
                }
                ts.writechunk = null;
                ts.writecb = null;
                if ( data != null ) this.push( data );
                cb( er );
                var rs = this._readableState;
                rs.reading = false;
                if ( rs.needReadable || rs.length < rs.highWaterMark ) {
                    this._read( rs.highWaterMark )
                }
            }

            function Transform( options ) {
                if ( !( this instanceof Transform ) ) return new Transform( options );
                Duplex.call( this, options );
                this._transformState = {
                    afterTransform: afterTransform.bind( this ),
                    needTransform: false,
                    transforming: false,
                    writecb: null,
                    writechunk: null,
                    writeencoding: null
                };
                this._readableState.needReadable = true;
                this._readableState.sync = false;
                if ( options ) {
                    if ( typeof options.transform === "function" ) this._transform = options.transform;
                    if ( typeof options.flush === "function" ) this._flush = options.flush
                }
                this.on( "prefinish", prefinish )
            }

            function prefinish() {
                var _this = this;
                if ( typeof this._flush === "function" ) {
                    this._flush( function( er, data ) {
                        done( _this, er, data )
                    } )
                } else {
                    done( this, null, null )
                }
            }
            Transform.prototype.push = function( chunk, encoding ) {
                this._transformState.needTransform = false;
                return Duplex.prototype.push.call( this, chunk, encoding )
            };
            Transform.prototype._transform = function( chunk, encoding, cb ) {
                throw new Error( "_transform() is not implemented" )
            };
            Transform.prototype._write = function( chunk, encoding, cb ) {
                var ts = this._transformState;
                ts.writecb = cb;
                ts.writechunk = chunk;
                ts.writeencoding = encoding;
                if ( !ts.transforming ) {
                    var rs = this._readableState;
                    if ( ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark ) this._read( rs.highWaterMark )
                }
            };
            Transform.prototype._read = function( n ) {
                var ts = this._transformState;
                if ( ts.writechunk !== null && ts.writecb && !ts.transforming ) {
                    ts.transforming = true;
                    this._transform( ts.writechunk, ts.writeencoding, ts.afterTransform )
                } else {
                    ts.needTransform = true
                }
            };
            Transform.prototype._destroy = function( err, cb ) {
                var _this2 = this;
                Duplex.prototype._destroy.call( this, err, function( err2 ) {
                    cb( err2 );
                    _this2.emit( "close" )
                } )
            };

            function done( stream, er, data ) {
                if ( er ) return stream.emit( "error", er );
                if ( data != null ) stream.push( data );
                if ( stream._writableState.length ) throw new Error( "Calling transform done when ws.length != 0" );
                if ( stream._transformState.transforming ) throw new Error( "Calling transform done when still transforming" );
                return stream.push( null )
            }
        }, {
            "./_stream_duplex": 40,
            "core-util-is": 5,
            inherits: 30
        } ],
        44: [ function( require, module, exports ) {
            ( function( process, global ) {
                "use strict";
                var pna = require( "process-nextick-args" );
                module.exports = Writable;

                function WriteReq( chunk, encoding, cb ) {
                    this.chunk = chunk;
                    this.encoding = encoding;
                    this.callback = cb;
                    this.next = null
                }

                function CorkedRequest( state ) {
                    var _this = this;
                    this.next = null;
                    this.entry = null;
                    this.finish = function() {
                        onCorkedFinish( _this, state )
                    }
                }
                var asyncWrite = !process.browser && [ "v0.10", "v0.9." ].indexOf( process.version.slice( 0, 5 ) ) > -1 ? setImmediate : pna.nextTick;
                var Duplex;
                Writable.WritableState = WritableState;
                var util = require( "core-util-is" );
                util.inherits = require( "inherits" );
                var internalUtil = {
                    deprecate: require( "util-deprecate" )
                };
                var Stream = require( "./internal/streams/stream" );
                var Buffer = require( "safe-buffer" ).Buffer;
                var OurUint8Array = global.Uint8Array || function() {};

                function _uint8ArrayToBuffer( chunk ) {
                    return Buffer.from( chunk )
                }

                function _isUint8Array( obj ) {
                    return Buffer.isBuffer( obj ) || obj instanceof OurUint8Array
                }
                var destroyImpl = require( "./internal/streams/destroy" );
                util.inherits( Writable, Stream );

                function nop() {}

                function WritableState( options, stream ) {
                    Duplex = Duplex || require( "./_stream_duplex" );
                    options = options || {};
                    var isDuplex = stream instanceof Duplex;
                    this.objectMode = !!options.objectMode;
                    if ( isDuplex ) this.objectMode = this.objectMode || !!options.writableObjectMode;
                    var hwm = options.highWaterMark;
                    var writableHwm = options.writableHighWaterMark;
                    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
                    if ( hwm || hwm === 0 ) this.highWaterMark = hwm;
                    else if ( isDuplex && ( writableHwm || writableHwm === 0 ) ) this.highWaterMark = writableHwm;
                    else this.highWaterMark = defaultHwm;
                    this.highWaterMark = Math.floor( this.highWaterMark );
                    this.finalCalled = false;
                    this.needDrain = false;
                    this.ending = false;
                    this.ended = false;
                    this.finished = false;
                    this.destroyed = false;
                    var noDecode = options.decodeStrings === false;
                    this.decodeStrings = !noDecode;
                    this.defaultEncoding = options.defaultEncoding || "utf8";
                    this.length = 0;
                    this.writing = false;
                    this.corked = 0;
                    this.sync = true;
                    this.bufferProcessing = false;
                    this.onwrite = function( er ) {
                        onwrite( stream, er )
                    };
                    this.writecb = null;
                    this.writelen = 0;
                    this.bufferedRequest = null;
                    this.lastBufferedRequest = null;
                    this.pendingcb = 0;
                    this.prefinished = false;
                    this.errorEmitted = false;
                    this.bufferedRequestCount = 0;
                    this.corkedRequestsFree = new CorkedRequest( this )
                }
                WritableState.prototype.getBuffer = function getBuffer() {
                    var current = this.bufferedRequest;
                    var out = [];
                    while ( current ) {
                        out.push( current );
                        current = current.next
                    }
                    return out
                };
                ( function() {
                    try {
                        Object.defineProperty( WritableState.prototype, "buffer", {
                            get: internalUtil.deprecate( function() {
                                return this.getBuffer()
                            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003" )
                        } )
                    } catch ( _ ) {}
                } )();
                var realHasInstance;
                if ( typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[ Symbol.hasInstance ] === "function" ) {
                    realHasInstance = Function.prototype[ Symbol.hasInstance ];
                    Object.defineProperty( Writable, Symbol.hasInstance, {
                        value: function( object ) {
                            if ( realHasInstance.call( this, object ) ) return true;
                            if ( this !== Writable ) return false;
                            return object && object._writableState instanceof WritableState
                        }
                    } )
                } else {
                    realHasInstance = function( object ) {
                        return object instanceof this
                    }
                }

                function Writable( options ) {
                    Duplex = Duplex || require( "./_stream_duplex" );
                    if ( !realHasInstance.call( Writable, this ) && !( this instanceof Duplex ) ) {
                        return new Writable( options )
                    }
                    this._writableState = new WritableState( options, this );
                    this.writable = true;
                    if ( options ) {
                        if ( typeof options.write === "function" ) this._write = options.write;
                        if ( typeof options.writev === "function" ) this._writev = options.writev;
                        if ( typeof options.destroy === "function" ) this._destroy = options.destroy;
                        if ( typeof options.final === "function" ) this._final = options.final
                    }
                    Stream.call( this )
                }
                Writable.prototype.pipe = function() {
                    this.emit( "error", new Error( "Cannot pipe, not readable" ) )
                };

                function writeAfterEnd( stream, cb ) {
                    var er = new Error( "write after end" );
                    stream.emit( "error", er );
                    pna.nextTick( cb, er )
                }

                function validChunk( stream, state, chunk, cb ) {
                    var valid = true;
                    var er = false;
                    if ( chunk === null ) {
                        er = new TypeError( "May not write null values to stream" )
                    } else if ( typeof chunk !== "string" && chunk !== undefined && !state.objectMode ) {
                        er = new TypeError( "Invalid non-string/buffer chunk" )
                    }
                    if ( er ) {
                        stream.emit( "error", er );
                        pna.nextTick( cb, er );
                        valid = false
                    }
                    return valid
                }
                Writable.prototype.write = function( chunk, encoding, cb ) {
                    var state = this._writableState;
                    var ret = false;
                    var isBuf = !state.objectMode && _isUint8Array( chunk );
                    if ( isBuf && !Buffer.isBuffer( chunk ) ) {
                        chunk = _uint8ArrayToBuffer( chunk )
                    }
                    if ( typeof encoding === "function" ) {
                        cb = encoding;
                        encoding = null
                    }
                    if ( isBuf ) encoding = "buffer";
                    else if ( !encoding ) encoding = state.defaultEncoding;
                    if ( typeof cb !== "function" ) cb = nop;
                    if ( state.ended ) writeAfterEnd( this, cb );
                    else if ( isBuf || validChunk( this, state, chunk, cb ) ) {
                        state.pendingcb++;
                        ret = writeOrBuffer( this, state, isBuf, chunk, encoding, cb )
                    }
                    return ret
                };
                Writable.prototype.cork = function() {
                    var state = this._writableState;
                    state.corked++
                };
                Writable.prototype.uncork = function() {
                    var state = this._writableState;
                    if ( state.corked ) {
                        state.corked--;
                        if ( !state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest ) clearBuffer( this, state )
                    }
                };
                Writable.prototype.setDefaultEncoding = function setDefaultEncoding( encoding ) {
                    if ( typeof encoding === "string" ) encoding = encoding.toLowerCase();
                    if ( !( [ "hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw" ].indexOf( ( encoding + "" ).toLowerCase() ) > -1 ) ) throw new TypeError( "Unknown encoding: " + encoding );
                    this._writableState.defaultEncoding = encoding;
                    return this
                };

                function decodeChunk( state, chunk, encoding ) {
                    if ( !state.objectMode && state.decodeStrings !== false && typeof chunk === "string" ) {
                        chunk = Buffer.from( chunk, encoding )
                    }
                    return chunk
                }

                function writeOrBuffer( stream, state, isBuf, chunk, encoding, cb ) {
                    if ( !isBuf ) {
                        var newChunk = decodeChunk( state, chunk, encoding );
                        if ( chunk !== newChunk ) {
                            isBuf = true;
                            encoding = "buffer";
                            chunk = newChunk
                        }
                    }
                    var len = state.objectMode ? 1 : chunk.length;
                    state.length += len;
                    var ret = state.length < state.highWaterMark;
                    if ( !ret ) state.needDrain = true;
                    if ( state.writing || state.corked ) {
                        var last = state.lastBufferedRequest;
                        state.lastBufferedRequest = {
                            chunk: chunk,
                            encoding: encoding,
                            isBuf: isBuf,
                            callback: cb,
                            next: null
                        };
                        if ( last ) {
                            last.next = state.lastBufferedRequest
                        } else {
                            state.bufferedRequest = state.lastBufferedRequest
                        }
                        state.bufferedRequestCount += 1
                    } else {
                        doWrite( stream, state, false, len, chunk, encoding, cb )
                    }
                    return ret
                }

                function doWrite( stream, state, writev, len, chunk, encoding, cb ) {
                    state.writelen = len;
                    state.writecb = cb;
                    state.writing = true;
                    state.sync = true;
                    if ( writev ) stream._writev( chunk, state.onwrite );
                    else stream._write( chunk, encoding, state.onwrite );
                    state.sync = false
                }

                function onwriteError( stream, state, sync, er, cb ) {
                    --state.pendingcb;
                    if ( sync ) {
                        pna.nextTick( cb, er );
                        pna.nextTick( finishMaybe, stream, state );
                        stream._writableState.errorEmitted = true;
                        stream.emit( "error", er )
                    } else {
                        cb( er );
                        stream._writableState.errorEmitted = true;
                        stream.emit( "error", er );
                        finishMaybe( stream, state )
                    }
                }

                function onwriteStateUpdate( state ) {
                    state.writing = false;
                    state.writecb = null;
                    state.length -= state.writelen;
                    state.writelen = 0
                }

                function onwrite( stream, er ) {
                    var state = stream._writableState;
                    var sync = state.sync;
                    var cb = state.writecb;
                    onwriteStateUpdate( state );
                    if ( er ) onwriteError( stream, state, sync, er, cb );
                    else {
                        var finished = needFinish( state );
                        if ( !finished && !state.corked && !state.bufferProcessing && state.bufferedRequest ) {
                            clearBuffer( stream, state )
                        }
                        if ( sync ) {
                            asyncWrite( afterWrite, stream, state, finished, cb )
                        } else {
                            afterWrite( stream, state, finished, cb )
                        }
                    }
                }

                function afterWrite( stream, state, finished, cb ) {
                    if ( !finished ) onwriteDrain( stream, state );
                    state.pendingcb--;
                    cb();
                    finishMaybe( stream, state )
                }

                function onwriteDrain( stream, state ) {
                    if ( state.length === 0 && state.needDrain ) {
                        state.needDrain = false;
                        stream.emit( "drain" )
                    }
                }

                function clearBuffer( stream, state ) {
                    state.bufferProcessing = true;
                    var entry = state.bufferedRequest;
                    if ( stream._writev && entry && entry.next ) {
                        var l = state.bufferedRequestCount;
                        var buffer = new Array( l );
                        var holder = state.corkedRequestsFree;
                        holder.entry = entry;
                        var count = 0;
                        var allBuffers = true;
                        while ( entry ) {
                            buffer[ count ] = entry;
                            if ( !entry.isBuf ) allBuffers = false;
                            entry = entry.next;
                            count += 1
                        }
                        buffer.allBuffers = allBuffers;
                        doWrite( stream, state, true, state.length, buffer, "", holder.finish );
                        state.pendingcb++;
                        state.lastBufferedRequest = null;
                        if ( holder.next ) {
                            state.corkedRequestsFree = holder.next;
                            holder.next = null
                        } else {
                            state.corkedRequestsFree = new CorkedRequest( state )
                        }
                        state.bufferedRequestCount = 0
                    } else {
                        while ( entry ) {
                            var chunk = entry.chunk;
                            var encoding = entry.encoding;
                            var cb = entry.callback;
                            var len = state.objectMode ? 1 : chunk.length;
                            doWrite( stream, state, false, len, chunk, encoding, cb );
                            entry = entry.next;
                            state.bufferedRequestCount--;
                            if ( state.writing ) {
                                break
                            }
                        }
                        if ( entry === null ) state.lastBufferedRequest = null
                    }
                    state.bufferedRequest = entry;
                    state.bufferProcessing = false
                }
                Writable.prototype._write = function( chunk, encoding, cb ) {
                    cb( new Error( "_write() is not implemented" ) )
                };
                Writable.prototype._writev = null;
                Writable.prototype.end = function( chunk, encoding, cb ) {
                    var state = this._writableState;
                    if ( typeof chunk === "function" ) {
                        cb = chunk;
                        chunk = null;
                        encoding = null
                    } else if ( typeof encoding === "function" ) {
                        cb = encoding;
                        encoding = null
                    }
                    if ( chunk !== null && chunk !== undefined ) this.write( chunk, encoding );
                    if ( state.corked ) {
                        state.corked = 1;
                        this.uncork()
                    }
                    if ( !state.ending && !state.finished ) endWritable( this, state, cb )
                };

                function needFinish( state ) {
                    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing
                }

                function callFinal( stream, state ) {
                    stream._final( function( err ) {
                        state.pendingcb--;
                        if ( err ) {
                            stream.emit( "error", err )
                        }
                        state.prefinished = true;
                        stream.emit( "prefinish" );
                        finishMaybe( stream, state )
                    } )
                }

                function prefinish( stream, state ) {
                    if ( !state.prefinished && !state.finalCalled ) {
                        if ( typeof stream._final === "function" ) {
                            state.pendingcb++;
                            state.finalCalled = true;
                            pna.nextTick( callFinal, stream, state )
                        } else {
                            state.prefinished = true;
                            stream.emit( "prefinish" )
                        }
                    }
                }

                function finishMaybe( stream, state ) {
                    var need = needFinish( state );
                    if ( need ) {
                        prefinish( stream, state );
                        if ( state.pendingcb === 0 ) {
                            state.finished = true;
                            stream.emit( "finish" )
                        }
                    }
                    return need
                }

                function endWritable( stream, state, cb ) {
                    state.ending = true;
                    finishMaybe( stream, state );
                    if ( cb ) {
                        if ( state.finished ) pna.nextTick( cb );
                        else stream.once( "finish", cb )
                    }
                    state.ended = true;
                    stream.writable = false
                }

                function onCorkedFinish( corkReq, state, err ) {
                    var entry = corkReq.entry;
                    corkReq.entry = null;
                    while ( entry ) {
                        var cb = entry.callback;
                        state.pendingcb--;
                        cb( err );
                        entry = entry.next
                    }
                    if ( state.corkedRequestsFree ) {
                        state.corkedRequestsFree.next = corkReq
                    } else {
                        state.corkedRequestsFree = corkReq
                    }
                }
                Object.defineProperty( Writable.prototype, "destroyed", {
                    get: function() {
                        if ( this._writableState === undefined ) {
                            return false
                        }
                        return this._writableState.destroyed
                    },
                    set: function( value ) {
                        if ( !this._writableState ) {
                            return
                        }
                        this._writableState.destroyed = value
                    }
                } );
                Writable.prototype.destroy = destroyImpl.destroy;
                Writable.prototype._undestroy = destroyImpl.undestroy;
                Writable.prototype._destroy = function( err, cb ) {
                    this.end();
                    cb( err )
                }
            } ).call( this, require( "_process" ), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {} )
        }, {
            "./_stream_duplex": 40,
            "./internal/streams/destroy": 46,
            "./internal/streams/stream": 47,
            _process: 38,
            "core-util-is": 5,
            inherits: 30,
            "process-nextick-args": 37,
            "safe-buffer": 60,
            "util-deprecate": 63
        } ],
        45: [ function( require, module, exports ) {
            "use strict";

            function _classCallCheck( instance, Constructor ) {
                if ( !( instance instanceof Constructor ) ) {
                    throw new TypeError( "Cannot call a class as a function" )
                }
            }
            var Buffer = require( "safe-buffer" ).Buffer;
            var util = require( "util" );

            function copyBuffer( src, target, offset ) {
                src.copy( target, offset )
            }
            module.exports = function() {
                function BufferList() {
                    _classCallCheck( this, BufferList );
                    this.head = null;
                    this.tail = null;
                    this.length = 0
                }
                BufferList.prototype.push = function push( v ) {
                    var entry = {
                        data: v,
                        next: null
                    };
                    if ( this.length > 0 ) this.tail.next = entry;
                    else this.head = entry;
                    this.tail = entry;
                    ++this.length
                };
                BufferList.prototype.unshift = function unshift( v ) {
                    var entry = {
                        data: v,
                        next: this.head
                    };
                    if ( this.length === 0 ) this.tail = entry;
                    this.head = entry;
                    ++this.length
                };
                BufferList.prototype.shift = function shift() {
                    if ( this.length === 0 ) return;
                    var ret = this.head.data;
                    if ( this.length === 1 ) this.head = this.tail = null;
                    else this.head = this.head.next;
                    --this.length;
                    return ret
                };
                BufferList.prototype.clear = function clear() {
                    this.head = this.tail = null;
                    this.length = 0
                };
                BufferList.prototype.join = function join( s ) {
                    if ( this.length === 0 ) return "";
                    var p = this.head;
                    var ret = "" + p.data;
                    while ( p = p.next ) {
                        ret += s + p.data
                    }
                    return ret
                };
                BufferList.prototype.concat = function concat( n ) {
                    if ( this.length === 0 ) return Buffer.alloc( 0 );
                    if ( this.length === 1 ) return this.head.data;
                    var ret = Buffer.allocUnsafe( n >>> 0 );
                    var p = this.head;
                    var i = 0;
                    while ( p ) {
                        copyBuffer( p.data, ret, i );
                        i += p.data.length;
                        p = p.next
                    }
                    return ret
                };
                return BufferList
            }();
            if ( util && util.inspect && util.inspect.custom ) {
                module.exports.prototype[ util.inspect.custom ] = function() {
                    var obj = util.inspect( {
                        length: this.length
                    } );
                    return this.constructor.name + " " + obj
                }
            }
        }, {
            "safe-buffer": 60,
            util: 2
        } ],
        46: [ function( require, module, exports ) {
            "use strict";
            var pna = require( "process-nextick-args" );

            function destroy( err, cb ) {
                var _this = this;
                var readableDestroyed = this._readableState && this._readableState.destroyed;
                var writableDestroyed = this._writableState && this._writableState.destroyed;
                if ( readableDestroyed || writableDestroyed ) {
                    if ( cb ) {
                        cb( err )
                    } else if ( err && ( !this._writableState || !this._writableState.errorEmitted ) ) {
                        pna.nextTick( emitErrorNT, this, err )
                    }
                    return this
                }
                if ( this._readableState ) {
                    this._readableState.destroyed = true
                }
                if ( this._writableState ) {
                    this._writableState.destroyed = true
                }
                this._destroy( err || null, function( err ) {
                    if ( !cb && err ) {
                        pna.nextTick( emitErrorNT, _this, err );
                        if ( _this._writableState ) {
                            _this._writableState.errorEmitted = true
                        }
                    } else if ( cb ) {
                        cb( err )
                    }
                } );
                return this
            }

            function undestroy() {
                if ( this._readableState ) {
                    this._readableState.destroyed = false;
                    this._readableState.reading = false;
                    this._readableState.ended = false;
                    this._readableState.endEmitted = false
                }
                if ( this._writableState ) {
                    this._writableState.destroyed = false;
                    this._writableState.ended = false;
                    this._writableState.ending = false;
                    this._writableState.finished = false;
                    this._writableState.errorEmitted = false
                }
            }

            function emitErrorNT( self, err ) {
                self.emit( "error", err )
            }
            module.exports = {
                destroy: destroy,
                undestroy: undestroy
            }
        }, {
            "process-nextick-args": 37
        } ],
        47: [ function( require, module, exports ) {
            module.exports = require( "events" ).EventEmitter
        }, {
            events: 7
        } ],
        48: [ function( require, module, exports ) {
            module.exports = require( "./readable" ).PassThrough
        }, {
            "./readable": 49
        } ],
        49: [ function( require, module, exports ) {
            exports = module.exports = require( "./lib/_stream_readable.js" );
            exports.Stream = exports;
            exports.Readable = exports;
            exports.Writable = require( "./lib/_stream_writable.js" );
            exports.Duplex = require( "./lib/_stream_duplex.js" );
            exports.Transform = require( "./lib/_stream_transform.js" );
            exports.PassThrough = require( "./lib/_stream_passthrough.js" )
        }, {
            "./lib/_stream_duplex.js": 40,
            "./lib/_stream_passthrough.js": 41,
            "./lib/_stream_readable.js": 42,
            "./lib/_stream_transform.js": 43,
            "./lib/_stream_writable.js": 44
        } ],
        50: [ function( require, module, exports ) {
            module.exports = require( "./readable" ).Transform
        }, {
            "./readable": 49
        } ],
        51: [ function( require, module, exports ) {
            module.exports = require( "./lib/_stream_writable.js" )
        }, {
            "./lib/_stream_writable.js": 44
        } ],
        52: [ function( require, module, exports ) {
            exports.dash = require( "./lib/rw/dash" );
            exports.readFile = require( "./lib/rw/read-file" );
            exports.readFileSync = require( "./lib/rw/read-file-sync" );
            exports.writeFile = require( "./lib/rw/write-file" );
            exports.writeFileSync = require( "./lib/rw/write-file-sync" )
        }, {
            "./lib/rw/dash": 53,
            "./lib/rw/read-file": 57,
            "./lib/rw/read-file-sync": 56,
            "./lib/rw/write-file": 59,
            "./lib/rw/write-file-sync": 58
        } ],
        53: [ function( require, module, exports ) {
            var slice = Array.prototype.slice;

            function dashify( method, file ) {
                return function( path ) {
                    var argv = arguments;
                    if ( path == "-" )( argv = slice.call( argv ) ).splice( 0, 1, file );
                    return method.apply( null, argv )
                }
            }
            exports.readFile = dashify( require( "./read-file" ), "/dev/stdin" );
            exports.readFileSync = dashify( require( "./read-file-sync" ), "/dev/stdin" );
            exports.writeFile = dashify( require( "./write-file" ), "/dev/stdout" );
            exports.writeFileSync = dashify( require( "./write-file-sync" ), "/dev/stdout" )
        }, {
            "./read-file": 57,
            "./read-file-sync": 56,
            "./write-file": 59,
            "./write-file-sync": 58
        } ],
        54: [ function( require, module, exports ) {
            ( function( Buffer ) {
                module.exports = function( options ) {
                    if ( options ) {
                        if ( typeof options === "string" ) return encoding( options );
                        if ( options.encoding !== null ) return encoding( options.encoding )
                    }
                    return identity()
                };

                function identity() {
                    var chunks = [];
                    return {
                        push: function( chunk ) {
                            chunks.push( chunk )
                        },
                        value: function() {
                            return Buffer.concat( chunks )
                        }
                    }
                }

                function encoding( encoding ) {
                    var chunks = [];
                    return {
                        push: function( chunk ) {
                            chunks.push( chunk )
                        },
                        value: function() {
                            return Buffer.concat( chunks ).toString( encoding )
                        }
                    }
                }
            } ).call( this, require( "buffer" ).Buffer )
        }, {
            buffer: 4
        } ],
        55: [ function( require, module, exports ) {
            ( function( Buffer ) {
                module.exports = function( data, options ) {
                    return typeof data === "string" ? new Buffer( data, typeof options === "string" ? options : options && options.encoding !== null ? options.encoding : "utf8" ) : data
                }
            } ).call( this, require( "buffer" ).Buffer )
        }, {
            buffer: 4
        } ],
        56: [ function( require, module, exports ) {
            ( function( Buffer ) {
                var fs = require( "fs" ),
                    decode = require( "./decode" );
                module.exports = function( filename, options ) {
                    if ( fs.statSync( filename ).isFile() ) {
                        return fs.readFileSync( filename, options )
                    } else {
                        var fd = fs.openSync( filename, options && options.flag || "r" ),
                            decoder = decode( options );
                        while ( true ) {
                            try {
                                var buffer = new Buffer( bufferSize ),
                                    bytesRead = fs.readSync( fd, buffer, 0, bufferSize )
                            } catch ( e ) {
                                if ( e.code === "EOF" ) break;
                                fs.closeSync( fd );
                                throw e
                            }
                            if ( bytesRead === 0 ) break;
                            decoder.push( buffer.slice( 0, bytesRead ) )
                        }
                        fs.closeSync( fd );
                        return decoder.value()
                    }
                };
                var bufferSize = 1 << 16
            } ).call( this, require( "buffer" ).Buffer )
        }, {
            "./decode": 54,
            buffer: 4,
            fs: 3
        } ],
        57: [ function( require, module, exports ) {
            ( function( process ) {
                var fs = require( "fs" ),
                    decode = require( "./decode" );
                module.exports = function( path, options, callback ) {
                    if ( arguments.length < 3 ) callback = options, options = null;
                    switch ( path ) {
                        case "/dev/stdin":
                            return readStream( process.stdin, options, callback )
                    }
                    fs.stat( path, function( error, stat ) {
                        if ( error ) return callback( error );
                        if ( stat.isFile() ) return fs.readFile( path, options, callback );
                        readStream( fs.createReadStream( path, options ? {
                            flags: options.flag || "r"
                        } : {} ), options, callback )
                    } )
                };

                function readStream( stream, options, callback ) {
                    var decoder = decode( options );
                    stream.on( "error", callback );
                    stream.on( "data", function( d ) {
                        decoder.push( d )
                    } );
                    stream.on( "end", function() {
                        callback( null, decoder.value() )
                    } )
                }
            } ).call( this, require( "_process" ) )
        }, {
            "./decode": 54,
            _process: 38,
            fs: 3
        } ],
        58: [ function( require, module, exports ) {
            var fs = require( "fs" ),
                encode = require( "./encode" );
            module.exports = function( filename, data, options ) {
                var stat;
                try {
                    stat = fs.statSync( filename )
                } catch ( error ) {
                    if ( error.code !== "ENOENT" ) throw error
                }
                if ( !stat || stat.isFile() ) {
                    fs.writeFileSync( filename, data, options )
                } else {
                    var fd = fs.openSync( filename, options && options.flag || "w" ),
                        bytesWritten = 0,
                        bytesTotal = ( data = encode( data, options ) ).length;
                    while ( bytesWritten < bytesTotal ) {
                        try {
                            bytesWritten += fs.writeSync( fd, data, bytesWritten, bytesTotal - bytesWritten, null )
                        } catch ( error ) {
                            if ( error.code === "EPIPE" ) break;
                            fs.closeSync( fd );
                            throw error
                        }
                    }
                    fs.closeSync( fd )
                }
            }
        }, {
            "./encode": 55,
            fs: 3
        } ],
        59: [ function( require, module, exports ) {
            ( function( process ) {
                var fs = require( "fs" ),
                    encode = require( "./encode" );
                module.exports = function( path, data, options, callback ) {
                    if ( arguments.length < 4 ) callback = options, options = null;
                    switch ( path ) {
                        case "/dev/stdout":
                            return writeStream( process.stdout, "write", data, options, callback );
                        case "/dev/stderr":
                            return writeStream( process.stderr, "write", data, options, callback )
                    }
                    fs.stat( path, function( error, stat ) {
                        if ( error && error.code !== "ENOENT" ) return callback( error );
                        if ( stat && stat.isFile() ) return fs.writeFile( path, data, options, callback );
                        writeStream( fs.createWriteStream( path, options ? {
                            flags: options.flag || "w"
                        } : {} ), "end", data, options, callback )
                    } )
                };

                function writeStream( stream, send, data, options, callback ) {
                    stream.on( "error", function( error ) {
                        callback( error.code === "EPIPE" ? null : error )
                    } );
                    stream[ send ]( encode( data, options ), function( error ) {
                        callback( error && error.code === "EPIPE" ? null : error )
                    } )
                }
            } ).call( this, require( "_process" ) )
        }, {
            "./encode": 55,
            _process: 38,
            fs: 3
        } ],
        60: [ function( require, module, exports ) {
            var buffer = require( "buffer" );
            var Buffer = buffer.Buffer;

            function copyProps( src, dst ) {
                for ( var key in src ) {
                    dst[ key ] = src[ key ]
                }
            }
            if ( Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow ) {
                module.exports = buffer
            } else {
                copyProps( buffer, exports );
                exports.Buffer = SafeBuffer
            }

            function SafeBuffer( arg, encodingOrOffset, length ) {
                return Buffer( arg, encodingOrOffset, length )
            }
            copyProps( Buffer, SafeBuffer );
            SafeBuffer.from = function( arg, encodingOrOffset, length ) {
                if ( typeof arg === "number" ) {
                    throw new TypeError( "Argument must not be a number" )
                }
                return Buffer( arg, encodingOrOffset, length )
            };
            SafeBuffer.alloc = function( size, fill, encoding ) {
                if ( typeof size !== "number" ) {
                    throw new TypeError( "Argument must be a number" )
                }
                var buf = Buffer( size );
                if ( fill !== undefined ) {
                    if ( typeof encoding === "string" ) {
                        buf.fill( fill, encoding )
                    } else {
                        buf.fill( fill )
                    }
                } else {
                    buf.fill( 0 )
                }
                return buf
            };
            SafeBuffer.allocUnsafe = function( size ) {
                if ( typeof size !== "number" ) {
                    throw new TypeError( "Argument must be a number" )
                }
                return Buffer( size )
            };
            SafeBuffer.allocUnsafeSlow = function( size ) {
                if ( typeof size !== "number" ) {
                    throw new TypeError( "Argument must be a number" )
                }
                return buffer.SlowBuffer( size )
            }
        }, {
            buffer: 4
        } ],
        61: [ function( require, module, exports ) {
            module.exports = Stream;
            var EE = require( "events" ).EventEmitter;
            var inherits = require( "inherits" );
            inherits( Stream, EE );
            Stream.Readable = require( "readable-stream/readable.js" );
            Stream.Writable = require( "readable-stream/writable.js" );
            Stream.Duplex = require( "readable-stream/duplex.js" );
            Stream.Transform = require( "readable-stream/transform.js" );
            Stream.PassThrough = require( "readable-stream/passthrough.js" );
            Stream.Stream = Stream;

            function Stream() {
                EE.call( this )
            }
            Stream.prototype.pipe = function( dest, options ) {
                var source = this;

                function ondata( chunk ) {
                    if ( dest.writable ) {
                        if ( false === dest.write( chunk ) && source.pause ) {
                            source.pause()
                        }
                    }
                }
                source.on( "data", ondata );

                function ondrain() {
                    if ( source.readable && source.resume ) {
                        source.resume()
                    }
                }
                dest.on( "drain", ondrain );
                if ( !dest._isStdio && ( !options || options.end !== false ) ) {
                    source.on( "end", onend );
                    source.on( "close", onclose )
                }
                var didOnEnd = false;

                function onend() {
                    if ( didOnEnd ) return;
                    didOnEnd = true;
                    dest.end()
                }

                function onclose() {
                    if ( didOnEnd ) return;
                    didOnEnd = true;
                    if ( typeof dest.destroy === "function" ) dest.destroy()
                }

                function onerror( er ) {
                    cleanup();
                    if ( EE.listenerCount( this, "error" ) === 0 ) {
                        throw er
                    }
                }
                source.on( "error", onerror );
                dest.on( "error", onerror );

                function cleanup() {
                    source.removeListener( "data", ondata );
                    dest.removeListener( "drain", ondrain );
                    source.removeListener( "end", onend );
                    source.removeListener( "close", onclose );
                    source.removeListener( "error", onerror );
                    dest.removeListener( "error", onerror );
                    source.removeListener( "end", cleanup );
                    source.removeListener( "close", cleanup );
                    dest.removeListener( "close", cleanup )
                }
                source.on( "end", cleanup );
                source.on( "close", cleanup );
                dest.on( "close", cleanup );
                dest.emit( "pipe", source );
                return dest
            }
        }, {
            events: 7,
            inherits: 30,
            "readable-stream/duplex.js": 39,
            "readable-stream/passthrough.js": 48,
            "readable-stream/readable.js": 49,
            "readable-stream/transform.js": 50,
            "readable-stream/writable.js": 51
        } ],
        62: [ function( require, module, exports ) {
            "use strict";
            var Buffer = require( "safe-buffer" ).Buffer;
            var isEncoding = Buffer.isEncoding || function( encoding ) {
                encoding = "" + encoding;
                switch ( encoding && encoding.toLowerCase() ) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                    case "raw":
                        return true;
                    default:
                        return false
                }
            };

            function _normalizeEncoding( enc ) {
                if ( !enc ) return "utf8";
                var retried;
                while ( true ) {
                    switch ( enc ) {
                        case "utf8":
                        case "utf-8":
                            return "utf8";
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return "utf16le";
                        case "latin1":
                        case "binary":
                            return "latin1";
                        case "base64":
                        case "ascii":
                        case "hex":
                            return enc;
                        default:
                            if ( retried ) return;
                            enc = ( "" + enc ).toLowerCase();
                            retried = true
                    }
                }
            }

            function normalizeEncoding( enc ) {
                var nenc = _normalizeEncoding( enc );
                if ( typeof nenc !== "string" && ( Buffer.isEncoding === isEncoding || !isEncoding( enc ) ) ) throw new Error( "Unknown encoding: " + enc );
                return nenc || enc
            }
            exports.StringDecoder = StringDecoder;

            function StringDecoder( encoding ) {
                this.encoding = normalizeEncoding( encoding );
                var nb;
                switch ( this.encoding ) {
                    case "utf16le":
                        this.text = utf16Text;
                        this.end = utf16End;
                        nb = 4;
                        break;
                    case "utf8":
                        this.fillLast = utf8FillLast;
                        nb = 4;
                        break;
                    case "base64":
                        this.text = base64Text;
                        this.end = base64End;
                        nb = 3;
                        break;
                    default:
                        this.write = simpleWrite;
                        this.end = simpleEnd;
                        return
                }
                this.lastNeed = 0;
                this.lastTotal = 0;
                this.lastChar = Buffer.allocUnsafe( nb )
            }
            StringDecoder.prototype.write = function( buf ) {
                if ( buf.length === 0 ) return "";
                var r;
                var i;
                if ( this.lastNeed ) {
                    r = this.fillLast( buf );
                    if ( r === undefined ) return "";
                    i = this.lastNeed;
                    this.lastNeed = 0
                } else {
                    i = 0
                }
                if ( i < buf.length ) return r ? r + this.text( buf, i ) : this.text( buf, i );
                return r || ""
            };
            StringDecoder.prototype.end = utf8End;
            StringDecoder.prototype.text = utf8Text;
            StringDecoder.prototype.fillLast = function( buf ) {
                if ( this.lastNeed <= buf.length ) {
                    buf.copy( this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed );
                    return this.lastChar.toString( this.encoding, 0, this.lastTotal )
                }
                buf.copy( this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length );
                this.lastNeed -= buf.length
            };

            function utf8CheckByte( byte ) {
                if ( byte <= 127 ) return 0;
                else if ( byte >> 5 === 6 ) return 2;
                else if ( byte >> 4 === 14 ) return 3;
                else if ( byte >> 3 === 30 ) return 4;
                return -1
            }

            function utf8CheckIncomplete( self, buf, i ) {
                var j = buf.length - 1;
                if ( j < i ) return 0;
                var nb = utf8CheckByte( buf[ j ] );
                if ( nb >= 0 ) {
                    if ( nb > 0 ) self.lastNeed = nb - 1;
                    return nb
                }
                if ( --j < i ) return 0;
                nb = utf8CheckByte( buf[ j ] );
                if ( nb >= 0 ) {
                    if ( nb > 0 ) self.lastNeed = nb - 2;
                    return nb
                }
                if ( --j < i ) return 0;
                nb = utf8CheckByte( buf[ j ] );
                if ( nb >= 0 ) {
                    if ( nb > 0 ) {
                        if ( nb === 2 ) nb = 0;
                        else self.lastNeed = nb - 3
                    }
                    return nb
                }
                return 0
            }

            function utf8CheckExtraBytes( self, buf, p ) {
                if ( ( buf[ 0 ] & 192 ) !== 128 ) {
                    self.lastNeed = 0;
                    return "".repeat( p )
                }
                if ( self.lastNeed > 1 && buf.length > 1 ) {
                    if ( ( buf[ 1 ] & 192 ) !== 128 ) {
                        self.lastNeed = 1;
                        return "".repeat( p + 1 )
                    }
                    if ( self.lastNeed > 2 && buf.length > 2 ) {
                        if ( ( buf[ 2 ] & 192 ) !== 128 ) {
                            self.lastNeed = 2;
                            return "".repeat( p + 2 )
                        }
                    }
                }
            }

            function utf8FillLast( buf ) {
                var p = this.lastTotal - this.lastNeed;
                var r = utf8CheckExtraBytes( this, buf, p );
                if ( r !== undefined ) return r;
                if ( this.lastNeed <= buf.length ) {
                    buf.copy( this.lastChar, p, 0, this.lastNeed );
                    return this.lastChar.toString( this.encoding, 0, this.lastTotal )
                }
                buf.copy( this.lastChar, p, 0, buf.length );
                this.lastNeed -= buf.length
            }

            function utf8Text( buf, i ) {
                var total = utf8CheckIncomplete( this, buf, i );
                if ( !this.lastNeed ) return buf.toString( "utf8", i );
                this.lastTotal = total;
                var end = buf.length - ( total - this.lastNeed );
                buf.copy( this.lastChar, 0, end );
                return buf.toString( "utf8", i, end )
            }

            function utf8End( buf ) {
                var r = buf && buf.length ? this.write( buf ) : "";
                if ( this.lastNeed ) return r + "".repeat( this.lastTotal - this.lastNeed );
                return r
            }

            function utf16Text( buf, i ) {
                if ( ( buf.length - i ) % 2 === 0 ) {
                    var r = buf.toString( "utf16le", i );
                    if ( r ) {
                        var c = r.charCodeAt( r.length - 1 );
                        if ( c >= 55296 && c <= 56319 ) {
                            this.lastNeed = 2;
                            this.lastTotal = 4;
                            this.lastChar[ 0 ] = buf[ buf.length - 2 ];
                            this.lastChar[ 1 ] = buf[ buf.length - 1 ];
                            return r.slice( 0, -1 )
                        }
                    }
                    return r
                }
                this.lastNeed = 1;
                this.lastTotal = 2;
                this.lastChar[ 0 ] = buf[ buf.length - 1 ];
                return buf.toString( "utf16le", i, buf.length - 1 )
            }

            function utf16End( buf ) {
                var r = buf && buf.length ? this.write( buf ) : "";
                if ( this.lastNeed ) {
                    var end = this.lastTotal - this.lastNeed;
                    return r + this.lastChar.toString( "utf16le", 0, end )
                }
                return r
            }

            function base64Text( buf, i ) {
                var n = ( buf.length - i ) % 3;
                if ( n === 0 ) return buf.toString( "base64", i );
                this.lastNeed = 3 - n;
                this.lastTotal = 3;
                if ( n === 1 ) {
                    this.lastChar[ 0 ] = buf[ buf.length - 1 ]
                } else {
                    this.lastChar[ 0 ] = buf[ buf.length - 2 ];
                    this.lastChar[ 1 ] = buf[ buf.length - 1 ]
                }
                return buf.toString( "base64", i, buf.length - n )
            }

            function base64End( buf ) {
                var r = buf && buf.length ? this.write( buf ) : "";
                if ( this.lastNeed ) return r + this.lastChar.toString( "base64", 0, 3 - this.lastNeed );
                return r
            }

            function simpleWrite( buf ) {
                return buf.toString( this.encoding )
            }

            function simpleEnd( buf ) {
                return buf && buf.length ? this.write( buf ) : ""
            }
        }, {
            "safe-buffer": 60
        } ],
        63: [ function( require, module, exports ) {
            ( function( global ) {
                module.exports = deprecate;

                function deprecate( fn, msg ) {
                    if ( config( "noDeprecation" ) ) {
                        return fn
                    }
                    var warned = false;

                    function deprecated() {
                        if ( !warned ) {
                            if ( config( "throwDeprecation" ) ) {
                                throw new Error( msg )
                            } else if ( config( "traceDeprecation" ) ) {
                                console.trace( msg )
                            } else {
                                console.warn( msg )
                            }
                            warned = true
                        }
                        return fn.apply( this, arguments )
                    }
                    return deprecated
                }

                function config( name ) {
                    try {
                        if ( !global.localStorage ) return false
                    } catch ( _ ) {
                        return false
                    }
                    var val = global.localStorage[ name ];
                    if ( null == val ) return false;
                    return String( val ).toLowerCase() === "true"
                }
            } ).call( this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {} )
        }, {} ]
    }, {}, [ 34 ] )( 34 )
} );